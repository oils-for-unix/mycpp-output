// _gen/asdl/examples/typed_arith.asdl.cc is generated by asdl_main.py

#include "_gen/asdl/examples/typed_arith.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;


namespace typed_arith_asdl {


hnode_t* pipeline::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("pipeline"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->negated);
  L->append(Alloc<Field>(StrFromC("negated"), x0));

  return out_node;
}

BigStr* arith_expr_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case arith_expr_e::NoOp:
    v = "NoOp"; break;
  case arith_expr_e::Const:
    v = "Const"; break;
  case arith_expr_e::Big:
    v = "Big"; break;
  case arith_expr_e::Var:
    v = "Var"; break;
  case arith_expr_e::Unary:
    v = "Unary"; break;
  case arith_expr_e::Binary:
    v = "Binary"; break;
  case arith_expr_e::Ternary:
    v = "Ternary"; break;
  case arith_expr_e::FuncCall:
    v = "FuncCall"; break;
  case arith_expr_e::Index:
    v = "Index"; break;
  case arith_expr_e::Slice:
    v = "Slice"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "arith_expr.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

arith_expr__NoOp* arith_expr::NoOp = &garith_expr__NoOp.obj;

GcGlobal<arith_expr__NoOp> garith_expr__NoOp = 
  { ObjHeader::Global(arith_expr_e::NoOp) };

hnode_t* arith_expr__NoOp::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  return out_node;
}


hnode_t* arith_expr__Const::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->i);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}


hnode_t* arith_expr__Big::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->b);
  L->append(Alloc<Field>(StrFromC("b"), x0));

  return out_node;
}


hnode_t* arith_expr__Var::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->name);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  return out_node;
}


hnode_t* arith_expr__Unary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->op);
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->a->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("a"), x1));

  return out_node;
}


hnode_t* arith_expr__Binary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->op);
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->left->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}


hnode_t* arith_expr__Ternary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen)
                                         {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->cond->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("cond"), x0));

  hnode_t* x1 = this->true_expr->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("true_expr"), x1));

  hnode_t* x2 = this->false_expr->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("false_expr"), x2));

  return out_node;
}


hnode_t* arith_expr__FuncCall::PrettyTree(bool do_abbrev, Dict<int, bool>*
                                          seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->name);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->args != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<arith_expr_t*> it(this->args); !it.Done(); it.Next()) {
      arith_expr_t* v_ = it.Value();
      hnode_t* h = (v_ == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                    color_e::OtherConst) : v_->PrettyTree(do_abbrev, seen);
      x1->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("args"), x1));
  }

  return out_node;
}


hnode_t* arith_expr__Index::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->a->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("a"), x0));

  hnode_t* x1 = this->index->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("index"), x1));

  return out_node;
}


hnode_t* arith_expr__Slice::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->a->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("a"), x0));

  if (this->begin) {  // Optional
    hnode_t* x1 = this->begin->PrettyTree(do_abbrev, seen);
    L->append(Alloc<Field>(StrFromC("begin"), x1));
  }

  if (this->end) {  // Optional
    hnode_t* x2 = this->end->PrettyTree(do_abbrev, seen);
    L->append(Alloc<Field>(StrFromC("end"), x2));
  }

  if (this->stride) {  // Optional
    hnode_t* x3 = this->stride->PrettyTree(do_abbrev, seen);
    L->append(Alloc<Field>(StrFromC("stride"), x3));
  }

  return out_node;
}


hnode_t* arith_expr_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case arith_expr_e::NoOp: {
    arith_expr__NoOp* obj = static_cast<arith_expr__NoOp*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Const: {
    arith_expr__Const* obj = static_cast<arith_expr__Const*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Big: {
    arith_expr__Big* obj = static_cast<arith_expr__Big*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Var: {
    arith_expr__Var* obj = static_cast<arith_expr__Var*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Unary: {
    arith_expr__Unary* obj = static_cast<arith_expr__Unary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Binary: {
    arith_expr__Binary* obj = static_cast<arith_expr__Binary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Ternary: {
    arith_expr__Ternary* obj = static_cast<arith_expr__Ternary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::FuncCall: {
    arith_expr__FuncCall* obj = static_cast<arith_expr__FuncCall*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Index: {
    arith_expr__Index* obj = static_cast<arith_expr__Index*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Slice: {
    arith_expr__Slice* obj = static_cast<arith_expr__Slice*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

}  // namespace typed_arith_asdl
