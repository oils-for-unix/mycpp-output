// _gen/asdl/examples/typed_arith.asdl.h is generated by asdl_main.py

#ifndef TYPED_ARITH_ASDL
#define TYPED_ARITH_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "asdl/cpp_runtime.h"
namespace typed_arith_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class pipeline;
class arith_expr_t;

ASDL_NAMES arith_expr_e {
  enum no_name {
  NoOp = 1,
  Const = 2,
  Big = 3,
  Var = 4,
  Unary = 5,
  Binary = 6,
  Ternary = 7,
  FuncCall = 8,
  Index = 9,
  Slice = 10,
  };
};

BigStr* arith_expr_str(int tag, bool dot = true);

class arith_expr_t {
 protected:
  arith_expr_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 256;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(arith_expr_t)
};

class arith_expr__NoOp : public arith_expr_t {
 public:
  arith_expr__NoOp() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::NoOp), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__NoOp)
};

class arith_expr__Const : public arith_expr_t {
 public:
  arith_expr__Const(int i)
      : i(i) {
  }

  static arith_expr__Const* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Const>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Const), 0);
  }
  int i;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Const)
};

class arith_expr__Big : public arith_expr_t {
 public:
  arith_expr__Big(mops::BigInt b)
      : b(b) {
  }

  static arith_expr__Big* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Big>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Big), 0);
  }
  mops::BigInt b;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Big)
};

class arith_expr__Var : public arith_expr_t {
 public:
  arith_expr__Var(BigStr* name)
      : name(name) {
  }

  static arith_expr__Var* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Var>(kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Var), 1);
  }
  BigStr* name;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Var)
};

class arith_expr__Unary : public arith_expr_t {
 public:
  arith_expr__Unary(BigStr* op, arith_expr_t* a)
      : op(op),
        a(a) {
  }

  static arith_expr__Unary* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Unary>(kEmptyString, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Unary), 2);
  }
  BigStr* op;
  arith_expr_t* a;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Unary)
};

class arith_expr__Binary : public arith_expr_t {
 public:
  arith_expr__Binary(BigStr* op, arith_expr_t* left, arith_expr_t* right)
      : op(op),
        left(left),
        right(right) {
  }

  static arith_expr__Binary* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Binary>(kEmptyString, nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Binary), 3);
  }
  BigStr* op;
  arith_expr_t* left;
  arith_expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Binary)
};

class arith_expr__Ternary : public arith_expr_t {
 public:
  arith_expr__Ternary(arith_expr_t* cond, arith_expr_t* true_expr,
                      arith_expr_t* false_expr)
      : cond(cond),
        true_expr(true_expr),
        false_expr(false_expr) {
  }

  static arith_expr__Ternary* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Ternary>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Ternary),
                                3);
  }
  arith_expr_t* cond;
  arith_expr_t* true_expr;
  arith_expr_t* false_expr;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Ternary)
};

class arith_expr__FuncCall : public arith_expr_t {
 public:
  arith_expr__FuncCall(BigStr* name, List<arith_expr_t*>* args)
      : name(name),
        args(args) {
  }

  static arith_expr__FuncCall* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__FuncCall>(kEmptyString, alloc_lists ?
                                       Alloc<List<arith_expr_t*>>() : nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::FuncCall),
                                2);
  }
  BigStr* name;
  List<arith_expr_t*>* args;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__FuncCall)
};

class arith_expr__Index : public arith_expr_t {
 public:
  arith_expr__Index(arith_expr_t* a, arith_expr_t* index)
      : a(a),
        index(index) {
  }

  static arith_expr__Index* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Index>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Index), 2);
  }
  arith_expr_t* a;
  arith_expr_t* index;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Index)
};

class arith_expr__Slice : public arith_expr_t {
 public:
  arith_expr__Slice(arith_expr_t* a, arith_expr_t* begin, arith_expr_t* end,
                    arith_expr_t* stride)
      : a(a),
        begin(begin),
        end(end),
        stride(stride) {
  }

  static arith_expr__Slice* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Slice>(nullptr, nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Slice), 4);
  }
  arith_expr_t* a;
  arith_expr_t* begin;
  arith_expr_t* end;
  arith_expr_t* stride;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Slice)
};

extern GcGlobal<arith_expr__NoOp> garith_expr__NoOp;
ASDL_NAMES arith_expr {
  static arith_expr__NoOp* NoOp;
  typedef arith_expr__Const Const;
  typedef arith_expr__Big Big;
  typedef arith_expr__Var Var;
  typedef arith_expr__Unary Unary;
  typedef arith_expr__Binary Binary;
  typedef arith_expr__Ternary Ternary;
  typedef arith_expr__FuncCall FuncCall;
  typedef arith_expr__Index Index;
  typedef arith_expr__Slice Slice;
};

class pipeline {
 public:
  pipeline(bool negated)
      : negated(negated) {
  }

  static pipeline* CreateNull(bool alloc_lists = false) { 
    return Alloc<pipeline>(false);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(64, 0);
  }
  bool negated;

  DISALLOW_COPY_AND_ASSIGN(pipeline)
};


}  // namespace typed_arith_asdl

#endif  // TYPED_ARITH_ASDL
