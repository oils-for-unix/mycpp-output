// This file is GENERATED by mycpp, from Python source code

#include "bin/osh_parse_preamble.h"

namespace runtime {  // forward declare
  class TraversalState;
}

namespace vm {  // forward declare
  class ControlFlow;
  class IntControlFlow;
  class ValueControlFlow;
  class _Executor;
  class _AssignBuiltin;
  class _Builtin;
  class _Callable;
  class ctx_MaybePure;
  class ctx_Redirect;
  class ctx_ProcessSub;
  class ctx_FlushStdout;
}

namespace format {  // forward declare
}

namespace osh_parse {  // forward declare
}

namespace alloc {  // forward declare
  class ctx_SourceCode;
  class Arena;
  class LosslessArena;
  class DynamicArena;
}

namespace bash_impl {  // forward declare
  class ArrayIndexEvaluator;
}

namespace error {  // forward declare
  class _ErrorWithLocation;
  class Usage;
  class Parse;
  class WordFailure;
  class FailGlob;
  class VarSubFailure;
  class RedirectEval;
  class FatalRuntime;
  class Strict;
  class ErrExit;
  class Expr;
  class Structured;
  class AssertionErr;
  class TypeErrVerbose;
  class TypeErr;
  class Runtime;
  class Decode;
  class Encode;
}

namespace num {  // forward declare
}

namespace state {  // forward declare
  class ctx_Source;
  class ctx_DebugTrap;
  class ctx_ErrTrap;
  class ctx_Option;
  class ctx_AssignBuiltin;
  class ctx_YshExpr;
  class ctx_ErrExit;
  class OptHook;
  class MutableOpts;
  class _ArgFrame;
  class ctx_FuncCall;
  class ctx_ProcCall;
  class ctx_EvalInFrame;
  class ctx_Temp;
  class ctx_EnvObj;
  class ctx_Registers;
  class ctx_ThisDir;
  class ctx_LoopFrame;
  class ctx_EnclosedFrame;
  class ctx_CompoundWordDebugFrame;
  class ctx_TokenDebugFrame;
  class ctx_ModuleEval;
  class ctx_Eval;
  class Mem;
  class Procs;
}

namespace util {  // forward declare
  class UserExit;
  class HistoryError;
  class _DebugFile;
  class NullDebugFile;
  class DebugFile;
}

namespace j8 {  // forward declare
  class InstancePrinter;
  class LexerDecoder;
  class _Parser;
  class Parser;
  class Nil8Parser;
  class J8LinesParser;
}

namespace j8_lite {  // forward declare
}

namespace ansi {  // forward declare
}

namespace pp_hnode {  // forward declare
  class BaseEncoder;
  class HNodeEncoder;
}

namespace pp_value {  // forward declare
  class ValueEncoder;
}

namespace pretty {  // forward declare
  class PrettyPrinter;
}

namespace ui {  // forward declare
  class ctx_Location;
  class ErrorFormatter;
}

namespace lexer {  // forward declare
  class LineLexer;
  class Lexer;
}

namespace location {  // forward declare
}

namespace parse_lib {  // forward declare
  class _BaseTrail;
  class ctx_Alias;
  class Trail;
  class ParseContext;
}

namespace reader {  // forward declare
  class _Reader;
  class DisallowedLineReader;
  class FileLineReader;
  class VirtualLineReader;
  class InteractiveLineReader;
}

namespace syntax_abbrev {  // forward declare
}

namespace arith_parse {  // forward declare
}

namespace bool_parse {  // forward declare
  class BoolParser;
}

namespace braces {  // forward declare
  class _NotARange;
  class _RangeParser;
  class _StackFrame;
}

namespace cmd_parse {  // forward declare
  class VarChecker;
  class ctx_VarChecker;
  class ctx_CmdMode;
  class CommandParser;
}

namespace glob_ {  // forward declare
  class _GlobParser;
  class Globber;
}

namespace tdop {  // forward declare
  class TdopParser;
}

namespace word_ {  // forward declare
  class ctx_EmitDocToken;
  class ctx_Multiline;
}

namespace word_compile {  // forward declare
}

namespace word_parse {  // forward declare
  class WordEmitter;
  class WordParser;
}

namespace parse {  // forward declare
  class ParseError;
  class _StackItem;
  class Parser;
}

namespace os_path {  // forward declare
}

namespace expr_parse {  // forward declare
  class ExprParser;
  class ctx_PNodeAllocator;
}

namespace expr_to_ast {  // forward declare
  class Transformer;
}

namespace regex_translate {  // forward declare
}

GLOBAL_STR(S_Aoo, "");
GLOBAL_STR(S_mve, "\t");
GLOBAL_STR(S_nfs, "\n");
GLOBAL_STR(S_sEF, "\n  ");
GLOBAL_STR(S_yfk, "\u001b[0;0m");
GLOBAL_STR(S_aaF, "\u001b[1m");
GLOBAL_STR(S_sqm, "\u001b[31m");
GLOBAL_STR(S_eda, "\u001b[32m");
GLOBAL_STR(S_ysf, "\u001b[33m");
GLOBAL_STR(S_osl, "\u001b[34m");
GLOBAL_STR(S_vie, "\u001b[35m");
GLOBAL_STR(S_mmi, "\u001b[36m");
GLOBAL_STR(S_rpo, "\u001b[37m");
GLOBAL_STR(S_sCc, "\u001b[4m");
GLOBAL_STR(S_woy, "\u001b[7m");
GLOBAL_STR(S_yfw, " ");
GLOBAL_STR(S_jEs, " \t");
GLOBAL_STR(S_Dqk, " \n\r\t");
GLOBAL_STR(S_jqf, "  ");
GLOBAL_STR(S_dtA, " --> ");
GLOBAL_STR(S_gAe, " -> ");
GLOBAL_STR(S_krt, "\"");
GLOBAL_STR(S_xbi, "\"BashArray\",");
GLOBAL_STR(S_ojw, "\"BashAssoc\",");
GLOBAL_STR(S_Aav, "\"InternalStringArray\",");
GLOBAL_STR(S_eqo, "\"data\":");
GLOBAL_STR(S_EDa, "\"type\":");
GLOBAL_STR(S_Czx, "$");
GLOBAL_STR(S_hqF, "${");
GLOBAL_STR(S_Ctu, "%end");
GLOBAL_STR(S_DwB, "%start");
GLOBAL_STR(S_Bfw, "'");
GLOBAL_STR(S_ijB, "(");
GLOBAL_STR(S_zxb, "()");
GLOBAL_STR(S_Ehr, "(...)");
GLOBAL_STR(S_hxb, ")");
GLOBAL_STR(S_Fgw, "*");
GLOBAL_STR(S_jnE, "+");
GLOBAL_STR(S_Coy, "+=");
GLOBAL_STR(S_Cce, ",");
GLOBAL_STR(S_Bjq, "-");
GLOBAL_STR(S_zdb, "-1");
GLOBAL_STR(S_DEp, "-c");
GLOBAL_STR(S_ygA, "-n");
GLOBAL_STR(S_Aru, ".");
GLOBAL_STR(S_mgF, ".*");
GLOBAL_STR(S_Dmc, "..");
GLOBAL_STR(S_otl, "...");
GLOBAL_STR(S_jhC, "..<");
GLOBAL_STR(S_Bge, ".|^$()+*?[]{}\\");
GLOBAL_STR(S_ckc, "/");
GLOBAL_STR(S_lFp, "//");
GLOBAL_STR(S_gEs, "///");
GLOBAL_STR(S_wfw, "0");
GLOBAL_STR(S_fyj, ":");
GLOBAL_STR(S_ows, ": ");
GLOBAL_STR(S_nbf, ";");
GLOBAL_STR(S_eox, "<");
GLOBAL_STR(S_bby, "=");
GLOBAL_STR(S_Fos, "=word isn't allowed.  Hint: add a space after =, or quote it");
GLOBAL_STR(S_jye, ">");
GLOBAL_STR(S_olB, "> ");
GLOBAL_STR(S_BAk, "?");
GLOBAL_STR(S_wjA, "ARGV");
GLOBAL_STR(S_ztv, "AST not printed.");
GLOBAL_STR(S_aEF, "BASHPID");
GLOBAL_STR(S_Dyf, "BASH_LINENO");
GLOBAL_STR(S_Erl, "BASH_REMATCH");
GLOBAL_STR(S_lqk, "BASH_SOURCE");
GLOBAL_STR(S_Fkp, "Backtracking with !! isn't implemented (requires Python/PCRE)");
GLOBAL_STR(S_ulC, "Bash (( not allowed in YSH (parse_dparen, see OILS-ERR-14 for wart)");
GLOBAL_STR(S_mEk, "Bash [[ not allowed in YSH (parse_dbracket)");
GLOBAL_STR(S_laa, "Bash for loops aren't allowed (parse_dparen)");
GLOBAL_STR(S_tDu, "BashArray");
GLOBAL_STR(S_Agv, "BashAssoc");
GLOBAL_STR(S_jgc, "BashAssoc cannot be list-initialzied by (KEY VALUE ...) (strict_array)");
GLOBAL_STR(S_DCt, "Binary int constant is too large");
GLOBAL_STR(S_stA, "Block param must have type Command");
GLOBAL_STR(S_sjc, "C");
GLOBAL_STR(S_jrg, "Call");
GLOBAL_STR(S_Crq, "Can't assign to items in a string");
GLOBAL_STR(S_kxq, "Can't assign to readonly array");
GLOBAL_STR(S_zFl, "Can't assign to readonly associative array");
GLOBAL_STR(S_rcx, "Can't assign to this attribute expr");
GLOBAL_STR(S_gzm, "Can't assign to this expression");
GLOBAL_STR(S_kdC, "Can't encode value of type Obj");
GLOBAL_STR(S_kfs, "Can't negate this symbol");
GLOBAL_STR(S_qkr, "Can't run functions or procs while errexit is disabled (OILS-ERR-301)");
GLOBAL_STR(S_egA, "Code point can't be greater than U+10ffff");
GLOBAL_STR(S_jma, "Command");
GLOBAL_STR(S_Awe, "Command evaluated to an empty argv array");
GLOBAL_STR(S_wac, "Comments aren't part of JSON; you may want 'json8 read'");
GLOBAL_STR(S_wcu, "Const");
GLOBAL_STR(S_AAe, "Container place not implemented");
GLOBAL_STR(S_qlz, "Control flow shouldn't have environment bindings");
GLOBAL_STR(S_Biw, "Control flow shouldn't have redirects");
GLOBAL_STR(S_pss, "Couldn't find terminator for here doc that starts here");
GLOBAL_STR(S_lAz, "DQ");
GLOBAL_STR(S_jgg, "Decimal int constant is too large");
GLOBAL_STR(S_iyA, "ENV");
GLOBAL_STR(S_ngj, "EOF");
GLOBAL_STR(S_ith, "ERE");
GLOBAL_STR(S_ACD, "Empty arg list not allowed");
GLOBAL_STR(S_pqq, "Environment binding shouldn't look like an array assignment");
GLOBAL_STR(S_fts, "Environment bindings can't contain array literals");
GLOBAL_STR(S_sai, "Expected 'proc' after 'typed'");
GLOBAL_STR(S_oCF, "Expected ( after =");
GLOBAL_STR(S_kCu, "Expected ( in typed return");
GLOBAL_STR(S_rbz, "Expected ) in function definition");
GLOBAL_STR(S_ine, "Expected ) to close");
GLOBAL_STR(S_paD, "Expected ) to close bash regex group");
GLOBAL_STR(S_nfD, "Expected ) to end for loop expression");
GLOBAL_STR(S_jod, "Expected : or } in slice");
GLOBAL_STR(S_lun, "Expected ; here");
GLOBAL_STR(S_qsa, "Expected ;; or esac");
GLOBAL_STR(S_amq, "Expected = in environment binding, got +=");
GLOBAL_STR(S_sxv, "Expected ] to close subscript");
GLOBAL_STR(S_qul, "Expected ]]");
GLOBAL_STR(S_xDn, "Expected a condition");
GLOBAL_STR(S_Fwi, "Expected a constant argument");
GLOBAL_STR(S_brv, "Expected a word to match against");
GLOBAL_STR(S_yDB, "Expected at most 2 loop variables");
GLOBAL_STR(S_vky, "Expected case pattern");
GLOBAL_STR(S_txD, "Expected end of var ref expression");
GLOBAL_STR(S_nnd, "Expected loop variable (a constant word)");
GLOBAL_STR(S_Fgl, "Expected second ) to end arith statement");
GLOBAL_STR(S_fsD, "Expected second ) to end arith sub");
GLOBAL_STR(S_smu, "Expected var name");
GLOBAL_STR(S_see, "Expected word after ( opening bash regex group");
GLOBAL_STR(S_Fhm, "Expected { after iterable expression");
GLOBAL_STR(S_mpl, "Expected } after length expression");
GLOBAL_STR(S_fpg, "Expected } to close ${");
GLOBAL_STR(S_eez, "Extended glob won't work without FNM_EXTMATCH support in libc");
GLOBAL_STR(S_gFh, "F");
GLOBAL_STR(S_lCr, "FUNCNAME");
GLOBAL_STR(S_dwl, "Flag can't be negated");
GLOBAL_STR(S_hoz, "Got unescaped right bracket");
GLOBAL_STR(S_btq, "Got unescaped trailing backslash");
GLOBAL_STR(S_jwu, "Here docs aren't allowed in expressions");
GLOBAL_STR(S_uDt, "Hex int constant is too large");
GLOBAL_STR(S_BvB, "INFINITY");
GLOBAL_STR(S_Aam, "Index %d is out of bounds for array of length 0");
GLOBAL_STR(S_zDl, "Integer is too big");
GLOBAL_STR(S_Fcv, "InternalStringArray");
GLOBAL_STR(S_rdm, "Invalid KSH-style function name");
GLOBAL_STR(S_scC, "Invalid argument to unary operator");
GLOBAL_STR(S_bio, "Invalid backtick: use $(cmd) or \\` in YSH strings");
GLOBAL_STR(S_gba, "Invalid blank line in multiline mode");
GLOBAL_STR(S_ago, "Invalid block expression argument");
GLOBAL_STR(S_vla, "Invalid char escape in C-style string literal (OILS-ERR-11)");
GLOBAL_STR(S_Bpn, "Invalid char escape in double quoted string (OILS-ERR-12)");
GLOBAL_STR(S_dEh, "Invalid char escape in unquoted word (OILS-ERR-13)");
GLOBAL_STR(S_rbb, "Invalid function name");
GLOBAL_STR(S_xco, "Invalid here doc delimiter");
GLOBAL_STR(S_dDj, "Invalid hex escape in YSH string (must be \\xHH)");
GLOBAL_STR(S_yzg, "Invalid quoted word part in YSH (OILS-ERR-17)");
GLOBAL_STR(S_apz, "Invalid token after redirect operator");
GLOBAL_STR(S_qDr, "Invalid token in bash regex");
GLOBAL_STR(S_iFj, "Invalid trailing comma");
GLOBAL_STR(S_kmo, "Invalid word after for expression");
GLOBAL_STR(S_pnr, "Invalid word in for loop");
GLOBAL_STR(S_fgr, "Invalid word while parsing command");
GLOBAL_STR(S_wpb, "Invalid word while parsing command list");
GLOBAL_STR(S_Czs, "J8");
GLOBAL_STR(S_ApC, "J8 Lines can't have unescaped ASCII control chars");
GLOBAL_STR(S_dqg, "JSON");
GLOBAL_STR(S_Fvt, "LINENO");
GLOBAL_STR(S_kkj, "Left-hand side of this assignment is invalid");
GLOBAL_STR(S_oex, "Literal $ should be quoted like \\$");
GLOBAL_STR(S_oFq, "Literal @ starting a word must be quoted (parse_at_all)");
GLOBAL_STR(S_dwa, "Loop variables look like x, y (fix spaces)");
GLOBAL_STR(S_idh, "Malformed character class; treating as literal");
GLOBAL_STR(S_eio, "Mismatched cases in character range");
GLOBAL_STR(S_ecq, "Module is missing __provide__ List");
GLOBAL_STR(S_Dtp, "Multiple assignment must use =");
GLOBAL_STR(S_ywk, "NAN");
GLOBAL_STR(S_rDF, "Octal int constant is too large");
GLOBAL_STR(S_sxs, "Only 1 block param is allowed");
GLOBAL_STR(S_ntu, "Only strings can be exported (strict_array)");
GLOBAL_STR(S_evu, "PIPESTATUS");
GLOBAL_STR(S_gik, "POSIX EREs don't have groups without capture, so this node needs () around it.");
GLOBAL_STR(S_xil, "POSIX classes can't be negated in ERE");
GLOBAL_STR(S_tFx, "POSIX shell arithmetic isn't allowed (parse_sh_arith)");
GLOBAL_STR(S_zyo, "PS4");
GLOBAL_STR(S_rqm, "Perl classes can't be negated in ERE");
GLOBAL_STR(S_aBC, "Perl-style repetition isn't implemented with libc");
GLOBAL_STR(S_ynk, "Places in containers not implemented yet");
GLOBAL_STR(S_gur, "PopEnvObj: env.prototype is null");
GLOBAL_STR(S_Fpz, "Positional arg can't appear in group of named args");
GLOBAL_STR(S_Ahj, "Pure JSON does not accept j\"\" prefix");
GLOBAL_STR(S_lBE, "Quoted range char can't be empty");
GLOBAL_STR(S_Fza, "Range start/end shouldn't have more than one character");
GLOBAL_STR(S_ioh, "Ref");
GLOBAL_STR(S_cEx, "Reserved syntax");
GLOBAL_STR(S_Cab, "Rest param isn't allowed for blocks");
GLOBAL_STR(S_xFB, "SECONDS");
GLOBAL_STR(S_cvm, "SHELLOPTS");
GLOBAL_STR(S_mip, "SQ");
GLOBAL_STR(S_hur, "Shell-style returns not allowed here");
GLOBAL_STR(S_hBp, "Single quotes aren't part of JSON; you may want 'json8 read'");
GLOBAL_STR(S_npc, "Slice length: Add explicit zero, or omit : for N (strict_parse_slice)");
GLOBAL_STR(S_nli, "Source");
GLOBAL_STR(S_ezD, "Space required before (");
GLOBAL_STR(S_bgA, "Splat not currently supported");
GLOBAL_STR(S_Cwz, "Step can't be 0");
GLOBAL_STR(S_DsF, "Str");
GLOBAL_STR(S_mrm, "Strings with backslashes should look like r'\\n' or u'\\n' or b'\\n'");
GLOBAL_STR(S_juC, "Subscript/Attribute not allowed on this LHS expression");
GLOBAL_STR(S_BpF, "Surround this word with either parens or quotes (parse_bare_word)");
GLOBAL_STR(S_cor, "T");
GLOBAL_STR(S_hzv, "TODO: ${.myproc builtin sub}");
GLOBAL_STR(S_rsr, "TODO: @{.myproc builtin sub}");
GLOBAL_STR(S_fAu, "The [ operator doesn't apply to this expression");
GLOBAL_STR(S_tjF, "This is a constant string.  You may want a variable like $x (parse_bare_word)");
GLOBAL_STR(S_dlq, "This kind of class literal term isn't implemented");
GLOBAL_STR(S_vvB, "Token can't be used in infix position");
GLOBAL_STR(S_Dmb, "Token can't be used in prefix position");
GLOBAL_STR(S_vuh, "Typed return doesn't take named arguments");
GLOBAL_STR(S_jkf, "Typed return expects one argument");
GLOBAL_STR(S_Bpo, "Typed return is only allowed inside func");
GLOBAL_STR(S_hlc, "Unexpected = (Hint: use var/setvar, or quote it)");
GLOBAL_STR(S_acC, "Unexpected EOF in single-quoted string that began here");
GLOBAL_STR(S_fip, "Unexpected EOF reading double-quoted string that began here");
GLOBAL_STR(S_ilx, "Unexpected EOF reading extended glob that began here");
GLOBAL_STR(S_edt, "Unexpected EOF while looking for closing backtick");
GLOBAL_STR(S_agx, "Unexpected EOF while parsing command");
GLOBAL_STR(S_dtB, "Unexpected end of input");
GLOBAL_STR(S_bjp, "Unexpected left paren (might need a space before it)");
GLOBAL_STR(S_imw, "Unexpected parts after triple quoted string");
GLOBAL_STR(S_avi, "Unexpected right brace");
GLOBAL_STR(S_rip, "Unexpected token after @()");
GLOBAL_STR(S_AAk, "Unexpected token after Expr splice");
GLOBAL_STR(S_wxA, "Unexpected token after YSH single-quoted string");
GLOBAL_STR(S_bbn, "Unexpected token after array literal");
GLOBAL_STR(S_evz, "Unexpected token after array splice");
GLOBAL_STR(S_tBm, "Unexpected token in ${}");
GLOBAL_STR(S_Ayd, "Unexpected token in array literal");
GLOBAL_STR(S_oDA, "Unexpected trailing input");
GLOBAL_STR(S_mfF, "Unexpected trailing input in J8 Lines");
GLOBAL_STR(S_noa, "Unexpected type parameters");
GLOBAL_STR(S_meF, "Unexpected typed args");
GLOBAL_STR(S_zfb, "Unexpected word after 3 loop variables");
GLOBAL_STR(S_cAo, "Unexpected word after for loop variable");
GLOBAL_STR(S_lrE, "Unexpected word when parsing command");
GLOBAL_STR(S_rBg, "Units suffix not implemented");
GLOBAL_STR(S_tce, "Unterminated here doc began here");
GLOBAL_STR(S_Aeo, "Use $(cmd) instead of backticks (parse_backticks)");
GLOBAL_STR(S_hkt, "Use 'and' in expression mode (OILS-ERR-15)");
GLOBAL_STR(S_yww, "Use 'or' in expression mode (OILS-ERR-15)");
GLOBAL_STR(S_bkb, "Use ..< for half-open range, or ..= for closed range (OILS-ERR-16)");
GLOBAL_STR(S_qbb, "Use === to be exact, or ~== to convert types");
GLOBAL_STR(S_jmF, "Use \\xhh or \\u{...} instead of octal escapes in YSH strings");
GLOBAL_STR(S_xih, "Use var/setvar to assign in YSH");
GLOBAL_STR(S_Duk, "VOp2");
GLOBAL_STR(S_hgF, "VOp3");
GLOBAL_STR(S_CsA, "Var");
GLOBAL_STR(S_tvz, "Word has unbalanced { }.  Maybe add a space or quote it like \\{");
GLOBAL_STR(S_Bej, "Word params may only have type Str or Ref");
GLOBAL_STR(S_Eax, "[");
GLOBAL_STR(S_wxv, "[ -c flag ]");
GLOBAL_STR(S_jgf, "[ headless ]");
GLOBAL_STR(S_odD, "[ interactive ]");
GLOBAL_STR(S_Aek, "[...]");
GLOBAL_STR(S_eEf, "[:alpha:][:digit:]_");
GLOBAL_STR(S_Bro, "[:digit:]");
GLOBAL_STR(S_khq, "[:space:]");
GLOBAL_STR(S_xmu, "[]");
GLOBAL_STR(S_iyu, "\\");
GLOBAL_STR(S_hpd, "\\*?[]-:!()|");
GLOBAL_STR(S_iCa, "\\-");
GLOBAL_STR(S_ivk, "\\?*+{}^$.()|[]");
GLOBAL_STR(S_uDk, "\\[");
GLOBAL_STR(S_Eef, "\\\\");
GLOBAL_STR(S_dkw, "\\]");
GLOBAL_STR(S_pcD, "]");
GLOBAL_STR(S_ldx, "]+=");
GLOBAL_STR(S_nuz, "]=");
GLOBAL_STR(S_EAB, "^");
GLOBAL_STR(S_neq, "^\n");
GLOBAL_STR(S_gch, "^D");
GLOBAL_STR(S_tci, "_");
GLOBAL_STR(S_Cet, "__");
GLOBAL_STR(S_hub, "__E__");
GLOBAL_STR(S_aEE, "___ GC: after parsing");
GLOBAL_STR(S_gfw, "___ GC: after printing");
GLOBAL_STR(S_mmF, "__builtins__");
GLOBAL_STR(S_myz, "__dumpdoc");
GLOBAL_STR(S_fBo, "__invoke__");
GLOBAL_STR(S_zcz, "__provide__");
GLOBAL_STR(S_zzh, "_error");
GLOBAL_STR(S_yzD, "_pipeline_status");
GLOBAL_STR(S_mcg, "_process_sub_status");
GLOBAL_STR(S_EeE, "_status");
GLOBAL_STR(S_ddq, "_this_dir");
GLOBAL_STR(S_Btg, "abbrev-");
GLOBAL_STR(S_gja, "alnum");
GLOBAL_STR(S_EvD, "alpha");
GLOBAL_STR(S_esE, "argv");
GLOBAL_STR(S_mqm, "array LHS");
GLOBAL_STR(S_jFv, "b");
GLOBAL_STR(S_vlc, "backticks");
GLOBAL_STR(S_trA, "bad input");
GLOBAL_STR(S_bdb, "blank");
GLOBAL_STR(S_tzb, "call_line");
GLOBAL_STR(S_eqz, "call_line_num");
GLOBAL_STR(S_ogo, "call_source");
GLOBAL_STR(S_mij, "cntrl");
GLOBAL_STR(S_gFE, "code");
GLOBAL_STR(S_pxA, "const can't be inside proc or func.  Use var instead.");
GLOBAL_STR(S_Crn, "d");
GLOBAL_STR(S_Coo, "digit");
GLOBAL_STR(S_urc, "dot");
GLOBAL_STR(S_uFo, "errexit was disabled for this construct");
GLOBAL_STR(S_xho, "failglob: ");
GLOBAL_STR(S_Ctn, "false");
GLOBAL_STR(S_boy, "flags");
GLOBAL_STR(S_hei, "for -Wreturn-type in C++");
GLOBAL_STR(S_ggl, "func is a YSH keyword, but this is OSH.");
GLOBAL_STR(S_rwo, "func_name");
GLOBAL_STR(S_pih, "funcs can't be defined inside shell functions");
GLOBAL_STR(S_jji, "graph");
GLOBAL_STR(S_eil, "i");
GLOBAL_STR(S_urB, "lower");
GLOBAL_STR(S_sDc, "main");
GLOBAL_STR(S_pBg, "message");
GLOBAL_STR(S_rob, "n");
GLOBAL_STR(S_sAx, "nameref must be a string");
GLOBAL_STR(S_rdE, "none");
GLOBAL_STR(S_lbA, "null");
GLOBAL_STR(S_owh, "num_shifted");
GLOBAL_STR(S_lAu, "osh warning: GLOB_PERIOD wasn't found in libc, so 'shopt -s dotglob' won't work");
GLOBAL_STR(S_nAz, "osh warning: set -o verbose not implemented");
GLOBAL_STR(S_nld, "print");
GLOBAL_STR(S_aFi, "proc");
GLOBAL_STR(S_dsk, "proc is a YSH keyword, but this is OSH.");
GLOBAL_STR(S_fot, "procs can't be defined inside shell functions");
GLOBAL_STR(S_syu, "punct");
GLOBAL_STR(S_nAr, "r");
GLOBAL_STR(S_fdv, "reg_icase");
GLOBAL_STR(S_ABj, "reg_newline");
GLOBAL_STR(S_anC, "s");
GLOBAL_STR(S_jlb, "shell functions can't be defined inside proc or func");
GLOBAL_STR(S_ulj, "shell-flags");
GLOBAL_STR(S_cmd, "source");
GLOBAL_STR(S_gxr, "source_name");
GLOBAL_STR(S_iya, "space");
GLOBAL_STR(S_omF, "t");
GLOBAL_STR(S_vwh, "too much input");
GLOBAL_STR(S_FsF, "true");
GLOBAL_STR(S_qEi, "type");
GLOBAL_STR(S_hzm, "typed is a YSH keyword, but this is OSH.");
GLOBAL_STR(S_rsz, "u");
GLOBAL_STR(S_zxo, "unix suffix implemented");
GLOBAL_STR(S_fgo, "upper");
GLOBAL_STR(S_zrD, "val");
GLOBAL_STR(S_pfC, "w");
GLOBAL_STR(S_Cbp, "word");
GLOBAL_STR(S_rqD, "x");
GLOBAL_STR(S_dgp, "xdigit");
GLOBAL_STR(S_ato, "{");
GLOBAL_STR(S_qnA, "{...}");
GLOBAL_STR(S_Fni, "{}");
GLOBAL_STR(S_Ebn, "|");
GLOBAL_STR(S_cEn, "}");
GLOBAL_STR(S_Bhp, "~");

namespace runtime {  // declare

extern int NO_SPID;
hnode::Record* NewRecord(BigStr* node_type);
hnode::Leaf* NewLeaf(BigStr* s, hnode_asdl::color_t e_color);
class TraversalState {
 public:
  TraversalState();
  Dict<int, bool>* seen{};
  Dict<int, int>* ref_count{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(TraversalState));
  }

  DISALLOW_COPY_AND_ASSIGN(TraversalState)
};

extern BigStr* TRUE_STR;
extern BigStr* FALSE_STR;

}  // declare namespace runtime

namespace vm {  // declare

class ControlFlow {
 public:

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(ControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(ControlFlow)
};

class IntControlFlow {
 public:
  IntControlFlow(int keyword_id, BigStr* keyword_str, syntax_asdl::loc_t* keyword_loc, int arg);
  BigStr* Keyword();
  syntax_asdl::loc_t* Location();
  bool IsReturn();
  bool IsBreak();
  bool IsContinue();
  int StatusCode();
  runtime_asdl::flow_t HandleLoop();
  BigStr* keyword_str{};
  syntax_asdl::loc_t* keyword_loc{};
  int keyword_id{};
  int arg{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(IntControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(IntControlFlow)
};

class ValueControlFlow {
 public:
  ValueControlFlow(syntax_asdl::Token* token, value_asdl::value_t* value);
  syntax_asdl::Token* token{};
  value_asdl::value_t* value{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(ValueControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(ValueControlFlow)
};

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith);
void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::ExprEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, vm::_Executor* pure_ex, prompt::Evaluator* prompt_ev, value_asdl::Obj* global_io, dev::Tracer* tracer);
class _Executor {
 public:
  _Executor(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, state::Procs* procs, hay_ysh::HayState* hay_state, Dict<int, vm::_Builtin*>* builtins, dev::Tracer* tracer, ui::ErrorFormatter* errfmt);
  void CheckCircularDeps();
  int RunSimpleCommand(cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, int run_flags);
  int _RunSimpleCommand(BigStr* arg0, syntax_asdl::loc_t* arg0_loc, cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, int run_flags);
  int RunBuiltin(int builtin_id, cmd_value::Argv* cmd_val);
  int _RunBuiltinProc(vm::_Builtin* builtin_proc, cmd_value::Argv* cmd_val);
  int _RunInvokable(value_asdl::value_t* proc_val, value_asdl::Obj* self_obj, syntax_asdl::loc_t* arg0_loc, cmd_value::Argv* cmd_val);
  int RunBackgroundJob(syntax_asdl::command_t* node);
  void RunPipeline(command::Pipeline* node, runtime_asdl::CommandStatus* status_out);
  int RunSubshell(syntax_asdl::command_t* node);
  Tuple2<int, BigStr*> CaptureStdout(syntax_asdl::command_t* node);
  Tuple3<int, BigStr*, BigStr*> Capture3(syntax_asdl::command_t* node);
  BigStr* RunCommandSub(syntax_asdl::CommandSub* cs_part);
  BigStr* RunProcessSub(syntax_asdl::CommandSub* cs_part);
  void PushRedirects(List<runtime_asdl::RedirValue*>* redirects, List<IOError_OSError*>* err_out);
  void PopRedirects(int num_redirects, List<IOError_OSError*>* err_out);
  void PushProcessSub();
  void PopProcessSub(runtime_asdl::StatusArray* compound_st);
  state::Mem* mem{};
  optview::Exec* exec_opts{};
  state::MutableOpts* mutable_opts{};
  state::Procs* procs{};
  hay_ysh::HayState* hay_state{};
  Dict<int, vm::_Builtin*>* builtins{};
  dev::Tracer* tracer{};
  ui::ErrorFormatter* errfmt{};
  cmd_eval::CommandEvaluator* cmd_ev{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(9, sizeof(_Executor));
  }

  DISALLOW_COPY_AND_ASSIGN(_Executor)
};

class _AssignBuiltin {
 public:
  _AssignBuiltin();
  int Run(cmd_value::Assign* cmd_val);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_AssignBuiltin));
  }

  DISALLOW_COPY_AND_ASSIGN(_AssignBuiltin)
};

class _Builtin {
 public:
  _Builtin();
  int Run(cmd_value::Argv* cmd_val);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_Builtin));
  }

  DISALLOW_COPY_AND_ASSIGN(_Builtin)
};

class _Callable {
 public:
  _Callable();
  value_asdl::value_t* Call(typed_args::Reader* args);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_Callable));
  }

  DISALLOW_COPY_AND_ASSIGN(_Callable)
};

class ctx_MaybePure {
 public:
  ctx_MaybePure(vm::_Executor* pure_ex, cmd_eval::CommandEvaluator* cmd_ev);
  ~ctx_MaybePure();
  void ctx_EXIT();
  vm::_Executor* pure_ex{};
  vm::_Executor* saved{};
  cmd_eval::CommandEvaluator* cmd_ev{};

  DISALLOW_COPY_AND_ASSIGN(ctx_MaybePure)
};

class ctx_Redirect {
 public:
  ctx_Redirect(vm::_Executor* shell_ex, int num_redirects, List<IOError_OSError*>* err_out);
  ~ctx_Redirect();
  vm::_Executor* shell_ex{};
  List<IOError_OSError*>* err_out{};
  int num_redirects{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Redirect)
};

class ctx_ProcessSub {
 public:
  ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status);
  ~ctx_ProcessSub();
  vm::_Executor* shell_ex{};
  runtime_asdl::StatusArray* process_sub_status{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ProcessSub)
};

class ctx_FlushStdout {
 public:
  ctx_FlushStdout(List<IOError_OSError*>* err_out);
  ~ctx_FlushStdout();
  List<IOError_OSError*>* err_out{};

  DISALLOW_COPY_AND_ASSIGN(ctx_FlushStdout)
};


}  // declare namespace vm

namespace format {  // declare

int _HNodeCount(hnode_asdl::hnode_t* h);
int _DocCount(pretty_asdl::doc_t* d);
void _HNodePrettyPrint(bool perf_stats, bool doc_debug, hnode_asdl::hnode_t* node, mylib::Writer* f, int max_width = 80);
void HNodePrettyPrint(hnode_asdl::hnode_t* node, mylib::Writer* f, int max_width = 80);

}  // declare namespace format

namespace osh_parse {  // declare

syntax_asdl::command_t* ParseWholeFile(cmd_parse::CommandParser* c_parser);
int main(List<BigStr*>* argv);

}  // declare namespace osh_parse

namespace alloc {  // declare

BigStr* SnipCodeBlock(syntax_asdl::Token* left, syntax_asdl::Token* right, List<syntax_asdl::SourceLine*>* lines);
class ctx_SourceCode {
 public:
  ctx_SourceCode(alloc::Arena* arena, syntax_asdl::source_t* src);
  ~ctx_SourceCode();
  alloc::Arena* arena{};

  DISALLOW_COPY_AND_ASSIGN(ctx_SourceCode)
};

class Arena {
 public:
  Arena(bool save_tokens = false);
  void SaveTokens();
  void PushSource(syntax_asdl::source_t* src);
  void PopSource();
  syntax_asdl::SourceLine* AddLine(BigStr* line, int line_num);
  void DiscardLines();
  List<syntax_asdl::SourceLine*>* SaveLinesAndDiscard(syntax_asdl::Token* left, syntax_asdl::Token* right);
  BigStr* SnipCodeString(syntax_asdl::Token* left, syntax_asdl::Token* right);
  syntax_asdl::Token* NewToken(int id_, int col, int length, syntax_asdl::SourceLine* src_line);
  void UnreadOne();
  syntax_asdl::Token* GetToken(int span_id);
  int GetSpanId(syntax_asdl::Token* tok);
  int LastSpanId();
  List<syntax_asdl::SourceLine*>* lines_list{};
  int num_tokens{};
  bool save_tokens{};
  List<syntax_asdl::source_t*>* source_instances{};
  Dict<syntax_asdl::Token*, int>* span_id_lookup{};
  List<syntax_asdl::Token*>* tokens{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(Arena, lines_list))
         | maskbit(offsetof(Arena, source_instances))
         | maskbit(offsetof(Arena, span_id_lookup))
         | maskbit(offsetof(Arena, tokens));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Arena));
  }

  DISALLOW_COPY_AND_ASSIGN(Arena)
};

class LosslessArena : public ::alloc::Arena {
 public:
  
  static constexpr uint32_t field_mask() {
    return ::alloc::Arena::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(LosslessArena));
  }

  DISALLOW_COPY_AND_ASSIGN(LosslessArena)
};

class DynamicArena : public ::alloc::Arena {
 public:
  
  static constexpr uint32_t field_mask() {
    return ::alloc::Arena::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(DynamicArena));
  }

  DISALLOW_COPY_AND_ASSIGN(DynamicArena)
};


}  // declare namespace alloc

namespace bash_impl {  // declare

bool BigInt_Greater(mops::BigInt a, mops::BigInt b);
bool BigInt_Less(mops::BigInt a, mops::BigInt b);
bool BigInt_GreaterEq(mops::BigInt a, mops::BigInt b);
bool BigInt_LessEq(mops::BigInt a, mops::BigInt b);
class ArrayIndexEvaluator {
 public:
  ArrayIndexEvaluator();
  mops::BigInt StringToBigInt(BigStr* s, syntax_asdl::loc_t* blame_loc);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(ArrayIndexEvaluator));
  }

  DISALLOW_COPY_AND_ASSIGN(ArrayIndexEvaluator)
};

bool InternalStringArray_IsEmpty(value::InternalStringArray* array_val);
int InternalStringArray_Count(value::InternalStringArray* array_val);
int InternalStringArray_Length(value::InternalStringArray* array_val);
List<int>* InternalStringArray_GetKeys(value::InternalStringArray* array_val);
List<BigStr*>* InternalStringArray_GetValues(value::InternalStringArray* array_val);
void InternalStringArray_AppendValues(value::InternalStringArray* array_val, List<BigStr*>* strs);
Tuple3<int, int, runtime_asdl::error_code_t> _InternalStringArray_CanonicalizeIndex(value::InternalStringArray* array_val, int index);
Tuple2<bool, runtime_asdl::error_code_t> InternalStringArray_HasElement(value::InternalStringArray* array_val, int index);
Tuple2<BigStr*, runtime_asdl::error_code_t> InternalStringArray_GetElement(value::InternalStringArray* array_val, int index);
runtime_asdl::error_code_t InternalStringArray_SetElement(value::InternalStringArray* array_val, int index, BigStr* s);
runtime_asdl::error_code_t InternalStringArray_UnsetElement(value::InternalStringArray* array_val, int index);
bool InternalStringArray_Equals(value::InternalStringArray* lhs, value::InternalStringArray* rhs);
bool _InternalStringArray_HasHoles(value::InternalStringArray* array_val);
BigStr* InternalStringArray_ToStrForShellPrint(value::InternalStringArray* array_val, BigStr* name);
value::BashAssoc* BashAssoc_New();
value::BashAssoc* BashAssoc_Copy(value::BashAssoc* val);
void BashAssoc_ListInitialize(value::BashAssoc* val, value::InitializerList* initializer, bool has_plus, optview::Exec* exec_opts, syntax_asdl::loc_t* blame_loc);
bool BashAssoc_IsEmpty(value::BashAssoc* assoc_val);
int BashAssoc_Count(value::BashAssoc* assoc_val);
Dict<BigStr*, BigStr*>* BashAssoc_GetDict(value::BashAssoc* assoc_val);
void BashAssoc_AppendDict(value::BashAssoc* assoc_val, Dict<BigStr*, BigStr*>* d);
List<BigStr*>* BashAssoc_GetKeys(value::BashAssoc* assoc_val);
List<BigStr*>* BashAssoc_GetValues(value::BashAssoc* assoc_val);
bool BashAssoc_HasElement(value::BashAssoc* assoc_val, BigStr* s);
BigStr* BashAssoc_GetElement(value::BashAssoc* assoc_val, BigStr* s);
void BashAssoc_SetElement(value::BashAssoc* assoc_val, BigStr* key, BigStr* s);
void BashAssoc_UnsetElement(value::BashAssoc* assoc_val, BigStr* key);
bool BashAssoc_Equals(value::BashAssoc* lhs, value::BashAssoc* rhs);
BigStr* BashAssoc_ToStrForShellPrint(value::BashAssoc* assoc_val);
value::BashArray* BashArray_New();
value::BashArray* BashArray_Copy(value::BashArray* val);
value::BashArray* BashArray_FromList(List<BigStr*>* strs);
void BashArray_ListInitialize(value::BashArray* val, value::InitializerList* initializer, bool has_plus, syntax_asdl::loc_t* blame_loc, bash_impl::ArrayIndexEvaluator* arith_ev);
bool BashArray_IsEmpty(value::BashArray* sparse_val);
int BashArray_Count(value::BashArray* sparse_val);
mops::BigInt BashArray_Length(value::BashArray* sparse_val);
List<mops::BigInt>* BashArray_GetKeys(value::BashArray* sparse_val);
List<BigStr*>* BashArray_GetValues(value::BashArray* sparse_val);
void BashArray_AppendValues(value::BashArray* sparse_val, List<BigStr*>* strs);
Tuple2<mops::BigInt, runtime_asdl::error_code_t> _BashArray_CanonicalizeIndex(value::BashArray* sparse_val, mops::BigInt index);
Tuple2<bool, runtime_asdl::error_code_t> BashArray_HasElement(value::BashArray* sparse_val, mops::BigInt index);
Tuple2<BigStr*, runtime_asdl::error_code_t> BashArray_GetElement(value::BashArray* sparse_val, mops::BigInt index);
runtime_asdl::error_code_t BashArray_SetElement(value::BashArray* sparse_val, mops::BigInt index, BigStr* s);
runtime_asdl::error_code_t BashArray_UnsetElement(value::BashArray* sparse_val, mops::BigInt index);
bool BashArray_Equals(value::BashArray* lhs, value::BashArray* rhs);
BigStr* BashArray_ToStrForShellPrint(value::BashArray* sparse_val);
BigStr* InitializerList_ToStrForShellPrint(value::InitializerList* val);

}  // declare namespace bash_impl

namespace error {  // declare

BigStr* _ValType(value_asdl::value_t* val);
class _ErrorWithLocation {
 public:
  _ErrorWithLocation(BigStr* msg, syntax_asdl::loc_t* location);
  bool HasLocation();
  BigStr* UserErrorString();
  syntax_asdl::loc_t* location{};
  BigStr* msg{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(_ErrorWithLocation, location))
         | maskbit(offsetof(_ErrorWithLocation, msg));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_ErrorWithLocation));
  }

  DISALLOW_COPY_AND_ASSIGN(_ErrorWithLocation)
};

class Usage : public ::error::_ErrorWithLocation {
 public:
  Usage(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::_ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Usage));
  }

  DISALLOW_COPY_AND_ASSIGN(Usage)
};

class Parse : public ::error::_ErrorWithLocation {
 public:
  Parse(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::_ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Parse));
  }

  DISALLOW_COPY_AND_ASSIGN(Parse)
};

class WordFailure : public ::error::_ErrorWithLocation {
 public:
  WordFailure(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::_ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(WordFailure));
  }

  DISALLOW_COPY_AND_ASSIGN(WordFailure)
};

class FailGlob : public ::error::WordFailure {
 public:
  FailGlob(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::WordFailure::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(FailGlob));
  }

  DISALLOW_COPY_AND_ASSIGN(FailGlob)
};

class VarSubFailure : public ::error::WordFailure {
 public:
  VarSubFailure(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::WordFailure::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(VarSubFailure));
  }

  DISALLOW_COPY_AND_ASSIGN(VarSubFailure)
};

class RedirectEval : public ::error::_ErrorWithLocation {
 public:
  RedirectEval(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::_ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(RedirectEval));
  }

  DISALLOW_COPY_AND_ASSIGN(RedirectEval)
};

class FatalRuntime : public ::error::_ErrorWithLocation {
 public:
  FatalRuntime(int exit_status, BigStr* msg, syntax_asdl::loc_t* location);
  int ExitStatus();

  int exit_status{};
  
  static constexpr uint32_t field_mask() {
    return ::error::_ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(FatalRuntime));
  }

  DISALLOW_COPY_AND_ASSIGN(FatalRuntime)
};

class Strict : public ::error::FatalRuntime {
 public:
  Strict(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Strict));
  }

  DISALLOW_COPY_AND_ASSIGN(Strict)
};

class ErrExit : public ::error::FatalRuntime {
 public:
  ErrExit(int exit_status, BigStr* msg, syntax_asdl::loc_t* location, bool show_code = false);

  bool show_code{};
  
  static constexpr uint32_t field_mask() {
    return ::error::FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(ErrExit));
  }

  DISALLOW_COPY_AND_ASSIGN(ErrExit)
};

class Expr : public ::error::FatalRuntime {
 public:
  Expr(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Expr));
  }

  DISALLOW_COPY_AND_ASSIGN(Expr)
};

class Structured : public ::error::FatalRuntime {
 public:
  Structured(int status, BigStr* msg, syntax_asdl::loc_t* location, Dict<BigStr*, value_asdl::value_t*>* properties = nullptr);
  value::Dict* ToDict();

  Dict<BigStr*, value_asdl::value_t*>* properties{};
  
  static constexpr uint32_t field_mask() {
    return ::error::FatalRuntime::field_mask()
         | maskbit(offsetof(Structured, properties));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Structured));
  }

  DISALLOW_COPY_AND_ASSIGN(Structured)
};

class AssertionErr : public ::error::Expr {
 public:
  AssertionErr(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::Expr::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(AssertionErr));
  }

  DISALLOW_COPY_AND_ASSIGN(AssertionErr)
};

class TypeErrVerbose : public ::error::Expr {
 public:
  TypeErrVerbose(BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::Expr::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(TypeErrVerbose));
  }

  DISALLOW_COPY_AND_ASSIGN(TypeErrVerbose)
};

class TypeErr : public ::error::TypeErrVerbose {
 public:
  TypeErr(value_asdl::value_t* actual_val, BigStr* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return ::error::TypeErrVerbose::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(TypeErr));
  }

  DISALLOW_COPY_AND_ASSIGN(TypeErr)
};

class Runtime {
 public:
  Runtime(BigStr* msg);
  BigStr* UserErrorString();
  BigStr* msg{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(Runtime));
  }

  DISALLOW_COPY_AND_ASSIGN(Runtime)
};

class Decode {
 public:
  Decode(BigStr* msg, BigStr* s, int start_pos, int end_pos, int line_num);
  BigStr* Message();
  BigStr* __str__();
  BigStr* msg{};
  BigStr* s{};
  int start_pos{};
  int end_pos{};
  int line_num{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(Decode));
  }

  DISALLOW_COPY_AND_ASSIGN(Decode)
};

class Encode {
 public:
  Encode(BigStr* msg);
  BigStr* Message();
  BigStr* msg{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(Encode));
  }

  DISALLOW_COPY_AND_ASSIGN(Encode)
};

[[noreturn]] void e_usage(BigStr* msg, syntax_asdl::loc_t* location);
[[noreturn]] void e_strict(BigStr* msg, syntax_asdl::loc_t* location);
[[noreturn]] void p_die(BigStr* msg, syntax_asdl::loc_t* location);
[[noreturn]] void e_die(BigStr* msg, syntax_asdl::loc_t* location = nullptr);
[[noreturn]] void e_die_status(int status, BigStr* msg, syntax_asdl::loc_t* location = nullptr);

}  // declare namespace error

namespace num {  // declare

value::Int* ToBig(int i);
mops::BigInt Exponent(mops::BigInt x, mops::BigInt y);

}  // declare namespace num

namespace state {  // declare

extern int SetReadOnly;
extern int ClearReadOnly;
extern int SetExport;
extern int ClearExport;
extern int SetNameref;
extern int ClearNameref;
extern int YshDecl;
class ctx_Source {
 public:
  ctx_Source(state::Mem* mem, BigStr* source_name, List<BigStr*>* argv, syntax_asdl::CompoundWord* source_loc);
  ~ctx_Source();
  state::Mem* mem{};
  List<BigStr*>* argv{};
  bool to_restore{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Source)
};

class ctx_DebugTrap {
 public:
  ctx_DebugTrap(state::Mem* mem);
  ~ctx_DebugTrap();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_DebugTrap)
};

class ctx_ErrTrap {
 public:
  ctx_ErrTrap(state::Mem* mem);
  ~ctx_ErrTrap();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ErrTrap)
};

class ctx_Option {
 public:
  ctx_Option(state::MutableOpts* mutable_opts, List<int>* opt_nums, bool b);
  ~ctx_Option();
  state::MutableOpts* mutable_opts{};
  List<int>* opt_nums{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Option)
};

class ctx_AssignBuiltin {
 public:
  ctx_AssignBuiltin(state::MutableOpts* mutable_opts);
  ~ctx_AssignBuiltin();
  state::MutableOpts* mutable_opts{};
  bool strict{};

  DISALLOW_COPY_AND_ASSIGN(ctx_AssignBuiltin)
};

class ctx_YshExpr {
 public:
  ctx_YshExpr(state::MutableOpts* mutable_opts);
  ~ctx_YshExpr();
  state::MutableOpts* mutable_opts{};

  DISALLOW_COPY_AND_ASSIGN(ctx_YshExpr)
};

class ctx_ErrExit {
 public:
  ctx_ErrExit(state::MutableOpts* mutable_opts, bool b, syntax_asdl::Token* disabled_tok);
  ~ctx_ErrExit();
  state::MutableOpts* mutable_opts{};
  bool strict{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ErrExit)
};

class OptHook {
 public:
  OptHook();
  bool OnChange(List<bool>* opt0_array, BigStr* opt_name, bool b);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(OptHook));
  }

  DISALLOW_COPY_AND_ASSIGN(OptHook)
};

List<bool>* InitOpts();
Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*> MakeOpts(state::Mem* mem, Dict<BigStr*, BigStr*>* environ, state::OptHook* opt_hook);
void _SetGroup(List<bool>* opt0_array, List<int>* opt_nums, bool b);
optview::Parse* MakeYshParseOpts();
int _AnyOptionNum(BigStr* opt_name, bool ignore_shopt_not_impl);
int _SetOptionNum(BigStr* opt_name);
void _MaybeWarnDotglob();
class MutableOpts {
 public:
  MutableOpts(state::Mem* mem, Dict<BigStr*, BigStr*>* environ, List<bool>* opt0_array, List<List<bool>*>* opt_stacks, state::OptHook* opt_hook);
  void InitFromEnv(BigStr* shellopts);
  BigStr* ShelloptsString();
  void Push(int opt_num, bool b);
  bool Pop(int opt_num);
  void PushDynamicScope(bool b);
  void PopDynamicScope();
  bool Get(int opt_num);
  void _Set(int opt_num, bool b);
  void set_interactive();
  void set_redefine_const();
  void set_redefine_source();
  void set_emacs();
  void _SetArrayByNum(int opt_num, bool b);
  void SetDeferredErrExit(bool b);
  void DisableErrExit();
  syntax_asdl::Token* ErrExitDisabledToken();
  bool ErrExitIsDisabled();
  void _SetOldOption(BigStr* opt_name, bool b);
  void SetOldOption(BigStr* opt_name, bool b);
  void SetAnyOption(BigStr* opt_name, bool b, bool ignore_shopt_not_impl = false);
  state::Mem* mem{};
  Dict<BigStr*, BigStr*>* environ{};
  List<bool>* opt0_array{};
  List<List<bool>*>* opt_stacks{};
  List<syntax_asdl::Token*>* errexit_disabled_tok{};
  state::OptHook* opt_hook{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(6, sizeof(MutableOpts));
  }

  DISALLOW_COPY_AND_ASSIGN(MutableOpts)
};

class _ArgFrame {
 public:
  _ArgFrame(List<BigStr*>* argv);
  Dict<BigStr*, value_asdl::value_t*>* Dump();
  value_asdl::value_t* GetArgNum(int arg_num);
  List<BigStr*>* GetArgv();
  int GetNumArgs();
  void SetArgv(List<BigStr*>* argv);
  List<BigStr*>* argv{};
  int num_shifted{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(_ArgFrame));
  }

  DISALLOW_COPY_AND_ASSIGN(_ArgFrame)
};

Dict<BigStr*, value_asdl::value_t*>* _DumpVarFrame(Dict<BigStr*, runtime_asdl::Cell*>* frame);
BigStr* _LineNumber(syntax_asdl::Token* tok);
void _AddCallToken(Dict<BigStr*, value_asdl::value_t*>* d, syntax_asdl::Token* token);
class ctx_FuncCall {
 public:
  ctx_FuncCall(state::Mem* mem, value::Func* func, syntax_asdl::Token* blame_tok);
  ~ctx_FuncCall();
  Dict<BigStr*, runtime_asdl::Cell*>* saved_globals{};
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_FuncCall)
};

class ctx_ProcCall {
 public:
  ctx_ProcCall(state::Mem* mem, state::MutableOpts* mutable_opts, value::Proc* proc, List<BigStr*>* argv, syntax_asdl::CompoundWord* invoke_loc);
  ~ctx_ProcCall();
  Dict<BigStr*, runtime_asdl::Cell*>* saved_globals{};
  state::Mem* mem{};
  state::MutableOpts* mutable_opts{};
  bool sh_compat{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ProcCall)
};

class ctx_EvalInFrame {
 public:
  ctx_EvalInFrame(state::Mem* mem, Dict<BigStr*, runtime_asdl::Cell*>* frame);
  ~ctx_EvalInFrame();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_EvalInFrame)
};

class ctx_Temp {
 public:
  ctx_Temp(state::Mem* mem);
  ~ctx_Temp();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Temp)
};

class ctx_EnvObj {
 public:
  ctx_EnvObj(state::Mem* mem, Dict<BigStr*, value_asdl::value_t*>* bindings);
  ~ctx_EnvObj();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_EnvObj)
};

class ctx_Registers {
 public:
  ctx_Registers(state::Mem* mem);
  ~ctx_Registers();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Registers)
};

class ctx_ThisDir {
 public:
  ctx_ThisDir(state::Mem* mem, BigStr* filename);
  ~ctx_ThisDir();
  state::Mem* mem{};
  bool do_pop{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ThisDir)
};

runtime_asdl::Cell* _MakeArgvCell(List<BigStr*>* argv);
class ctx_LoopFrame {
 public:
  ctx_LoopFrame(state::Mem* mem, bool do_new_frame);
  ~ctx_LoopFrame();
  state::Mem* mem{};
  Dict<BigStr*, runtime_asdl::Cell*>* new_frame{};
  bool do_new_frame{};

  DISALLOW_COPY_AND_ASSIGN(ctx_LoopFrame)
};

class ctx_EnclosedFrame {
 public:
  ctx_EnclosedFrame(state::Mem* mem, Dict<BigStr*, runtime_asdl::Cell*>* to_enclose, Dict<BigStr*, runtime_asdl::Cell*>* module_frame, Dict<BigStr*, value_asdl::value_t*>* out_dict, bool inside = false);
  ~ctx_EnclosedFrame();
  state::Mem* mem{};
  Dict<BigStr*, runtime_asdl::Cell*>* to_enclose{};
  Dict<BigStr*, runtime_asdl::Cell*>* module_frame{};
  Dict<BigStr*, value_asdl::value_t*>* out_dict{};
  Dict<BigStr*, runtime_asdl::Cell*>* saved_globals{};
  Dict<BigStr*, runtime_asdl::Cell*>* new_frame{};

  DISALLOW_COPY_AND_ASSIGN(ctx_EnclosedFrame)
};

class ctx_CompoundWordDebugFrame {
 public:
  ctx_CompoundWordDebugFrame(state::Mem* mem, syntax_asdl::CompoundWord* w);
  ~ctx_CompoundWordDebugFrame();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_CompoundWordDebugFrame)
};

class ctx_TokenDebugFrame {
 public:
  ctx_TokenDebugFrame(state::Mem* mem, syntax_asdl::Token* tok);
  ~ctx_TokenDebugFrame();
  state::Mem* mem{};

  DISALLOW_COPY_AND_ASSIGN(ctx_TokenDebugFrame)
};

class ctx_ModuleEval {
 public:
  ctx_ModuleEval(state::Mem* mem, syntax_asdl::CompoundWord* use_loc, Dict<BigStr*, value_asdl::value_t*>* out_dict, List<BigStr*>* out_errors);
  ~ctx_ModuleEval();
  void ctx_EXIT();
  state::Mem* mem{};
  Dict<BigStr*, value_asdl::value_t*>* out_dict{};
  List<BigStr*>* out_errors{};
  Dict<BigStr*, runtime_asdl::Cell*>* new_frame{};
  Dict<BigStr*, runtime_asdl::Cell*>* saved_frame{};
  bool to_restore{};

  DISALLOW_COPY_AND_ASSIGN(ctx_ModuleEval)
};

class ctx_Eval {
 public:
  ctx_Eval(state::Mem* mem, BigStr* dollar0, List<BigStr*>* pos_args, Dict<BigStr*, value_asdl::value_t*>* vars);
  ~ctx_Eval();
  void _Push(Dict<BigStr*, value_asdl::value_t*>* vars);
  void _Pop();
  state::Mem* mem{};
  BigStr* dollar0{};
  List<BigStr*>* pos_args{};
  Dict<BigStr*, value_asdl::value_t*>* vars{};
  BigStr* restore_dollar0{};
  List<Tuple2<value_asdl::LeftName*, value_asdl::value_t*>*>* restore{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Eval)
};

Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> _FrameLookup(Dict<BigStr*, runtime_asdl::Cell*>* frame, BigStr* name, bool ysh_decl);
class Mem {
 public:
  Mem(BigStr* dollar0, List<BigStr*>* argv, alloc::Arena* arena, List<syntax_asdl::debug_frame_t*>* debug_stack, Dict<BigStr*, value_asdl::value_t*>* env_dict, Dict<BigStr*, value_asdl::value_t*>* defaults = nullptr);
  void AddBuiltin(BigStr* name, value_asdl::value_t* val);
  void SetPwd(BigStr* pwd);
  Tuple3<List<value_asdl::value_t*>*, List<value_asdl::value_t*>*, List<value_asdl::value_t*>*> Dump();
  void SetLastArgument(BigStr* s);
  void SetTokenForLine(syntax_asdl::Token* tok);
  void SetLocationForExpr(syntax_asdl::loc_t* blame_loc);
  syntax_asdl::loc_t* GetFallbackLocation();
  int LastStatus();
  int TryStatus();
  value::Dict* TryError();
  List<int>* PipeStatus();
  void SetLastStatus(int x);
  void SetTryStatus(int x);
  void SetTryError(value::Dict* x);
  void SetPipeStatus(List<int>* x);
  void SetSimplePipeStatus(int status);
  void SetProcessSubStatus(List<int>* x);
  bool ShouldRunDebugTrap();
  bool IsGlobalScope();
  bool InsideFunction();
  Dict<BigStr*, runtime_asdl::Cell*>* GlobalFrame();
  Dict<BigStr*, runtime_asdl::Cell*>* CurrentFrame();
  void PushSource(BigStr* source_name, List<BigStr*>* argv, syntax_asdl::CompoundWord* source_loc);
  void PopSource(List<BigStr*>* argv);
  void PushTemp();
  void PopTemp();
  void _BindEnvObj();
  void MaybeInitEnvDict(Dict<BigStr*, BigStr*>* environ);
  void PushEnvObj(Dict<BigStr*, value_asdl::value_t*>* bindings);
  void PopEnvObj();
  int Shift(int n);
  value::Str* GetArg0();
  value_asdl::value_t* GetArgNum(int arg_num);
  List<BigStr*>* GetArgv();
  void SetArgv(List<BigStr*>* argv);
  value_asdl::value_t* GetSpecialVar(int op_id);
  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> _ResolveNameForYshMutation(BigStr* name, runtime_asdl::scope_t which_scopes, bool ysh_decl);
  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> _ResolveNameOnly(BigStr* name, runtime_asdl::scope_t which_scopes);
  Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> _ResolveNameOrRef(BigStr* name, runtime_asdl::scope_t which_scopes, List<BigStr*>* ref_trail = nullptr);
  bool IsBashAssoc(BigStr* name);
  void SetPlace(value::Place* place, value_asdl::value_t* val, syntax_asdl::loc_t* blame_loc);
  void SetLocalName(value_asdl::LeftName* lval, value_asdl::value_t* val);
  void SetNamedYsh(value_asdl::LeftName* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags = 0);
  void SetNamed(value_asdl::LeftName* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags = 0);
  void SetValue(value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags = 0);
  void _BindNewArrayWithEntry(Dict<BigStr*, runtime_asdl::Cell*>* var_frame, sh_lvalue::Indexed* lval, value::Str* val, int flags, syntax_asdl::loc_t* blame_loc);
  void InternalSetGlobal(BigStr* name, value_asdl::value_t* new_val);
  value_asdl::value_t* GetValue(BigStr* name, runtime_asdl::scope_t which_scopes = scope_e::Shopt);
  runtime_asdl::Cell* GetCell(BigStr* name, runtime_asdl::scope_t which_scopes = scope_e::Shopt);
  runtime_asdl::Cell* GetCellDeref(BigStr* name, runtime_asdl::scope_t which_scopes = scope_e::Shopt);
  bool Unset(value_asdl::sh_lvalue_t* lval, runtime_asdl::scope_t which_scopes);
  runtime_asdl::scope_t ScopesForReading();
  runtime_asdl::scope_t ScopesForWriting();
  bool ClearFlag(BigStr* name, int flag);
  void _FillWithExported(Dict<BigStr*, BigStr*>* new_env);
  void _FillEnvObj(Dict<BigStr*, BigStr*>* new_env, value_asdl::Obj* env_object);
  Dict<BigStr*, BigStr*>* GetEnv();
  List<BigStr*>* VarNames();
  List<BigStr*>* VarNamesStartingWith(BigStr* prefix);
  Dict<BigStr*, BigStr*>* GetAllVars();
  Dict<BigStr*, runtime_asdl::Cell*>* GetAllCells(runtime_asdl::scope_t which_scopes);
  void SetRegexMatch(value_asdl::regex_match_t* match);
  value_asdl::regex_match_t* GetRegexMatch();
  void PushContextStack(Dict<BigStr*, value_asdl::value_t*>* context);
  Dict<BigStr*, value_asdl::value_t*>* GetContext();
  Dict<BigStr*, value_asdl::value_t*>* PopContextStack();
  optview::Exec* exec_opts{};
  sh_expr_eval::UnsafeArith* unsafe_arith{};
  BigStr* dollar0{};
  List<state::_ArgFrame*>* argv_stack{};
  List<Dict<BigStr*, runtime_asdl::Cell*>*>* var_stack{};
  List<syntax_asdl::debug_frame_t*>* debug_stack{};
  Dict<BigStr*, value_asdl::value_t*>* env_dict{};
  value_asdl::Obj* env_object{};
  Dict<BigStr*, value_asdl::value_t*>* defaults{};
  BigStr* pwd{};
  syntax_asdl::Token* token_for_line{};
  syntax_asdl::loc_t* loc_for_expr{};
  BigStr* last_arg{};
  value::Str* line_num{};
  List<int>* last_status{};
  List<int>* try_status{};
  List<value::Dict*>* try_error{};
  List<List<int>*>* pipe_status{};
  List<List<int>*>* process_sub_status{};
  List<BigStr*>* this_dir{};
  List<value_asdl::regex_match_t*>* regex_match{};
  List<Dict<BigStr*, value_asdl::value_t*>*>* ctx_stack{};
  Dict<BigStr*, value_asdl::value_t*>* builtins{};
  sh_init::EnvConfig* env_config{};
  double seconds_start{};
  int root_pid{};
  int last_bg_pid{};
  bool running_debug_trap{};
  bool running_err_trap{};
  bool is_main{};
  bool did_ysh_env{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(24, sizeof(Mem));
  }

  DISALLOW_COPY_AND_ASSIGN(Mem)
};

Tuple2<value_asdl::value_t*, value_asdl::Obj*> ValueIsInvokableObj(value_asdl::value_t* val);
void _AddNames(Dict<BigStr*, bool>* unique, Dict<BigStr*, runtime_asdl::Cell*>* frame);
class Procs {
 public:
  Procs(state::Mem* mem);
  void DefineShellFunc(BigStr* name, value::Proc* proc);
  bool IsShellFunc(BigStr* name);
  value::Proc* GetShellFunc(BigStr* name);
  void EraseShellFunc(BigStr* to_del);
  List<BigStr*>* ShellFuncNames();
  void DefineProc(BigStr* name, value::Proc* proc);
  bool IsProc(BigStr* name);
  bool IsInvokableObj(BigStr* name);
  List<BigStr*>* InvokableNames();
  Tuple2<value_asdl::value_t*, value_asdl::Obj*> GetInvokable(BigStr* name);
  state::Mem* mem{};
  Dict<BigStr*, value::Proc*>* sh_funcs{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(Procs));
  }

  DISALLOW_COPY_AND_ASSIGN(Procs)
};

void OshLanguageSetValue(state::Mem* mem, value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val, int flags = 0);
void BuiltinSetValue(state::Mem* mem, value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val);
void BuiltinSetString(state::Mem* mem, BigStr* name, BigStr* s);
void BuiltinSetArray(state::Mem* mem, BigStr* name, List<BigStr*>* a);
void SetGlobalString(state::Mem* mem, BigStr* name, BigStr* s);
void SetGlobalArray(state::Mem* mem, BigStr* name, List<BigStr*>* a);
void SetGlobalValue(state::Mem* mem, BigStr* name, value_asdl::value_t* val);
void SetLocalValue(state::Mem* mem, BigStr* name, value_asdl::value_t* val);
void ExportGlobalString(state::Mem* mem, BigStr* name, BigStr* s);
void SetStringInEnv(state::Mem* mem, BigStr* var_name, BigStr* s);
value_asdl::value_t* DynamicGetVar(state::Mem* mem, BigStr* name, runtime_asdl::scope_t which_scopes);
BigStr* GetString(state::Mem* mem, BigStr* name);
BigStr* MaybeString(state::Mem* mem, BigStr* name);
int GetInteger(state::Mem* mem, BigStr* name);

}  // declare namespace state

namespace util {  // declare

List<BigStr*>* RegexGroupStrings(BigStr* s, List<int>* indices);
List<BigStr*>* RegexSearch(BigStr* pat, BigStr* s);
class UserExit {
 public:
  UserExit(int status);
  int status{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(UserExit));
  }

  DISALLOW_COPY_AND_ASSIGN(UserExit)
};

class HistoryError {
 public:
  HistoryError(BigStr* msg);
  BigStr* UserErrorString();
  BigStr* msg{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(HistoryError));
  }

  DISALLOW_COPY_AND_ASSIGN(HistoryError)
};

class _DebugFile {
 public:
  _DebugFile();
  virtual void write(BigStr* s);
  virtual void writeln(BigStr* s);
  virtual bool isatty();
  
  static constexpr uint32_t field_mask() {
    return kZeroMask;
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_DebugFile));
  }

  DISALLOW_COPY_AND_ASSIGN(_DebugFile)
};

class NullDebugFile : public ::util::_DebugFile {
 public:
  NullDebugFile();
  
  static constexpr uint32_t field_mask() {
    return ::util::_DebugFile::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(NullDebugFile));
  }

  DISALLOW_COPY_AND_ASSIGN(NullDebugFile)
};

class DebugFile : public ::util::_DebugFile {
 public:
  DebugFile(mylib::Writer* f);
  virtual void write(BigStr* s);
  virtual void writeln(BigStr* s);
  virtual bool isatty();

  mylib::Writer* f{};
  
  static constexpr uint32_t field_mask() {
    return ::util::_DebugFile::field_mask()
         | maskbit(offsetof(DebugFile, f));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(DebugFile));
  }

  DISALLOW_COPY_AND_ASSIGN(DebugFile)
};

void PrintTopicHeader(BigStr* topic_id, mylib::Writer* f);
bool PrintEmbeddedHelp(pyutil::_ResourceLoader* loader, BigStr* topic_id, mylib::Writer* f);
void _PrintVersionLine(pyutil::_ResourceLoader* loader, mylib::Writer* f);
void HelpFlag(pyutil::_ResourceLoader* loader, BigStr* topic_id, mylib::Writer* f);
void VersionFlag(pyutil::_ResourceLoader* loader, mylib::Writer* f);

}  // declare namespace util

namespace j8 {  // declare

BigStr* ValType(value_asdl::value_t* val);
int ValueId(value_asdl::value_t* val);
BigStr* ValueIdString(value_asdl::value_t* val);
BigStr* Utf8Encode(int code);
extern int SHOW_CYCLES;
extern int LOSSY_JSON_STRINGS;
extern int INF_NAN_ARE_NULL;
extern int NON_DATA_IS_NULL;
extern int NON_DATA_IS_ERROR;
void _Print(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, int options = 0);
void PrintMessage(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, bool type_errors);
void PrintJsonMessage(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, bool type_errors);
void PrintLine(value_asdl::value_t* val, mylib::Writer* f);
void EncodeString(BigStr* s, mylib::BufWriter* buf, bool unquoted_ok = false);
BigStr* MaybeEncodeString(BigStr* s);
BigStr* MaybeEncodeJsonString(BigStr* s);
class InstancePrinter {
 public:
  InstancePrinter(mylib::BufWriter* buf, int indent, int options);
  void _ItemIndent(int level);
  void _BracketIndent(int level);
  void _MaybeNewline();
  void _MaybeSpace();
  void _PrintList(value::List* val, int level);
  void _PrintMapping(Dict<BigStr*, value_asdl::value_t*>* d, BigStr* left, BigStr* right, int level);
  void _PrintDict(value::Dict* val, int level);
  void _PrintObj(value_asdl::Obj* val, int level);
  void _PrintBashPrefix(BigStr* type_str, int level);
  void _PrintBashSuffix(int level);
  void _PrintBashArray(value::BashArray* val, int level);
  void _PrintInternalStringArray(value::InternalStringArray* val, int level);
  void _PrintBashAssoc(value::BashAssoc* val, int level);
  void Print(value_asdl::value_t* val, int level = 0);
  mylib::BufWriter* buf{};
  Dict<int, bool>* visiting{};
  int indent{};
  int options{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(InstancePrinter));
  }

  DISALLOW_COPY_AND_ASSIGN(InstancePrinter)
};

class LexerDecoder {
 public:
  LexerDecoder(BigStr* s, bool is_j8, BigStr* lang_str);
  error::Decode* _Error(BigStr* msg, int end_pos);
  Tuple3<int, int, BigStr*> Next();
  Tuple3<int, int, BigStr*> NextForLines();
  Tuple3<int, int, BigStr*> _DecodeString(int left_id, int str_pos);
  BigStr* s{};
  BigStr* lang_str{};
  mylib::BufWriter* decoded{};
  bool is_j8{};
  int pos{};
  int cur_line_num{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(LexerDecoder));
  }

  DISALLOW_COPY_AND_ASSIGN(LexerDecoder)
};

class _Parser {
 public:
  _Parser(BigStr* s, bool is_j8);
  void _Next();
  void _Eat(int tok_id);
  void _NextForLines();
  error::Decode* _ParseError(BigStr* msg);
  BigStr* decoded{};
  int end_pos{};
  bool is_j8{};
  BigStr* lang_str{};
  j8::LexerDecoder* lexer{};
  BigStr* s{};
  int start_pos{};
  int tok_id{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(_Parser, decoded))
         | maskbit(offsetof(_Parser, lang_str))
         | maskbit(offsetof(_Parser, lexer))
         | maskbit(offsetof(_Parser, s));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_Parser));
  }

  DISALLOW_COPY_AND_ASSIGN(_Parser)
};

class Parser : public ::j8::_Parser {
 public:
  Parser(BigStr* s, bool is_j8);
  Tuple2<BigStr*, value_asdl::value_t*> _ParsePair();
  value_asdl::value_t* _ParseDict();
  value_asdl::value_t* _ParseList();
  value_asdl::value_t* _ParseValue();
  value_asdl::value_t* ParseValue();
  
  static constexpr uint32_t field_mask() {
    return ::j8::_Parser::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Parser));
  }

  DISALLOW_COPY_AND_ASSIGN(Parser)
};

class Nil8Parser : public ::j8::_Parser {
 public:
  Nil8Parser(BigStr* s, bool is_j8);
  nil8_asdl::nvalue_t* _ParseRecord();
  nil8_asdl::nvalue_t* _ParseList8();
  nil8_asdl::nvalue_t* _ParseNil8();
  nil8_asdl::nvalue_t* ParseNil8();
  
  static constexpr uint32_t field_mask() {
    return ::j8::_Parser::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Nil8Parser));
  }

  DISALLOW_COPY_AND_ASSIGN(Nil8Parser)
};

class J8LinesParser : public ::j8::_Parser {
 public:
  J8LinesParser(BigStr* s);
  void _Show(BigStr* s);
  void _ParseLine(List<BigStr*>* out);
  List<BigStr*>* Parse();
  
  static constexpr uint32_t field_mask() {
    return ::j8::_Parser::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(J8LinesParser));
  }

  DISALLOW_COPY_AND_ASSIGN(J8LinesParser)
};

List<BigStr*>* SplitJ8Lines(BigStr* s);

}  // declare namespace j8

namespace j8_lite {  // declare

BigStr* EncodeString(BigStr* s, bool unquoted_ok = false);
BigStr* YshEncodeString(BigStr* s);
BigStr* MaybeShellEncode(BigStr* s);
BigStr* ShellEncode(BigStr* s);
BigStr* YshEncode(BigStr* s, bool unquoted_ok = false);

}  // declare namespace j8_lite

namespace ansi {  // declare

extern BigStr* RESET;
extern BigStr* BOLD;
extern BigStr* UNDERLINE;
extern BigStr* REVERSE;
extern BigStr* RED;
extern BigStr* GREEN;
extern BigStr* YELLOW;
extern BigStr* BLUE;
extern BigStr* MAGENTA;
extern BigStr* CYAN;
extern BigStr* WHITE;

}  // declare namespace ansi

namespace pp_hnode {  // declare

class BaseEncoder {
 public:
  BaseEncoder();
  void SetIndent(int indent);
  void SetUseStyles(bool use_styles);
  void SetMaxTabularWidth(int max_tabular_width);
  pretty_asdl::MeasuredDoc* _Styled(BigStr* style, pretty_asdl::MeasuredDoc* mdoc);
  pretty_asdl::MeasuredDoc* _StyledAscii(BigStr* style, BigStr* s);
  pretty_asdl::MeasuredDoc* _Surrounded(BigStr* left, pretty_asdl::MeasuredDoc* mdoc, BigStr* right);
  pretty_asdl::MeasuredDoc* _SurroundedAndPrefixed(BigStr* left, pretty_asdl::MeasuredDoc* prefix, BigStr* sep, pretty_asdl::MeasuredDoc* mdoc, BigStr* right);
  pretty_asdl::MeasuredDoc* _Join(List<pretty_asdl::MeasuredDoc*>* items, BigStr* sep, BigStr* space);
  pretty_asdl::MeasuredDoc* _Tabular(List<pretty_asdl::MeasuredDoc*>* items, BigStr* sep);
  int indent{};
  int max_tabular_width{};
  bool use_styles{};
  Dict<int, bool>* visiting{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(BaseEncoder, visiting));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(BaseEncoder));
  }

  DISALLOW_COPY_AND_ASSIGN(BaseEncoder)
};

class HNodeEncoder : public ::pp_hnode::BaseEncoder {
 public:
  HNodeEncoder();
  pretty_asdl::MeasuredDoc* HNode(hnode_asdl::hnode_t* h);
  pretty_asdl::MeasuredDoc* _Field(hnode_asdl::Field* field);
  pretty_asdl::MeasuredDoc* _HNode(hnode_asdl::hnode_t* h);

  BigStr* field_color{};
  BigStr* type_color{};
  
  static constexpr uint32_t field_mask() {
    return ::pp_hnode::BaseEncoder::field_mask()
         | maskbit(offsetof(HNodeEncoder, field_color))
         | maskbit(offsetof(HNodeEncoder, type_color));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(HNodeEncoder));
  }

  DISALLOW_COPY_AND_ASSIGN(HNodeEncoder)
};


}  // declare namespace pp_hnode

namespace pp_value {  // declare

BigStr* ValType(value_asdl::value_t* val);
BigStr* FloatString(double fl);
int TryUnicodeWidth(BigStr* s);
pretty_asdl::MeasuredDoc* UText(BigStr* string);
class ValueEncoder : public ::pp_hnode::BaseEncoder {
 public:
  ValueEncoder();
  List<pretty_asdl::MeasuredDoc*>* TypePrefix(BigStr* type_str);
  pretty_asdl::MeasuredDoc* Value(value_asdl::value_t* val);
  pretty_asdl::MeasuredDoc* _DictKey(BigStr* s);
  pretty_asdl::MeasuredDoc* _StringLiteral(BigStr* s);
  pretty_asdl::MeasuredDoc* _BashStringLiteral(BigStr* s);
  pretty_asdl::MeasuredDoc* _YshList(value::List* vlist);
  List<pretty_asdl::MeasuredDoc*>* _DictMdocs(Dict<BigStr*, value_asdl::value_t*>* d);
  pretty_asdl::MeasuredDoc* _YshDict(value::Dict* vdict);
  pretty_asdl::MeasuredDoc* _InternalStringArray(value::InternalStringArray* varray);
  pretty_asdl::MeasuredDoc* _BashAssoc(value::BashAssoc* vassoc);
  pretty_asdl::MeasuredDoc* _BashArray(value::BashArray* val);
  pretty_asdl::MeasuredDoc* _Obj(value_asdl::Obj* obj);
  pretty_asdl::MeasuredDoc* _Value(value_asdl::value_t* val);

  BigStr* bool_style{};
  BigStr* cycle_style{};
  BigStr* float_style{};
  BigStr* int_style{};
  BigStr* null_style{};
  BigStr* string_style{};
  BigStr* type_style{};
  bool ysh_style{};
  
  static constexpr uint32_t field_mask() {
    return ::pp_hnode::BaseEncoder::field_mask()
         | maskbit(offsetof(ValueEncoder, bool_style))
         | maskbit(offsetof(ValueEncoder, cycle_style))
         | maskbit(offsetof(ValueEncoder, float_style))
         | maskbit(offsetof(ValueEncoder, int_style))
         | maskbit(offsetof(ValueEncoder, null_style))
         | maskbit(offsetof(ValueEncoder, string_style))
         | maskbit(offsetof(ValueEncoder, type_style));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(ValueEncoder));
  }

  DISALLOW_COPY_AND_ASSIGN(ValueEncoder)
};


}  // declare namespace pp_value

namespace pretty {  // declare

pretty_asdl::Measure* _EmptyMeasure();
pretty_asdl::Measure* _FlattenMeasure(pretty_asdl::Measure* measure);
pretty_asdl::Measure* _ConcatMeasure(pretty_asdl::Measure* m1, pretty_asdl::Measure* m2);
int _SuffixLen(pretty_asdl::Measure* measure);
pretty_asdl::MeasuredDoc* AsciiText(BigStr* string);
pretty_asdl::MeasuredDoc* _Break(BigStr* string);
pretty_asdl::MeasuredDoc* _Indent(int indent, pretty_asdl::MeasuredDoc* mdoc);
pretty_asdl::Measure* _Splice(List<pretty_asdl::MeasuredDoc*>* out, List<pretty_asdl::MeasuredDoc*>* mdocs);
pretty_asdl::MeasuredDoc* _Concat(List<pretty_asdl::MeasuredDoc*>* mdocs);
pretty_asdl::MeasuredDoc* _Group(pretty_asdl::MeasuredDoc* mdoc);
pretty_asdl::MeasuredDoc* _IfFlat(pretty_asdl::MeasuredDoc* flat_mdoc, pretty_asdl::MeasuredDoc* nonflat_mdoc);
pretty_asdl::MeasuredDoc* _Flat(pretty_asdl::MeasuredDoc* mdoc);
class PrettyPrinter {
 public:
  PrettyPrinter(int max_width);
  bool _Fits(int prefix_len, pretty_asdl::MeasuredDoc* group, pretty_asdl::Measure* suffix_measure);
  void PrintDoc(pretty_asdl::MeasuredDoc* document, mylib::BufWriter* buf);
  int max_width{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(PrettyPrinter));
  }

  DISALLOW_COPY_AND_ASSIGN(PrettyPrinter)
};


}  // declare namespace pretty

namespace ui {  // declare

BigStr* ValType(value_asdl::value_t* val);
BigStr* CommandType(syntax_asdl::command_t* cmd);
BigStr* PrettyId(int id_);
BigStr* PrettyToken(syntax_asdl::Token* tok);
BigStr* PrettyDir(BigStr* dir_name, BigStr* home_dir);
void PrintCaretLine(BigStr* line, int col, int length, mylib::Writer* f);
void _PrintCodeExcerpt(BigStr* line, int col, int length, mylib::Writer* f);
void _PrintTokenTooLong(loc::TokenTooLong* loc_tok, mylib::Writer* f);
BigStr* GetFilenameString(syntax_asdl::SourceLine* line);
BigStr* GetLineSourceString(syntax_asdl::SourceLine* line, bool quote_filename = false);
void _PrintWithLocation(BigStr* prefix, BigStr* msg, syntax_asdl::loc_t* blame_loc, bool show_code);
Tuple2<BigStr*, BigStr*> CodeExcerptAndPrefix(syntax_asdl::Token* blame_tok);
class ctx_Location {
 public:
  ctx_Location(ui::ErrorFormatter* errfmt, syntax_asdl::loc_t* location);
  ~ctx_Location();
  ui::ErrorFormatter* errfmt{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Location)
};

class ErrorFormatter {
 public:
  ErrorFormatter();
  void OneLineErrExit();
  syntax_asdl::loc_t* _FallbackLocation(syntax_asdl::loc_t* blame_loc);
  void PrefixPrint(BigStr* msg, BigStr* prefix, syntax_asdl::loc_t* blame_loc);
  void Print_(BigStr* msg, syntax_asdl::loc_t* blame_loc = nullptr);
  void PrintMessage(BigStr* msg, syntax_asdl::loc_t* blame_loc = nullptr);
  void StderrLine(BigStr* msg);
  void PrettyPrintError(error::_ErrorWithLocation* err, BigStr* prefix = S_Aoo);
  void PrintErrExit(error::ErrExit* err, int pid);
  List<syntax_asdl::loc_t*>* loc_stack{};
  bool one_line_errexit{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(ErrorFormatter));
  }

  DISALLOW_COPY_AND_ASSIGN(ErrorFormatter)
};

void PrintAst(syntax_asdl::command_t* node, arg_types::main* flag);
bool TypeNotPrinted(value_asdl::value_t* val);
int _GetMaxWidth();
void PrettyPrintValue(BigStr* prefix, value_asdl::value_t* val, mylib::Writer* f, int max_width = -1);

}  // declare namespace ui

namespace lexer {  // declare

bool IsPlusEquals(syntax_asdl::Token* tok);
bool TokenContains(syntax_asdl::Token* tok, BigStr* substr);
bool TokenEquals(syntax_asdl::Token* tok, BigStr* s);
bool TokenStartsWith(syntax_asdl::Token* tok, BigStr* s);
bool TokenEndsWith(syntax_asdl::Token* tok, BigStr* s);
BigStr* TokenVal(syntax_asdl::Token* tok);
BigStr* TokenSliceLeft(syntax_asdl::Token* tok, int left_index);
BigStr* TokenSliceRight(syntax_asdl::Token* tok, int right_index);
BigStr* TokenSlice(syntax_asdl::Token* tok, int left, int right);
BigStr* LazyStr(syntax_asdl::Token* tok);
syntax_asdl::Token* DummyToken(int id_, BigStr* val);
class LineLexer {
 public:
  LineLexer(alloc::Arena* arena);
  void Reset(syntax_asdl::SourceLine* src_line, int line_pos);
  bool MaybeUnreadOne();
  syntax_asdl::Token* GetEofToken(int id_);
  int LookAheadOne(types_asdl::lex_mode_t lex_mode);
  void AssertAtEndOfLine();
  int LookPastSpace(types_asdl::lex_mode_t lex_mode);
  bool LookAheadFuncParens(int unread);
  BigStr* ByteLookAhead();
  int ByteLookBack();
  syntax_asdl::Token* Read(types_asdl::lex_mode_t lex_mode);
  alloc::Arena* arena{};
  syntax_asdl::Token* eol_tok{};
  syntax_asdl::SourceLine* src_line{};
  bool replace_last_token{};
  int line_pos{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(LineLexer));
  }

  DISALLOW_COPY_AND_ASSIGN(LineLexer)
};

class Lexer {
 public:
  Lexer(lexer::LineLexer* line_lexer, reader::_Reader* line_reader);
  void ResetInputObjects();
  bool MaybeUnreadOne();
  int LookAheadOne(types_asdl::lex_mode_t lex_mode);
  int LookPastSpace(types_asdl::lex_mode_t lex_mode);
  bool LookAheadFuncParens(int unread);
  BigStr* ByteLookAhead();
  int ByteLookBack();
  void EmitCompDummy();
  void PushHint(int old_id, int new_id);
  bool MoveToNextLine();
  syntax_asdl::Token* _Read(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::Token* Read(types_asdl::lex_mode_t lex_mode);
  lexer::LineLexer* line_lexer{};
  reader::_Reader* line_reader{};
  List<Tuple2<int, int>*>* translation_stack{};
  int line_id{};
  bool emit_comp_dummy{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(Lexer));
  }

  DISALLOW_COPY_AND_ASSIGN(Lexer)
};


}  // declare namespace lexer

namespace location {  // declare

value_asdl::LeftName* LName(BigStr* name);
syntax_asdl::Token* TokenFor(syntax_asdl::loc_t* loc_);
syntax_asdl::Token* TokenForCommand(syntax_asdl::command_t* node);
syntax_asdl::Token* TokenForArith(syntax_asdl::arith_expr_t* node);
syntax_asdl::Token* LeftTokenForWordPart(syntax_asdl::word_part_t* part);
syntax_asdl::Token* _RightTokenForWordPart(syntax_asdl::word_part_t* part);
syntax_asdl::Token* LeftTokenForCompoundWord(syntax_asdl::CompoundWord* w);
syntax_asdl::Token* LeftTokenForWord(syntax_asdl::word_t* w);
syntax_asdl::Token* RightTokenForWord(syntax_asdl::word_t* w);
syntax_asdl::Token* TokenForLhsExpr(syntax_asdl::sh_lhs_t* node);
syntax_asdl::loc_t* TokenForExpr(syntax_asdl::expr_t* node);

}  // declare namespace location

namespace parse_lib {  // declare

class _BaseTrail {
 public:
  _BaseTrail();
  virtual void Clear();
  virtual void SetLatestWords(List<syntax_asdl::CompoundWord*>* words, List<syntax_asdl::Redir*>* redirects);
  virtual void AppendToken(syntax_asdl::Token* token);
  void BeginAliasExpansion();
  void EndAliasExpansion();
  bool _expanding_alias{};
  List<syntax_asdl::CompoundWord*>* alias_words{};
  List<syntax_asdl::Redir*>* redirects{};
  List<syntax_asdl::Token*>* tokens{};
  List<syntax_asdl::CompoundWord*>* words{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(_BaseTrail, alias_words))
         | maskbit(offsetof(_BaseTrail, redirects))
         | maskbit(offsetof(_BaseTrail, tokens))
         | maskbit(offsetof(_BaseTrail, words));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_BaseTrail));
  }

  DISALLOW_COPY_AND_ASSIGN(_BaseTrail)
};

class ctx_Alias {
 public:
  ctx_Alias(parse_lib::_BaseTrail* trail);
  ~ctx_Alias();
  parse_lib::_BaseTrail* trail{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Alias)
};

class Trail : public ::parse_lib::_BaseTrail {
 public:
  Trail();
  virtual void Clear();
  virtual void SetLatestWords(List<syntax_asdl::CompoundWord*>* words, List<syntax_asdl::Redir*>* redirects);
  virtual void AppendToken(syntax_asdl::Token* token);
  
  static constexpr uint32_t field_mask() {
    return ::parse_lib::_BaseTrail::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Trail));
  }

  DISALLOW_COPY_AND_ASSIGN(Trail)
};

class ParseContext {
 public:
  ParseContext(alloc::Arena* arena, optview::Parse* parse_opts, Dict<BigStr*, BigStr*>* aliases, grammar::Grammar* ysh_grammar, bool do_lossless = false);
  void Init_Trail(parse_lib::_BaseTrail* trail);
  lexer::Lexer* MakeLexer(reader::_Reader* line_reader);
  cmd_parse::CommandParser* MakeOshParser(reader::_Reader* line_reader, bool emit_comp_dummy = false);
  cmd_parse::CommandParser* MakeConfigParser(reader::_Reader* line_reader);
  word_parse::WordParser* MakeWordParserForHereDoc(reader::_Reader* line_reader);
  word_parse::WordParser* MakeWordParser(lexer::Lexer* lx, reader::_Reader* line_reader);
  tdop::TdopParser* MakeArithParser(BigStr* code_str);
  cmd_parse::CommandParser* MakeParserForCommandSub(reader::_Reader* line_reader, lexer::Lexer* lexer, int eof_id);
  word_parse::WordParser* MakeWordParserForPlugin(BigStr* code_str);
  expr_parse::ExprParser* _YshParser();
  Tuple2<syntax_asdl::VarDecl*, syntax_asdl::Token*> ParseVarDecl(syntax_asdl::Token* kw_token, lexer::Lexer* lexer);
  Tuple2<syntax_asdl::Mutation*, syntax_asdl::Token*> ParseMutation(syntax_asdl::Token* kw_token, lexer::Lexer* lexer);
  void ParseProcCallArgs(lexer::Lexer* lx, syntax_asdl::ArgList* out, int start_symbol);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> ParseYshExpr(lexer::Lexer* lx, int start_symbol);
  Tuple3<syntax_asdl::pat_t*, syntax_asdl::Token*, syntax_asdl::Token*> ParseYshCasePattern(lexer::Lexer* lexer);
  syntax_asdl::Token* ParseProc(lexer::Lexer* lexer, syntax_asdl::Proc* out);
  syntax_asdl::Token* ParseFunc(lexer::Lexer* lexer, syntax_asdl::Func* out);
  alloc::Arena* arena{};
  optview::Parse* parse_opts{};
  Dict<BigStr*, BigStr*>* aliases{};
  grammar::Grammar* ysh_grammar{};
  expr_to_ast::Transformer* tr{};
  parse_lib::_BaseTrail* trail{};
  bool do_lossless{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(6, sizeof(ParseContext));
  }

  DISALLOW_COPY_AND_ASSIGN(ParseContext)
};


}  // declare namespace parse_lib

namespace reader {  // declare

extern BigStr* _PS2;
class _Reader {
 public:
  _Reader(alloc::Arena* arena);
  void SetLineOffset(int n);
  virtual BigStr* _GetLine();
  virtual Tuple2<syntax_asdl::SourceLine*, int> GetLine();
  virtual void Reset();
  virtual bool LastLineHint();
  alloc::Arena* arena{};
  int line_num{};
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(_Reader, arena));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_Reader));
  }

  DISALLOW_COPY_AND_ASSIGN(_Reader)
};

class DisallowedLineReader : public ::reader::_Reader {
 public:
  DisallowedLineReader(alloc::Arena* arena, syntax_asdl::Token* blame_token);
  virtual BigStr* _GetLine();

  syntax_asdl::Token* blame_token{};
  
  static constexpr uint32_t field_mask() {
    return ::reader::_Reader::field_mask()
         | maskbit(offsetof(DisallowedLineReader, blame_token));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(DisallowedLineReader));
  }

  DISALLOW_COPY_AND_ASSIGN(DisallowedLineReader)
};

class FileLineReader : public ::reader::_Reader {
 public:
  FileLineReader(mylib::LineReader* f, alloc::Arena* arena);
  virtual BigStr* _GetLine();
  virtual bool LastLineHint();

  mylib::LineReader* f{};
  bool last_line_hint{};
  
  static constexpr uint32_t field_mask() {
    return ::reader::_Reader::field_mask()
         | maskbit(offsetof(FileLineReader, f));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(FileLineReader));
  }

  DISALLOW_COPY_AND_ASSIGN(FileLineReader)
};

reader::FileLineReader* StringLineReader(BigStr* s, alloc::Arena* arena);
class VirtualLineReader : public ::reader::_Reader {
 public:
  VirtualLineReader(alloc::Arena* arena, List<Tuple2<syntax_asdl::SourceLine*, int>*>* lines, bool do_lossless);
  virtual Tuple2<syntax_asdl::SourceLine*, int> GetLine();

  bool do_lossless{};
  List<Tuple2<syntax_asdl::SourceLine*, int>*>* lines{};
  int num_lines{};
  int pos{};
  
  static constexpr uint32_t field_mask() {
    return ::reader::_Reader::field_mask()
         | maskbit(offsetof(VirtualLineReader, lines));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(VirtualLineReader));
  }

  DISALLOW_COPY_AND_ASSIGN(VirtualLineReader)
};

BigStr* _PlainPromptInput(BigStr* prompt);
class InteractiveLineReader : public ::reader::_Reader {
 public:
  InteractiveLineReader(alloc::Arena* arena, prompt::Evaluator* prompt_ev, history::Evaluator* hist_ev, py_readline::Readline* line_input, comp_ui::PromptState* prompt_state);
  virtual void Reset();
  BigStr* _ReadlinePromptInput();
  virtual BigStr* _GetLine();

  history::Evaluator* hist_ev{};
  py_readline::Readline* line_input{};
  BigStr* prev_line{};
  prompt::Evaluator* prompt_ev{};
  comp_ui::PromptState* prompt_state{};
  BigStr* prompt_str{};
  bool render_ps1{};
  
  static constexpr uint32_t field_mask() {
    return ::reader::_Reader::field_mask()
         | maskbit(offsetof(InteractiveLineReader, hist_ev))
         | maskbit(offsetof(InteractiveLineReader, line_input))
         | maskbit(offsetof(InteractiveLineReader, prev_line))
         | maskbit(offsetof(InteractiveLineReader, prompt_ev))
         | maskbit(offsetof(InteractiveLineReader, prompt_state))
         | maskbit(offsetof(InteractiveLineReader, prompt_str));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(InteractiveLineReader));
  }

  DISALLOW_COPY_AND_ASSIGN(InteractiveLineReader)
};


}  // declare namespace reader

namespace syntax_abbrev {  // declare

void _AbbreviateToken(syntax_asdl::Token* tok, List<hnode_asdl::hnode_t*>* out);
hnode_asdl::hnode_t* _Token(syntax_asdl::Token* obj);
hnode_asdl::hnode_t* _CompoundWord(syntax_asdl::CompoundWord* obj);
hnode_asdl::hnode_t* _DoubleQuoted(syntax_asdl::DoubleQuoted* obj);
hnode_asdl::hnode_t* _SingleQuoted(syntax_asdl::SingleQuoted* obj);
hnode_asdl::hnode_t* _SimpleVarSub(syntax_asdl::SimpleVarSub* obj);
hnode_asdl::hnode_t* _BracedVarSub(syntax_asdl::BracedVarSub* obj);
hnode_asdl::hnode_t* _command__Simple(command::Simple* obj);
hnode_asdl::hnode_t* _expr__Var(expr::Var* obj);
hnode_asdl::hnode_t* _expr__Const(expr::Const* obj);

}  // declare namespace syntax_abbrev

namespace arith_parse {  // declare

syntax_asdl::arith_expr_t* NullIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* NullUnaryPlus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullUnaryMinus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* LeftIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftIndex(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int unused_bp);
syntax_asdl::arith_expr_t* LeftTernary(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int bp);

}  // declare namespace arith_parse

namespace bool_parse {  // declare

class BoolParser {
 public:
  BoolParser(word_parse::WordEmitter* w_parser);
  void _NextOne(types_asdl::lex_mode_t lex_mode = lex_mode_e::DBracket);
  void _Next(types_asdl::lex_mode_t lex_mode = lex_mode_e::DBracket);
  syntax_asdl::word_t* _LookAhead();
  Tuple2<syntax_asdl::bool_expr_t*, syntax_asdl::Token*> Parse();
  bool _TestAtEnd();
  syntax_asdl::bool_expr_t* ParseForBuiltin();
  syntax_asdl::bool_expr_t* ParseExpr();
  syntax_asdl::bool_expr_t* ParseTerm();
  syntax_asdl::bool_expr_t* ParseNegatedFactor();
  syntax_asdl::bool_expr_t* ParseFactor();
  word_parse::WordEmitter* w_parser{};
  List<syntax_asdl::word_t*>* words{};
  syntax_asdl::word_t* cur_word{};
  int bool_id{};
  id_kind_asdl::Kind_t bool_kind{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(BoolParser));
  }

  DISALLOW_COPY_AND_ASSIGN(BoolParser)
};


}  // declare namespace bool_parse

namespace braces {  // declare

extern int NO_STEP;
class _NotARange {
 public:
  _NotARange(BigStr* s);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_NotARange));
  }

  DISALLOW_COPY_AND_ASSIGN(_NotARange)
};

class _RangeParser {
 public:
  _RangeParser(match::SimpleLexer* lexer, syntax_asdl::Token* blame_tok);
  void _Next();
  BigStr* _Eat(int token_type);
  int _ParseStep();
  word_part::BracedRange* _ParseRange(int range_kind);
  word_part::BracedRange* Parse();
  match::SimpleLexer* lexer{};
  syntax_asdl::Token* blame_tok{};
  BigStr* token_val{};
  int token_type{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(_RangeParser));
  }

  DISALLOW_COPY_AND_ASSIGN(_RangeParser)
};

word_part::BracedRange* _RangePartDetect(syntax_asdl::Token* tok);
class _StackFrame {
 public:
  _StackFrame(List<syntax_asdl::word_part_t*>* cur_parts);
  List<syntax_asdl::word_part_t*>* cur_parts{};
  word_part::BracedTuple* alt_part{};
  bool saw_comma{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(_StackFrame));
  }

  DISALLOW_COPY_AND_ASSIGN(_StackFrame)
};

word::BracedTree* BraceDetect(syntax_asdl::CompoundWord* w);
List<syntax_asdl::word_t*>* BraceDetectAll(List<syntax_asdl::CompoundWord*>* words);
int _LeadingZeros(BigStr* s);
BigStr* _IntToString(int i, int width);
List<BigStr*>* _RangeStrings(word_part::BracedRange* part);
List<List<syntax_asdl::word_part_t*>*>* _ExpandPart(List<syntax_asdl::word_part_t*>* parts, int first_alt_index, List<List<syntax_asdl::word_part_t*>*>* suffixes);
List<List<syntax_asdl::word_part_t*>*>* _BraceExpand(List<syntax_asdl::word_part_t*>* parts);
List<syntax_asdl::CompoundWord*>* BraceExpandWords(List<syntax_asdl::word_t*>* words);

}  // declare namespace braces

namespace cmd_parse {  // declare

extern int TAB_CH;
extern int SPACE_CH;
Tuple2<List<Tuple2<syntax_asdl::SourceLine*, int>*>*, Tuple2<syntax_asdl::SourceLine*, int>*> _ReadHereLines(reader::_Reader* line_reader, syntax_asdl::Redir* h, BigStr* delimiter);
List<syntax_asdl::word_part_t*>* _MakeLiteralHereLines(List<Tuple2<syntax_asdl::SourceLine*, int>*>* here_lines, alloc::Arena* arena, bool do_lossless);
void _ParseHereDocBody(parse_lib::ParseContext* parse_ctx, syntax_asdl::Redir* r, reader::_Reader* line_reader, alloc::Arena* arena);
syntax_asdl::AssignPair* _MakeAssignPair(parse_lib::ParseContext* parse_ctx, syntax_asdl::ParsedAssignment* preparsed, alloc::Arena* arena);
void _AppendMoreEnv(List<syntax_asdl::ParsedAssignment*>* preparsed_list, List<syntax_asdl::EnvPair*>* more_env);
Tuple2<List<syntax_asdl::ParsedAssignment*>*, List<syntax_asdl::CompoundWord*>*> _SplitSimpleCommandPrefix(List<syntax_asdl::CompoundWord*>* words);
command::Simple* _MakeSimpleCommand(List<syntax_asdl::ParsedAssignment*>* preparsed_list, List<syntax_asdl::CompoundWord*>* suffix_words, syntax_asdl::ArgList* typed_args, value_asdl::LiteralBlock* block);
class VarChecker {
 public:
  VarChecker();
  void Push(syntax_asdl::Token* blame_tok);
  void Pop();
  void Check(int keyword_id, BigStr* var_name, syntax_asdl::Token* blame_tok);
  List<syntax_asdl::Token*>* tokens{};
  List<Dict<BigStr*, int>*>* names{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(VarChecker));
  }

  DISALLOW_COPY_AND_ASSIGN(VarChecker)
};

class ctx_VarChecker {
 public:
  ctx_VarChecker(cmd_parse::VarChecker* var_checker, syntax_asdl::Token* blame_tok);
  ~ctx_VarChecker();
  cmd_parse::VarChecker* var_checker{};

  DISALLOW_COPY_AND_ASSIGN(ctx_VarChecker)
};

class ctx_CmdMode {
 public:
  ctx_CmdMode(cmd_parse::CommandParser* cmd_parse, types_asdl::cmd_mode_t new_cmd_mode);
  ~ctx_CmdMode();
  cmd_parse::CommandParser* cmd_parse{};
  types_asdl::cmd_mode_t prev_cmd_mode{};

  DISALLOW_COPY_AND_ASSIGN(ctx_CmdMode)
};

extern List<int>* SECONDARY_KEYWORDS;
class CommandParser {
 public:
  CommandParser(parse_lib::ParseContext* parse_ctx, optview::Parse* parse_opts, word_parse::WordParser* w_parser, lexer::Lexer* lexer, reader::_Reader* line_reader, int eof_id = Id::Eof_Real);
  void Init_AliasesInFlight(List<Tuple2<BigStr*, int>*>* aliases_in_flight);
  void Reset();
  void ResetInputObjects();
  void _SetNext();
  void _SetNextBrack();
  void _GetWord();
  syntax_asdl::word_t* _Eat(int c_id, BigStr* msg = nullptr);
  void _NewlineOk();
  bool _AtSecondaryKeyword();
  syntax_asdl::Redir* ParseRedirect();
  List<syntax_asdl::Redir*>* _ParseRedirectList();
  syntax_asdl::command_t* _MaybeParseRedirectList(syntax_asdl::command_t* node);
  Tuple4<List<syntax_asdl::Redir*>*, List<syntax_asdl::CompoundWord*>*, syntax_asdl::ArgList*, value_asdl::LiteralBlock*> _ScanSimpleCommand();
  syntax_asdl::command_t* _MaybeExpandAliases(List<syntax_asdl::CompoundWord*>* words);
  syntax_asdl::command_t* ParseSimpleCommand();
  syntax_asdl::BraceGroup* ParseBraceGroup();
  command::DoGroup* ParseDoGroup();
  Tuple2<List<syntax_asdl::CompoundWord*>*, syntax_asdl::Token*> ParseForWords();
  command::ForExpr* _ParseForExprLoop(syntax_asdl::Token* for_kw);
  command::ForEach* _ParseForEachLoop(syntax_asdl::Token* for_kw);
  syntax_asdl::command_t* ParseFor();
  syntax_asdl::condition_t* _ParseConditionList();
  command::WhileUntil* ParseWhileUntil(syntax_asdl::Token* keyword);
  syntax_asdl::CaseArm* ParseCaseArm();
  syntax_asdl::CaseArm* ParseYshCaseArm(int discriminant);
  command::Case* ParseYshCase(syntax_asdl::Token* case_kw);
  command::Case* ParseOldCase(syntax_asdl::Token* case_kw);
  command::Case* ParseCase();
  void _ParseYshElifElse(command::If* if_node);
  command::If* _ParseYshIf(syntax_asdl::Token* if_kw, syntax_asdl::condition_t* cond);
  void _ParseElifElse(command::If* if_node);
  command::If* ParseIf();
  syntax_asdl::command_t* ParseTime();
  syntax_asdl::command_t* ParseCompoundCommand();
  command::ShFunction* ParseFunctionDef();
  command::ShFunction* ParseKshFunctionDef();
  syntax_asdl::Proc* ParseYshProc();
  syntax_asdl::Func* ParseYshFunc();
  syntax_asdl::command_t* ParseCoproc();
  command::Subshell* ParseSubshell();
  command::DBracket* ParseDBracket();
  command::DParen* ParseDParen();
  syntax_asdl::command_t* ParseCommand();
  syntax_asdl::command_t* ParsePipeline();
  syntax_asdl::command_t* ParseAndOr();
  syntax_asdl::command_t* _ParseAndOr();
  syntax_asdl::command_t* _ParseCommandLine();
  command::CommandList* _ParseCommandTerm();
  command::CommandList* _ParseCommandList();
  syntax_asdl::command_t* ParseLogicalLine();
  syntax_asdl::parse_result_t* ParseInteractiveLine();
  syntax_asdl::command_t* ParseCommandSub();
  void CheckForPendingHereDocs();
  parse_lib::ParseContext* parse_ctx{};
  Dict<BigStr*, BigStr*>* aliases{};
  optview::Parse* parse_opts{};
  word_parse::WordParser* w_parser{};
  lexer::Lexer* lexer{};
  reader::_Reader* line_reader{};
  alloc::Arena* arena{};
  List<Tuple2<BigStr*, int>*>* aliases_in_flight{};
  List<bool>* hay_attrs_stack{};
  cmd_parse::VarChecker* var_checker{};
  syntax_asdl::word_t* cur_word{};
  List<syntax_asdl::Redir*>* pending_here_docs{};
  int eof_id{};
  bool allow_block{};
  types_asdl::cmd_mode_t cmd_mode{};
  types_asdl::lex_mode_t next_lex_mode{};
  id_kind_asdl::Kind_t c_kind{};
  int c_id{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(12, sizeof(CommandParser));
  }

  DISALLOW_COPY_AND_ASSIGN(CommandParser)
};


}  // declare namespace cmd_parse

namespace glob_ {  // declare

bool LooksLikeGlob(BigStr* s);
bool LooksLikeStaticGlob(syntax_asdl::CompoundWord* w);
extern BigStr* GLOB_META_CHARS;
BigStr* GlobEscape(BigStr* s);
extern BigStr* ERE_META_CHARS;
BigStr* ExtendedRegexEscape(BigStr* s);
BigStr* GlobUnescape(BigStr* s);
class _GlobParser {
 public:
  _GlobParser(match::SimpleLexer* lexer);
  void _Next();
  List<syntax_asdl::glob_part_t*>* _ParseCharClass();
  Tuple2<List<syntax_asdl::glob_part_t*>*, List<BigStr*>*> Parse();
  match::SimpleLexer* lexer{};
  BigStr* token_val{};
  List<BigStr*>* warnings{};
  int token_type{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(3, sizeof(_GlobParser));
  }

  DISALLOW_COPY_AND_ASSIGN(_GlobParser)
};

extern BigStr* _REGEX_CHARS_TO_ESCAPE;
BigStr* _GenerateERE(List<syntax_asdl::glob_part_t*>* parts);
Tuple2<BigStr*, List<BigStr*>*> GlobToERE(BigStr* pat);
class Globber {
 public:
  Globber(optview::Exec* exec_opts);
  int _Glob(BigStr* arg, List<BigStr*>* out);
  int Expand(BigStr* arg, List<BigStr*>* out);
  int ExpandExtended(BigStr* glob_pat, BigStr* fnmatch_pat, List<BigStr*>* out);
  optview::Exec* exec_opts{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(Globber));
  }

  DISALLOW_COPY_AND_ASSIGN(Globber)
};


}  // declare namespace glob_

namespace tdop {  // declare

bool IsIndexable(syntax_asdl::arith_expr_t* node);
void CheckLhsExpr(syntax_asdl::arith_expr_t* node, syntax_asdl::word_t* blame_word);
syntax_asdl::arith_expr_t* NullError(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullConstant(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* NullParen(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp);
syntax_asdl::arith_expr_t* NullPrefixOp(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp);
syntax_asdl::arith_expr_t* LeftError(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftBinaryOp(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
syntax_asdl::arith_expr_t* LeftAssign(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp);
class TdopParser {
 public:
  TdopParser(tdop::ParserSpec* spec, word_parse::WordParser* w_parser, optview::Parse* parse_opts);
  int CurrentId();
  bool AtToken(int token_type);
  void Eat(int token_type);
  bool Next();
  syntax_asdl::arith_expr_t* ParseUntil(int rbp);
  syntax_asdl::arith_expr_t* Parse();
  tdop::ParserSpec* spec{};
  word_parse::WordParser* w_parser{};
  optview::Parse* parse_opts{};
  syntax_asdl::word_t* cur_word{};
  int op_id{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(4, sizeof(TdopParser));
  }

  DISALLOW_COPY_AND_ASSIGN(TdopParser)
};


}  // declare namespace tdop

namespace word_ {  // declare

int LiteralId(syntax_asdl::word_part_t* part);
syntax_asdl::Token* CheckLiteralId(syntax_asdl::word_part_t* part, int tok_id);
syntax_asdl::Token* LiteralToken(syntax_asdl::word_t* UP_w);
Tuple3<bool, BigStr*, bool> _EvalWordPart(syntax_asdl::word_part_t* part);
BigStr* FastStrEval(syntax_asdl::CompoundWord* w);
Tuple3<bool, BigStr*, bool> StaticEval(syntax_asdl::word_t* UP_w);
syntax_asdl::CompoundWord* TildeDetect(syntax_asdl::word_t* UP_w);
syntax_asdl::CompoundWord* TildeDetect2(syntax_asdl::CompoundWord* w);
void TildeDetectAssign(syntax_asdl::CompoundWord* w);
List<syntax_asdl::word_t*>* TildeDetectAll(List<syntax_asdl::word_t*>* words);
bool HasArrayPart(syntax_asdl::CompoundWord* w);
BigStr* ShFunctionName(syntax_asdl::CompoundWord* w);
bool IsVarLike(syntax_asdl::CompoundWord* w);
syntax_asdl::Token* LooksLikeArithVar(syntax_asdl::word_t* UP_w);
syntax_asdl::Token* CheckLeadingEquals(syntax_asdl::CompoundWord* w);
Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> DetectShAssignment(syntax_asdl::CompoundWord* w);
syntax_asdl::AssocPair* DetectAssocPair(syntax_asdl::CompoundWord* w);
Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> IsControlFlow(syntax_asdl::CompoundWord* w);
syntax_asdl::Token* BraceToken(syntax_asdl::word_t* UP_w);
syntax_asdl::Token* AsKeywordToken(syntax_asdl::word_t* UP_w);
syntax_asdl::Token* AsOperatorToken(syntax_asdl::word_t* word);
int ArithId(syntax_asdl::word_t* w);
int BoolId(syntax_asdl::word_t* w);
int CommandId(syntax_asdl::word_t* w);
id_kind_asdl::Kind_t CommandKind(syntax_asdl::word_t* w);
bool IsVarSub(syntax_asdl::word_t* w);
syntax_asdl::CompoundWord* ErrorWord(BigStr* error_str);
BigStr* Pretty(syntax_asdl::word_t* w);
class ctx_EmitDocToken {
 public:
  ctx_EmitDocToken(word_parse::WordParser* w_parser);
  ~ctx_EmitDocToken();
  word_parse::WordParser* w_parser{};

  DISALLOW_COPY_AND_ASSIGN(ctx_EmitDocToken)
};

class ctx_Multiline {
 public:
  ctx_Multiline(word_parse::WordParser* w_parser);
  ~ctx_Multiline();
  word_parse::WordParser* w_parser{};

  DISALLOW_COPY_AND_ASSIGN(ctx_Multiline)
};


}  // declare namespace word_

namespace word_compile {  // declare

syntax_asdl::CharCode* EvalCharLiteralForRegex(syntax_asdl::Token* tok);
BigStr* EvalCStringToken(int id_, BigStr* value);
BigStr* EvalSingleQuoted(int id_, List<syntax_asdl::Token*>* tokens);
bool _TokenConsistsOf(syntax_asdl::Token* tok, BigStr* byte_set);
bool _IsLeadingSpace(syntax_asdl::Token* tok);
bool _IsTrailingSpace(syntax_asdl::Token* tok);
void RemoveLeadingSpaceDQ(List<syntax_asdl::word_part_t*>* parts);
void RemoveLeadingSpaceSQ(List<syntax_asdl::Token*>* tokens);

}  // declare namespace word_compile

namespace word_parse {  // declare

extern List<id_kind_asdl::Kind_t>* KINDS_THAT_END_WORDS;
bool _IsValidYshWord(syntax_asdl::CompoundWord* w);
class WordEmitter {
 public:
  WordEmitter();
  virtual syntax_asdl::word_t* ReadWord(types_asdl::lex_mode_t lex_mode);
  
  static constexpr uint32_t field_mask() {
    return kZeroMask;
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(WordEmitter));
  }

  DISALLOW_COPY_AND_ASSIGN(WordEmitter)
};

class WordParser : public ::word_parse::WordEmitter {
 public:
  WordParser(parse_lib::ParseContext* parse_ctx, lexer::Lexer* lexer, reader::_Reader* line_reader);
  void Init(types_asdl::lex_mode_t lex_mode);
  void Reset();
  void _GetToken();
  void _SetNext(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::rhs_word_t* _ReadVarOpArg(types_asdl::lex_mode_t arg_lex_mode);
  syntax_asdl::CompoundWord* _ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type, bool empty_ok);
  suffix_op::Slice* _ReadSliceVarOp();
  suffix_op::PatSub* _ReadPatSubVarOp();
  syntax_asdl::bracket_op_t* _ReadSubscript();
  syntax_asdl::BracedVarSub* _ParseVarOf();
  syntax_asdl::BracedVarSub* _ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode, bool allow_query = false);
  word_part::ZshVarSub* _ReadZshVarSub(syntax_asdl::Token* left_token);
  Tuple2<syntax_asdl::BracedVarSub*, syntax_asdl::Token*> ReadBracedVarSub(syntax_asdl::Token* left_token);
  syntax_asdl::BracedVarSub* _ReadBracedVarSub(syntax_asdl::Token* left_token, bool d_quoted);
  syntax_asdl::SingleQuoted* _ReadSingleQuoted(syntax_asdl::Token* left_token, types_asdl::lex_mode_t lex_mode);
  syntax_asdl::Token* ReadSingleQuoted(types_asdl::lex_mode_t lex_mode, syntax_asdl::Token* left_token, List<syntax_asdl::Token*>* out_tokens, bool is_ysh_expr);
  syntax_asdl::word_part_t* _ReadDoubleQuotedLeftParts();
  syntax_asdl::CompoundWord* _ReadYshSingleQuoted(int left_id);
  syntax_asdl::word_part_t* _ReadUnquotedLeftParts(syntax_asdl::BoolParamBox* triple_out);
  word_part::ExtGlob* _ReadExtGlob();
  word_part::BashRegexGroup* _ReadBashRegexGroup();
  void _ReadLikeDQ(syntax_asdl::Token* left_token, bool is_ysh_expr, List<syntax_asdl::word_part_t*>* out_parts);
  syntax_asdl::DoubleQuoted* _ReadDoubleQuoted(syntax_asdl::Token* left_token);
  syntax_asdl::Token* ReadDoubleQuoted(syntax_asdl::Token* left_token, List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::CommandSub* _ReadCommandSub(int left_id, bool d_quoted = false);
  word_part::ExprSub* _ReadExprSub(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::VarDecl* ParseVarDecl(syntax_asdl::Token* kw_token);
  syntax_asdl::Mutation* ParseMutation(syntax_asdl::Token* kw_token, cmd_parse::VarChecker* var_checker);
  syntax_asdl::expr_t* ParseBareDecl();
  syntax_asdl::expr_t* ParseYshExprForCommand();
  syntax_asdl::expr_t* ParseCommandExpr();
  void ParseProc(syntax_asdl::Proc* node);
  void ParseFunc(syntax_asdl::Func* node);
  Tuple2<syntax_asdl::pat_t*, syntax_asdl::Token*> ParseYshCasePattern();
  int NewlineOkForYshCase();
  syntax_asdl::arith_expr_t* _ReadArithExpr(int end_id);
  word_part::ArithSub* _ReadArithSub();
  Tuple2<syntax_asdl::arith_expr_t*, syntax_asdl::Token*> ReadDParen();
  void _NextNonSpace();
  command::ForExpr* ReadForExpression();
  syntax_asdl::word_part_t* _ReadArrayLiteral();
  syntax_asdl::ArgList* ParseProcCallArgs(int start_symbol);
  bool _MaybeReadWordPart(bool is_first, types_asdl::lex_mode_t lex_mode, List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::CompoundWord* _ReadCompoundWord(types_asdl::lex_mode_t lex_mode);
  syntax_asdl::CompoundWord* _ReadCompoundWord3(types_asdl::lex_mode_t lex_mode, int eof_type, bool empty_ok);
  syntax_asdl::word_t* _ReadArithWord();
  syntax_asdl::word_t* _ReadWord(types_asdl::lex_mode_t word_mode);
  syntax_asdl::BracedVarSub* ParseVarRef();
  int LookPastSpace();
  bool LookAheadFuncParens();
  virtual syntax_asdl::word_t* ReadWord(types_asdl::lex_mode_t word_mode);
  syntax_asdl::word_t* ReadArithWord();
  void ReadHereDocBody(List<syntax_asdl::word_part_t*>* parts);
  syntax_asdl::CompoundWord* ReadForPlugin();
  void EmitDocToken(bool b);
  void Multiline(bool b);

  tdop::TdopParser* a_parser{};
  alloc::Arena* arena{};
  syntax_asdl::word_t* buffered_word{};
  syntax_asdl::Token* cur_token{};
  bool emit_doc_token{};
  lexer::Lexer* lexer{};
  reader::_Reader* line_reader{};
  bool multiline{};
  int newline_state{};
  types_asdl::lex_mode_t next_lex_mode{};
  parse_lib::ParseContext* parse_ctx{};
  optview::Parse* parse_opts{};
  bool returned_newline{};
  id_kind_asdl::Kind_t token_kind{};
  int token_type{};
  
  static constexpr uint32_t field_mask() {
    return ::word_parse::WordEmitter::field_mask()
         | maskbit(offsetof(WordParser, a_parser))
         | maskbit(offsetof(WordParser, arena))
         | maskbit(offsetof(WordParser, buffered_word))
         | maskbit(offsetof(WordParser, cur_token))
         | maskbit(offsetof(WordParser, lexer))
         | maskbit(offsetof(WordParser, line_reader))
         | maskbit(offsetof(WordParser, parse_ctx))
         | maskbit(offsetof(WordParser, parse_opts));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(WordParser));
  }

  DISALLOW_COPY_AND_ASSIGN(WordParser)
};


}  // declare namespace word_parse

namespace parse {  // declare

extern int NT_OFFSET;
class ParseError {
 public:
  ParseError(BigStr* msg, int type_, syntax_asdl::Token* tok);
  BigStr* msg{};
  syntax_asdl::Token* tok{};
  int type{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(ParseError));
  }

  DISALLOW_COPY_AND_ASSIGN(ParseError)
};

class _StackItem {
 public:
  _StackItem(Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* dfa, int state, pnode::PNode* node);
  Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* dfa{};
  pnode::PNode* node{};
  int state{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(_StackItem));
  }

  DISALLOW_COPY_AND_ASSIGN(_StackItem)
};

class Parser {
 public:
  Parser(grammar::Grammar* grammar);
  void setup(int start, pnode::PNodeAllocator* pnode_alloc);
  bool addtoken(int typ, syntax_asdl::Token* opaque, int ilabel);
  void shift(int typ, syntax_asdl::Token* opaque, int newstate);
  void push(int typ, syntax_asdl::Token* opaque, Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* newdfa, int newstate);
  void pop();
  grammar::Grammar* grammar{};
  pnode::PNode* rootnode{};
  List<parse::_StackItem*>* stack{};
  pnode::PNodeAllocator* pnode_alloc{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(4, sizeof(Parser));
  }

  DISALLOW_COPY_AND_ASSIGN(Parser)
};


}  // declare namespace parse

namespace os_path {  // declare

extern BigStr* extsep;
extern BigStr* sep;
BigStr* join(BigStr* s1, BigStr* s2);
Tuple2<BigStr*, BigStr*> split(BigStr* p);
Tuple2<BigStr*, BigStr*> _splitext(BigStr* p, BigStr* sep, BigStr* extsep);
Tuple2<BigStr*, BigStr*> splitext(BigStr* p);
BigStr* basename(BigStr* p);
BigStr* dirname(BigStr* p);
BigStr* normpath(BigStr* path);
bool isabs(BigStr* s);
BigStr* abspath(BigStr* path);

}  // declare namespace os_path

namespace expr_parse {  // declare

int _Classify(grammar::Grammar* gr, syntax_asdl::Token* tok);
extern Dict<int, int>* _OTHER_BALANCE;
syntax_asdl::Token* _PushYshTokens(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, parse::Parser* p, lexer::Lexer* lex);
class ExprParser {
 public:
  ExprParser(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr);
  Tuple2<pnode::PNode*, syntax_asdl::Token*> Parse(lexer::Lexer* lexer, int start_symbol);
  parse_lib::ParseContext* parse_ctx{};
  grammar::Grammar* gr{};
  parse::Parser* push_parser{};
  pnode::PNodeAllocator* pnode_alloc{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(4, sizeof(ExprParser));
  }

  DISALLOW_COPY_AND_ASSIGN(ExprParser)
};

class ctx_PNodeAllocator {
 public:
  ctx_PNodeAllocator(expr_parse::ExprParser* ep);
  ~ctx_PNodeAllocator();
  expr_parse::ExprParser* expr_parser{};

  DISALLOW_COPY_AND_ASSIGN(ctx_PNodeAllocator)
};


}  // declare namespace expr_parse

namespace expr_to_ast {  // declare

extern Dict<BigStr*, BigStr*>* PERL_CLASSES;
extern List<BigStr*>* POSIX_CLASSES;
extern BigStr* RANGE_POINT_TOO_LONG;
extern BigStr* POS_ARG_MISPLACED;
extern int NT_OFFSET;
class Transformer {
 public:
  Transformer(grammar::Grammar* gr);
  syntax_asdl::expr_t* _LeftAssoc(pnode::PNode* p_node);
  syntax_asdl::expr_t* _Trailer(syntax_asdl::expr_t* base, pnode::PNode* p_trailer);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> _DictPair(pnode::PNode* p_node);
  expr::Dict* _Dict(pnode::PNode* parent, pnode::PNode* p_node);
  syntax_asdl::expr_t* _Tuple(pnode::PNode* parent);
  syntax_asdl::expr_t* _TestlistComp(pnode::PNode* parent, pnode::PNode* p_node, int id0);
  syntax_asdl::expr_t* _Atom(pnode::PNode* parent);
  syntax_asdl::NameType* _NameType(pnode::PNode* p_node);
  List<syntax_asdl::NameType*>* _NameTypeList(pnode::PNode* p_node);
  syntax_asdl::Comprehension* _CompFor(pnode::PNode* p_node);
  syntax_asdl::expr_t* _CompareChain(pnode::PNode* parent);
  syntax_asdl::expr_t* _Subscript(pnode::PNode* parent);
  syntax_asdl::expr_t* Expr(pnode::PNode* pnode);
  void _CheckLhs(syntax_asdl::expr_t* lhs);
  List<syntax_asdl::y_lhs_t*>* _LhsExprList(pnode::PNode* p_node);
  syntax_asdl::VarDecl* MakeVarDecl(pnode::PNode* p_node);
  syntax_asdl::Mutation* MakeMutation(pnode::PNode* p_node);
  syntax_asdl::EggexFlag* _EggexFlag(pnode::PNode* p_node);
  syntax_asdl::Eggex* _Eggex(pnode::PNode* p_node);
  syntax_asdl::pat_t* YshCasePattern(pnode::PNode* pnode);
  syntax_asdl::expr_t* _BlockArg(pnode::PNode* p_node);
  void _Argument(pnode::PNode* p_node, bool after_semi, syntax_asdl::ArgList* arglist);
  void _ArgGroup(pnode::PNode* p_node, bool after_semi, syntax_asdl::ArgList* arglist);
  void _ArgList(pnode::PNode* p_node, syntax_asdl::ArgList* arglist);
  void ProcCallArgs(pnode::PNode* pnode, syntax_asdl::ArgList* arglist);
  syntax_asdl::TypeExpr* _TypeExpr(pnode::PNode* pnode);
  syntax_asdl::Param* _Param(pnode::PNode* pnode);
  syntax_asdl::ParamGroup* _ParamGroup(pnode::PNode* p_node);
  syntax_asdl::proc_sig_t* Proc(pnode::PNode* p_node);
  void YshFunc(pnode::PNode* p_node, syntax_asdl::Func* out);
  syntax_asdl::CharCode* _RangeCharSingleQuoted(pnode::PNode* p_node);
  syntax_asdl::Token* _OtherRangeToken(pnode::PNode* p_node);
  syntax_asdl::class_literal_term_t* _NonRangeChars(pnode::PNode* p_node);
  syntax_asdl::class_literal_term_t* _ClassLiteralTerm(pnode::PNode* p_node);
  List<syntax_asdl::class_literal_term_t*>* _ClassLiteral(pnode::PNode* p_node);
  syntax_asdl::re_t* _NameInRegex(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok);
  syntax_asdl::class_literal_term_t* _NameInClass(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok);
  syntax_asdl::re_t* _ReAtom(pnode::PNode* p_atom);
  syntax_asdl::re_repeat_t* _RepeatOp(pnode::PNode* p_repeat);
  syntax_asdl::re_t* _ReAlt(pnode::PNode* p_node);
  syntax_asdl::re_t* _Regex(pnode::PNode* p_node);
  Dict<int, BigStr*>* number2symbol{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(Transformer));
  }

  DISALLOW_COPY_AND_ASSIGN(Transformer)
};


}  // declare namespace expr_to_ast

namespace regex_translate {  // declare

extern Dict<BigStr*, BigStr*>* PERL_CLASS;
extern int CH_RBRACKET;
extern int CH_BACKSLASH;
extern int CH_CARET;
extern int CH_HYPHEN;
extern int FLAG_RBRACKET;
extern int FLAG_BACKSLASH;
extern int FLAG_CARET;
extern int FLAG_HYPHEN;
void _CharCodeToEre(syntax_asdl::CharCode* term, List<BigStr*>* parts, List<int>* special_char_flags);
void _CharClassTermToEre(syntax_asdl::char_class_term_t* term, List<BigStr*>* parts, List<int>* special_char_flags);
void _AsPosixEre(syntax_asdl::re_t* node, List<BigStr*>* parts, List<BigStr*>* capture_names);
BigStr* AsPosixEre(value::Eggex* eggex);
BigStr* CanonicalFlags(List<syntax_asdl::EggexFlag*>* flags);
int LibcFlags(BigStr* canonical_flags);

}  // declare namespace regex_translate

namespace runtime {  // define

using hnode_asdl::hnode;
using hnode_asdl::color_t;
using hnode_asdl::color_e;
int NO_SPID = -1;

hnode::Record* NewRecord(BigStr* node_type) {
  StackRoot _root0(&node_type);

  return Alloc<hnode::Record>(node_type, S_ijB, S_hxb, Alloc<List<hnode_asdl::Field*>>(), nullptr);
}

hnode::Leaf* NewLeaf(BigStr* s, hnode_asdl::color_t e_color) {
  StackRoot _root0(&s);

  if (s == nullptr) {
    return Alloc<hnode::Leaf>(S_tci, color_e::OtherConst);
  }
  else {
    return Alloc<hnode::Leaf>(s, e_color);
  }
}

TraversalState::TraversalState() {
  this->seen = Alloc<Dict<int, bool>>();
  this->ref_count = Alloc<Dict<int, int>>();
}
BigStr* TRUE_STR = S_cor;
BigStr* FALSE_STR = S_gFh;

}  // define namespace runtime

namespace vm {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using runtime_asdl::CommandStatus;
using runtime_asdl::StatusArray;
using runtime_asdl::flow_e;
using runtime_asdl::flow_t;
using syntax_asdl::Token;
using syntax_asdl::loc;
using syntax_asdl::loc_t;
using value_asdl::value;
using value_asdl::value_e;
using value_asdl::value_t;
using value_asdl::Obj;
using error::e_die;

IntControlFlow::IntControlFlow(int keyword_id, BigStr* keyword_str, syntax_asdl::loc_t* keyword_loc, int arg) {
  this->keyword_id = keyword_id;
  this->keyword_str = keyword_str;
  this->keyword_loc = keyword_loc;
  this->arg = arg;
}

BigStr* IntControlFlow::Keyword() {
  return this->keyword_str;
}

syntax_asdl::loc_t* IntControlFlow::Location() {
  return this->keyword_loc;
}

bool IntControlFlow::IsReturn() {
  return this->keyword_id == Id::ControlFlow_Return;
}

bool IntControlFlow::IsBreak() {
  return this->keyword_id == Id::ControlFlow_Break;
}

bool IntControlFlow::IsContinue() {
  return this->keyword_id == Id::ControlFlow_Continue;
}

int IntControlFlow::StatusCode() {
  return (this->arg & 255);
}

runtime_asdl::flow_t IntControlFlow::HandleLoop() {
  if (this->IsBreak()) {
    this->arg -= 1;
    if (this->arg == 0) {
      return flow_e::Break;
    }
  }
  else {
    if (this->IsContinue()) {
      this->arg -= 1;
      if (this->arg == 0) {
        return flow_e::Nothing;
      }
    }
  }
  return flow_e::Raise;
}

ValueControlFlow::ValueControlFlow(syntax_asdl::Token* token, value_asdl::value_t* value) {
  this->token = token;
  this->value = value;
}

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith) {
  StackRoot _root0(&mem);
  StackRoot _root1(&word_ev);
  StackRoot _root2(&unsafe_arith);

  mem->unsafe_arith = unsafe_arith;
  word_ev->unsafe_arith = unsafe_arith;
}

void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::ExprEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, vm::_Executor* pure_ex, prompt::Evaluator* prompt_ev, value_asdl::Obj* global_io, dev::Tracer* tracer) {
  StackRoot _root0(&arith_ev);
  StackRoot _root1(&bool_ev);
  StackRoot _root2(&expr_ev);
  StackRoot _root3(&word_ev);
  StackRoot _root4(&cmd_ev);
  StackRoot _root5(&shell_ex);
  StackRoot _root6(&pure_ex);
  StackRoot _root7(&prompt_ev);
  StackRoot _root8(&global_io);
  StackRoot _root9(&tracer);

  arith_ev->word_ev = word_ev;
  bool_ev->word_ev = word_ev;
  if (expr_ev) {
    expr_ev->shell_ex = shell_ex;
    expr_ev->cmd_ev = cmd_ev;
    expr_ev->word_ev = word_ev;
  }
  word_ev->arith_ev = arith_ev;
  word_ev->expr_ev = expr_ev;
  word_ev->prompt_ev = prompt_ev;
  word_ev->shell_ex = shell_ex;
  cmd_ev->shell_ex = shell_ex;
  cmd_ev->arith_ev = arith_ev;
  cmd_ev->bool_ev = bool_ev;
  cmd_ev->expr_ev = expr_ev;
  cmd_ev->word_ev = word_ev;
  cmd_ev->tracer = tracer;
  shell_ex->cmd_ev = cmd_ev;
  pure_ex->cmd_ev = cmd_ev;
  prompt_ev->word_ev = word_ev;
  prompt_ev->expr_ev = expr_ev;
  prompt_ev->global_io = global_io;
  tracer->word_ev = word_ev;
  arith_ev->CheckCircularDeps();
  bool_ev->CheckCircularDeps();
  if (expr_ev) {
    expr_ev->CheckCircularDeps();
  }
  word_ev->CheckCircularDeps();
  cmd_ev->CheckCircularDeps();
  shell_ex->CheckCircularDeps();
  pure_ex->CheckCircularDeps();
  prompt_ev->CheckCircularDeps();
  tracer->CheckCircularDeps();
}

_Executor::_Executor(state::Mem* mem, optview::Exec* exec_opts, state::MutableOpts* mutable_opts, state::Procs* procs, hay_ysh::HayState* hay_state, Dict<int, vm::_Builtin*>* builtins, dev::Tracer* tracer, ui::ErrorFormatter* errfmt) {
  this->mem = mem;
  this->exec_opts = exec_opts;
  this->mutable_opts = mutable_opts;
  this->procs = procs;
  this->hay_state = hay_state;
  this->builtins = builtins;
  this->tracer = tracer;
  this->errfmt = errfmt;
  this->cmd_ev = nullptr;
}

void _Executor::CheckCircularDeps() {
}

int _Executor::RunSimpleCommand(cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, int run_flags) {
  syntax_asdl::loc_t* arg0_loc = nullptr;
  List<BigStr*>* argv = nullptr;
  StackRoot _root0(&cmd_val);
  StackRoot _root1(&cmd_st);
  StackRoot _root2(&arg0_loc);
  StackRoot _root3(&argv);

  if (len(cmd_val->arg_locs)) {
    arg0_loc = cmd_val->arg_locs->at(0);
  }
  else {
    arg0_loc = loc::Missing;
  }
  argv = cmd_val->argv;
  if (len(argv) == 0) {
    if (this->exec_opts->strict_argv()) {
      e_die(S_Awe, arg0_loc);
    }
    else {
      return 0;
    }
  }
  return this->_RunSimpleCommand(argv->at(0), arg0_loc, cmd_val, cmd_st, run_flags);
}

int _Executor::_RunSimpleCommand(BigStr* arg0, syntax_asdl::loc_t* arg0_loc, cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, int run_flags) {
  StackRoot _root0(&arg0);
  StackRoot _root1(&arg0_loc);
  StackRoot _root2(&cmd_val);
  StackRoot _root3(&cmd_st);

  FAIL(kNotImplemented);  // Python NotImplementedError
}

int _Executor::RunBuiltin(int builtin_id, cmd_value::Argv* cmd_val) {
  vm::_Builtin* builtin_proc = nullptr;
  StackRoot _root0(&cmd_val);
  StackRoot _root1(&builtin_proc);

  this->tracer->OnBuiltin(builtin_id, cmd_val->argv);
  builtin_proc = this->builtins->at(builtin_id);
  return this->_RunBuiltinProc(builtin_proc, cmd_val);
}

int _Executor::_RunBuiltinProc(vm::_Builtin* builtin_proc, cmd_value::Argv* cmd_val) {
  List<IOError_OSError*>* io_errors = nullptr;
  int status;
  BigStr* arg0 = nullptr;
  StackRoot _root0(&builtin_proc);
  StackRoot _root1(&cmd_val);
  StackRoot _root2(&io_errors);
  StackRoot _root3(&arg0);

  io_errors = Alloc<List<IOError_OSError*>>();
  {  // with
    ctx_FlushStdout ctx{io_errors};

    {  // with
      ui::ctx_Location ctx{this->errfmt, cmd_val->arg_locs->at(0)};

      try {
        status = builtin_proc->Run(cmd_val);
      }
      catch (IOError_OSError* e) {
        this->errfmt->PrintMessage(StrFormat("%s builtin I/O error: %s", cmd_val->argv->at(0), pyutil::strerror(e)), cmd_val->arg_locs->at(0));
        return 1;
      }
      catch (error::Usage* e) {
        arg0 = cmd_val->argv->at(0);
        this->errfmt->PrefixPrint(e->msg, StrFormat("%r ", arg0), e->location);
        return 2;
      }
    }
  }
  if (len(io_errors)) {
    this->errfmt->PrintMessage(StrFormat("%s builtin I/O error: %s", cmd_val->argv->at(0), pyutil::strerror(io_errors->at(0))), cmd_val->arg_locs->at(0));
    return 1;
  }
  return status;
}

int _Executor::_RunInvokable(value_asdl::value_t* proc_val, value_asdl::Obj* self_obj, syntax_asdl::loc_t* arg0_loc, cmd_value::Argv* cmd_val) {
  syntax_asdl::Token* disabled_tok = nullptr;
  value::BuiltinProc* builtin_proc = nullptr;
  vm::_Builtin* b = nullptr;
  int status;
  value::Proc* proc = nullptr;
  StackRoot _root0(&proc_val);
  StackRoot _root1(&self_obj);
  StackRoot _root2(&arg0_loc);
  StackRoot _root3(&cmd_val);
  StackRoot _root4(&disabled_tok);
  StackRoot _root5(&builtin_proc);
  StackRoot _root6(&b);
  StackRoot _root7(&proc);

  cmd_val->self_obj = self_obj;
  if (this->exec_opts->strict_errexit()) {
    disabled_tok = this->mutable_opts->ErrExitDisabledToken();
    if (disabled_tok) {
      this->errfmt->Print_(S_uFo, disabled_tok);
      this->errfmt->StderrLine(S_Aoo);
      e_die(S_qkr, arg0_loc);
    }
  }
  switch (proc_val->tag()) {
    case value_e::BuiltinProc: {
      builtin_proc = static_cast<value::BuiltinProc*>(proc_val);
      b = static_cast<_Builtin*>(builtin_proc->builtin);
      status = this->_RunBuiltinProc(b, cmd_val);
    }
      break;
    case value_e::Proc: {
      proc = static_cast<value::Proc*>(proc_val);
      {  // with
        dev::ctx_Tracer ctx{this->tracer, S_aFi, cmd_val->argv};

        status = this->cmd_ev->RunProc(proc, cmd_val);
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return status;
}

int _Executor::RunBackgroundJob(syntax_asdl::command_t* node) {
  StackRoot _root0(&node);

  return 0;
}

void _Executor::RunPipeline(command::Pipeline* node, runtime_asdl::CommandStatus* status_out) {
  StackRoot _root0(&node);
  StackRoot _root1(&status_out);

  ;  // pass
}

int _Executor::RunSubshell(syntax_asdl::command_t* node) {
  StackRoot _root0(&node);

  return 0;
}

Tuple2<int, BigStr*> _Executor::CaptureStdout(syntax_asdl::command_t* node) {
  StackRoot _root0(&node);

  return Tuple2<int, BigStr*>(0, S_Aoo);
}

Tuple3<int, BigStr*, BigStr*> _Executor::Capture3(syntax_asdl::command_t* node) {
  StackRoot _root0(&node);

  return Tuple3<int, BigStr*, BigStr*>(0, S_Aoo, S_Aoo);
}

BigStr* _Executor::RunCommandSub(syntax_asdl::CommandSub* cs_part) {
  StackRoot _root0(&cs_part);

  return S_Aoo;
}

BigStr* _Executor::RunProcessSub(syntax_asdl::CommandSub* cs_part) {
  StackRoot _root0(&cs_part);

  return S_Aoo;
}

void _Executor::PushRedirects(List<runtime_asdl::RedirValue*>* redirects, List<IOError_OSError*>* err_out) {
  StackRoot _root0(&redirects);
  StackRoot _root1(&err_out);

  ;  // pass
}

void _Executor::PopRedirects(int num_redirects, List<IOError_OSError*>* err_out) {
  StackRoot _root0(&err_out);

  ;  // pass
}

void _Executor::PushProcessSub() {
  ;  // pass
}

void _Executor::PopProcessSub(runtime_asdl::StatusArray* compound_st) {
  StackRoot _root0(&compound_st);

  ;  // pass
}

_AssignBuiltin::_AssignBuiltin() {
  ;  // pass
}

int _AssignBuiltin::Run(cmd_value::Assign* cmd_val) {
  StackRoot _root0(&cmd_val);

  FAIL(kNotImplemented);  // Python NotImplementedError
}

_Builtin::_Builtin() {
  ;  // pass
}

int _Builtin::Run(cmd_value::Argv* cmd_val) {
  StackRoot _root0(&cmd_val);

  FAIL(kNotImplemented);  // Python NotImplementedError
}

_Callable::_Callable() {
  ;  // pass
}

value_asdl::value_t* _Callable::Call(typed_args::Reader* args) {
  StackRoot _root0(&args);

  FAIL(kNotImplemented);  // Python NotImplementedError
}

ctx_MaybePure::ctx_MaybePure(vm::_Executor* pure_ex, cmd_eval::CommandEvaluator* cmd_ev) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->cmd_ev)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->pure_ex)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->saved)));
  this->pure_ex = pure_ex;
  if (!pure_ex) {
    return ;
  }
  word_eval::NormalWordEvaluator* word_ev = cmd_ev->word_ev;
  expr_eval::ExprEvaluator* expr_ev = cmd_ev->expr_ev;
  this->saved = cmd_ev->shell_ex;
  cmd_ev->shell_ex = pure_ex;
  word_ev->shell_ex = pure_ex;
  expr_ev->shell_ex = pure_ex;
  this->cmd_ev = cmd_ev;
}

void ctx_MaybePure::ctx_EXIT() {
  if (!this->pure_ex) {
    return ;
  }
  this->cmd_ev->shell_ex = this->saved;
  this->cmd_ev->word_ev->shell_ex = this->saved;
  this->cmd_ev->expr_ev->shell_ex = this->saved;
}

ctx_MaybePure::~ctx_MaybePure() {
  ctx_EXIT();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_Redirect::ctx_Redirect(vm::_Executor* shell_ex, int num_redirects, List<IOError_OSError*>* err_out) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->err_out)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->shell_ex)));
  this->shell_ex = shell_ex;
  this->num_redirects = num_redirects;
  this->err_out = err_out;
}

ctx_Redirect::~ctx_Redirect() {
  this->shell_ex->PopRedirects(this->num_redirects, this->err_out);
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_ProcessSub::ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->process_sub_status)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->shell_ex)));
  shell_ex->PushProcessSub();
  this->shell_ex = shell_ex;
  this->process_sub_status = process_sub_status;
}

ctx_ProcessSub::~ctx_ProcessSub() {
  this->shell_ex->PopProcessSub(this->process_sub_status);
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_FlushStdout::ctx_FlushStdout(List<IOError_OSError*>* err_out) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->err_out)));
  this->err_out = err_out;
}

ctx_FlushStdout::~ctx_FlushStdout() {
  IOError_OSError* err = pyos::FlushStdout();
  if (err != nullptr) {
    this->err_out->append(err);
  }
  gHeap.PopRoot();
}

}  // define namespace vm

namespace format {  // define

using hnode_asdl::hnode;
using hnode_asdl::hnode_e;
using hnode_asdl::hnode_t;
using pretty_asdl::doc;
using pretty_asdl::doc_e;
using pretty_asdl::doc_t;
using pretty_asdl::MeasuredDoc;
using pretty_asdl::List_Measured;

int _HNodeCount(hnode_asdl::hnode_t* h) {
  hnode_asdl::hnode_t* UP_h = nullptr;
  int n;
  StackRoot _root0(&h);
  StackRoot _root1(&UP_h);

  UP_h = h;
  switch (h->tag()) {
    case hnode_e::AlreadySeen: {
      return 1;
    }
      break;
    case hnode_e::Leaf: {
      return 1;
    }
      break;
    case hnode_e::Array: {
      hnode::Array* h = static_cast<hnode::Array*>(UP_h);
      n = 1;
      for (ListIter<hnode_asdl::hnode_t*> it(h->children); !it.Done(); it.Next()) {
        hnode_asdl::hnode_t* child = it.Value();
        StackRoot _for(&child      );
        n += _HNodeCount(child);
      }
      return n;
    }
      break;
    case hnode_e::Record: {
      hnode::Record* h = static_cast<hnode::Record*>(UP_h);
      n = 1;
      for (ListIter<hnode_asdl::Field*> it(h->fields); !it.Done(); it.Next()) {
        hnode_asdl::Field* field = it.Value();
        StackRoot _for(&field      );
        n += _HNodeCount(field->val);
      }
      if (h->unnamed_fields != nullptr) {
        for (ListIter<hnode_asdl::hnode_t*> it(h->unnamed_fields); !it.Done(); it.Next()) {
          hnode_asdl::hnode_t* child = it.Value();
          StackRoot _for(&child        );
          n += _HNodeCount(child);
        }
      }
      return n;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

int _DocCount(pretty_asdl::doc_t* d) {
  pretty_asdl::doc_t* UP_d = nullptr;
  int n;
  StackRoot _root0(&d);
  StackRoot _root1(&UP_d);

  UP_d = d;
  switch (d->tag()) {
    case doc_e::Break: {
      return 1;
    }
      break;
    case doc_e::Text: {
      return 1;
    }
      break;
    case doc_e::Indent: {
      doc::Indent* d = static_cast<doc::Indent*>(UP_d);
      return (1 + _DocCount(d->mdoc->doc));
    }
      break;
    case doc_e::Group: {
      MeasuredDoc* d = static_cast<MeasuredDoc*>(UP_d);
      return (1 + _DocCount(d->doc));
    }
      break;
    case doc_e::Flat: {
      doc::Flat* d = static_cast<doc::Flat*>(UP_d);
      return (1 + _DocCount(d->mdoc->doc));
    }
      break;
    case doc_e::IfFlat: {
      doc::IfFlat* d = static_cast<doc::IfFlat*>(UP_d);
      return ((1 + _DocCount(d->flat_mdoc->doc)) + _DocCount(d->nonflat_mdoc->doc));
    }
      break;
    case doc_e::Concat: {
      List_Measured* d = static_cast<List_Measured*>(UP_d);
      n = 1;
      for (ListIter<pretty_asdl::MeasuredDoc*> it(d); !it.Done(); it.Next()) {
        pretty_asdl::MeasuredDoc* mdoc = it.Value();
        StackRoot _for(&mdoc      );
        n += _DocCount(mdoc->doc);
      }
      return n;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void _HNodePrettyPrint(bool perf_stats, bool doc_debug, hnode_asdl::hnode_t* node, mylib::Writer* f, int max_width) {
  pp_hnode::HNodeEncoder* enc = nullptr;
  pretty_asdl::MeasuredDoc* d = nullptr;
  hnode_asdl::hnode_t* p = nullptr;
  pretty::PrettyPrinter* printer = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&f);
  StackRoot _root2(&enc);
  StackRoot _root3(&d);
  StackRoot _root4(&p);
  StackRoot _root5(&printer);
  StackRoot _root6(&buf);

  mylib::MaybeCollect();
  if (perf_stats) {
    mylib::print_stderr(StrFormat("___ HNODE COUNT %d", _HNodeCount(node)));
    mylib::print_stderr(S_Aoo);
  }
  enc = Alloc<pp_hnode::HNodeEncoder>();
  enc->SetUseStyles(f->isatty());
  enc->SetIndent(2);
  d = enc->HNode(node);
  mylib::MaybeCollect();
  if (perf_stats) {
    if (doc_debug) {
      p = d->PrettyTree(false);
      _HNodePrettyPrint(perf_stats, false, p, f);
    }
    mylib::print_stderr(StrFormat("___ DOC COUNT %d", _DocCount(d)));
    mylib::print_stderr(S_Aoo);
  }
  printer = Alloc<pretty::PrettyPrinter>(max_width);
  buf = Alloc<mylib::BufWriter>();
  printer->PrintDoc(d, buf);
  f->write(buf->getvalue());
  f->write(S_nfs);
  mylib::MaybeCollect();
  if (perf_stats) {
    mylib::print_stderr(S_gfw);
    mylib::PrintGcStats();
    mylib::print_stderr(S_Aoo);
  }
}

void HNodePrettyPrint(hnode_asdl::hnode_t* node, mylib::Writer* f, int max_width) {
  StackRoot _root0(&node);
  StackRoot _root1(&f);

  _HNodePrettyPrint(false, true, node, f, max_width);
}

}  // define namespace format

namespace osh_parse {  // define

using option_asdl::option_i;
using syntax_asdl::source;
using syntax_asdl::source_t;
using syntax_asdl::command;
using syntax_asdl::command_t;
namespace fmt = format;

syntax_asdl::command_t* ParseWholeFile(cmd_parse::CommandParser* c_parser) {
  List<syntax_asdl::command_t*>* children = nullptr;
  syntax_asdl::command_t* node = nullptr;
  StackRoot _root0(&c_parser);
  StackRoot _root1(&children);
  StackRoot _root2(&node);

  children = Alloc<List<syntax_asdl::command_t*>>();
  while (true) {
    node = c_parser->ParseLogicalLine();
    if (node == nullptr) {
      c_parser->CheckForPendingHereDocs();
      break;
    }
    children->append(node);
  }
  if (len(children) == 1) {
    return children->at(0);
  }
  else {
    return Alloc<command::CommandList>(children);
  }
}

int main(List<BigStr*>* argv) {
  alloc::Arena* arena = nullptr;
  ui::ErrorFormatter* errfmt = nullptr;
  List<bool>* opt0_array = nullptr;
  List<bool>* no_stack = nullptr;
  List<List<bool>*>* opt_stacks = nullptr;
  optview::Parse* parse_opts = nullptr;
  Dict<BigStr*, BigStr*>* aliases = nullptr;
  grammar::Grammar* ysh_grammar = nullptr;
  parse_lib::ParseContext* parse_ctx = nullptr;
  bool pretty_print;
  reader::FileLineReader* line_reader = nullptr;
  syntax_asdl::source_t* src = nullptr;
  BigStr* path = nullptr;
  mylib::LineReader* f = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::command_t* node = nullptr;
  hnode_asdl::hnode_t* tree = nullptr;
  StackRoot _root0(&argv);
  StackRoot _root1(&arena);
  StackRoot _root2(&errfmt);
  StackRoot _root3(&opt0_array);
  StackRoot _root4(&no_stack);
  StackRoot _root5(&opt_stacks);
  StackRoot _root6(&parse_opts);
  StackRoot _root7(&aliases);
  StackRoot _root8(&ysh_grammar);
  StackRoot _root9(&parse_ctx);
  StackRoot _root10(&line_reader);
  StackRoot _root11(&src);
  StackRoot _root12(&path);
  StackRoot _root13(&f);
  StackRoot _root14(&c_parser);
  StackRoot _root15(&node);
  StackRoot _root16(&tree);

  arena = Alloc<alloc::Arena>();
  errfmt = Alloc<ui::ErrorFormatter>();
  opt0_array = state::InitOpts();
  no_stack = nullptr;
  opt_stacks = list_repeat(no_stack, option_i::ARRAY_SIZE);
  parse_opts = Alloc<optview::Parse>(opt0_array, opt_stacks);
  aliases = Alloc<Dict<BigStr*, BigStr*>>();
  ysh_grammar = nullptr;
  parse_ctx = Alloc<parse_lib::ParseContext>(arena, parse_opts, aliases, ysh_grammar);
  pretty_print = true;
  if (len(argv) == 1) {
    line_reader = Alloc<reader::FileLineReader>(mylib::Stdin(), arena);
    src = Alloc<source::Stdin>(S_Aoo);
  }
  else {
    if (len(argv) == 2) {
      path = argv->at(1);
      f = mylib::open(path);
      line_reader = Alloc<reader::FileLineReader>(f, arena);
      src = Alloc<source::MainFile>(path);
    }
    else {
      if (len(argv) == 3) {
        if (str_equals(argv->at(1), S_DEp)) {
          line_reader = reader::StringLineReader(argv->at(2), arena);
          src = source::CFlag;
        }
        else {
          if (str_equals(argv->at(1), S_ygA)) {
            path = argv->at(2);
            f = mylib::open(path);
            line_reader = Alloc<reader::FileLineReader>(f, arena);
            src = Alloc<source::MainFile>(path);
            pretty_print = false;
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  arena->PushSource(src);
  c_parser = parse_ctx->MakeOshParser(line_reader);
  try {
    node = ParseWholeFile(c_parser);
  }
  catch (error::Parse* e) {
    errfmt->PrettyPrintError(e);
    return 2;
  }
  if (pretty_print) {
    tree = node->PrettyTree(true);
    fmt::HNodePrettyPrint(tree, mylib::Stdout());
  }
  return 0;
}

}  // define namespace osh_parse

namespace alloc {  // define

using syntax_asdl::source_t;
using syntax_asdl::Token;
using syntax_asdl::SourceLine;
using syntax_asdl::loc;

BigStr* SnipCodeBlock(syntax_asdl::Token* left, syntax_asdl::Token* right, List<syntax_asdl::SourceLine*>* lines) {
  List<BigStr*>* pieces = nullptr;
  BigStr* piece = nullptr;
  bool saving;
  bool found_left;
  bool found_right;
  StackRoot _root0(&left);
  StackRoot _root1(&right);
  StackRoot _root2(&lines);
  StackRoot _root3(&pieces);
  StackRoot _root4(&piece);

  pieces = Alloc<List<BigStr*>>();
  pieces->append(str_repeat(S_yfw, (left->col + 1)));
  if (left->line == right->line) {
    for (ListIter<syntax_asdl::SourceLine*> it(lines); !it.Done(); it.Next()) {
      syntax_asdl::SourceLine* li = it.Value();
      StackRoot _for(&li    );
      if (li == left->line) {
        piece = li->content->slice((left->col + left->length), right->col);
        pieces->append(piece);
      }
    }
    return S_Aoo->join(pieces);
  }
  saving = false;
  found_left = false;
  found_right = false;
  for (ListIter<syntax_asdl::SourceLine*> it(lines); !it.Done(); it.Next()) {
    syntax_asdl::SourceLine* li = it.Value();
    StackRoot _for(&li  );
    if (li == left->line) {
      found_left = true;
      saving = true;
      piece = li->content->slice((left->col + left->length));
      pieces->append(piece);
      continue;
    }
    if (li == right->line) {
      found_right = true;
      piece = li->content->slice(0, right->col);
      pieces->append(piece);
      saving = false;
      break;
    }
    if (saving) {
      pieces->append(li->content);
    }
  }
  return S_Aoo->join(pieces);
}

ctx_SourceCode::ctx_SourceCode(alloc::Arena* arena, syntax_asdl::source_t* src) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->arena)));
  arena->PushSource(src);
  this->arena = arena;
}

ctx_SourceCode::~ctx_SourceCode() {
  this->arena->PopSource();
  gHeap.PopRoot();
}

Arena::Arena(bool save_tokens) {
  this->save_tokens = save_tokens;
  this->tokens = Alloc<List<syntax_asdl::Token*>>();
  this->num_tokens = 0;
  this->span_id_lookup = Alloc<Dict<syntax_asdl::Token*, int>>();
  this->lines_list = Alloc<List<syntax_asdl::SourceLine*>>();
  this->source_instances = Alloc<List<syntax_asdl::source_t*>>();
}

void Arena::SaveTokens() {
  this->save_tokens = true;
}

void Arena::PushSource(syntax_asdl::source_t* src) {
  StackRoot _root0(&src);

  this->source_instances->append(src);
}

void Arena::PopSource() {
  this->source_instances->pop();
}

syntax_asdl::SourceLine* Arena::AddLine(BigStr* line, int line_num) {
  syntax_asdl::SourceLine* src_line = nullptr;
  StackRoot _root0(&line);
  StackRoot _root1(&src_line);

  src_line = Alloc<SourceLine>(line_num, line, this->source_instances->at(-1));
  this->lines_list->append(src_line);
  return src_line;
}

void Arena::DiscardLines() {
  this->lines_list->clear();
}

List<syntax_asdl::SourceLine*>* Arena::SaveLinesAndDiscard(syntax_asdl::Token* left, syntax_asdl::Token* right) {
  List<syntax_asdl::SourceLine*>* saved = nullptr;
  bool saving;
  StackRoot _root0(&left);
  StackRoot _root1(&right);
  StackRoot _root2(&saved);

  saved = Alloc<List<syntax_asdl::SourceLine*>>();
  saving = false;
  for (ListIter<syntax_asdl::SourceLine*> it(this->lines_list); !it.Done(); it.Next()) {
    syntax_asdl::SourceLine* li = it.Value();
    StackRoot _for(&li  );
    if (li == left->line) {
      saving = true;
    }
    if (saving) {
      saved->append(li);
    }
    if (li == right->line) {
      saving = false;
      break;
    }
  }
  this->DiscardLines();
  return saved;
}

BigStr* Arena::SnipCodeString(syntax_asdl::Token* left, syntax_asdl::Token* right) {
  BigStr* piece = nullptr;
  List<BigStr*>* pieces = nullptr;
  bool saving;
  bool found_left;
  bool found_right;
  StackRoot _root0(&left);
  StackRoot _root1(&right);
  StackRoot _root2(&piece);
  StackRoot _root3(&pieces);

  if (left->line == right->line) {
    for (ListIter<syntax_asdl::SourceLine*> it(this->lines_list); !it.Done(); it.Next()) {
      syntax_asdl::SourceLine* li = it.Value();
      StackRoot _for(&li    );
      if (li == left->line) {
        piece = li->content->slice(left->col, (right->col + right->length));
        return piece;
      }
    }
  }
  pieces = Alloc<List<BigStr*>>();
  saving = false;
  found_left = false;
  found_right = false;
  for (ListIter<syntax_asdl::SourceLine*> it(this->lines_list); !it.Done(); it.Next()) {
    syntax_asdl::SourceLine* li = it.Value();
    StackRoot _for(&li  );
    if (li == left->line) {
      found_left = true;
      saving = true;
      piece = li->content->slice(left->col);
      pieces->append(piece);
      continue;
    }
    if (li == right->line) {
      found_right = true;
      piece = li->content->slice(0, (right->col + right->length));
      pieces->append(piece);
      saving = false;
      break;
    }
    if (saving) {
      pieces->append(li->content);
    }
  }
  return S_Aoo->join(pieces);
}

syntax_asdl::Token* Arena::NewToken(int id_, int col, int length, syntax_asdl::SourceLine* src_line) {
  syntax_asdl::Token* tok = nullptr;
  int span_id;
  StackRoot _root0(&src_line);
  StackRoot _root1(&tok);

  if (length >= 65536) {
    throw Alloc<error::Parse>(S_Aoo, Alloc<loc::TokenTooLong>(src_line, id_, length, col));
  }
  tok = Alloc<Token>(id_, length, col, src_line, nullptr);
  if (this->save_tokens) {
    span_id = this->num_tokens;
    this->num_tokens += 1;
    this->tokens->append(tok);
    this->span_id_lookup->set(tok, span_id);
  }
  return tok;
}

void Arena::UnreadOne() {
  if (this->save_tokens) {
    this->tokens->pop();
    this->num_tokens -= 1;
  }
}

syntax_asdl::Token* Arena::GetToken(int span_id) {
  return this->tokens->at(span_id);
}

int Arena::GetSpanId(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  return this->span_id_lookup->at(tok);
}

int Arena::LastSpanId() {
  return len(this->tokens);
}

}  // define namespace alloc

namespace bash_impl {  // define

using runtime_asdl::error_code_e;
using runtime_asdl::error_code_t;
using value_asdl::value;
using syntax_asdl::loc_t;
using error::e_die;

bool BigInt_Greater(mops::BigInt a, mops::BigInt b) {
  return mops::Greater(a, b);
}

bool BigInt_Less(mops::BigInt a, mops::BigInt b) {
  return mops::Greater(b, a);
}

bool BigInt_GreaterEq(mops::BigInt a, mops::BigInt b) {
  return !mops::Greater(b, a);
}

bool BigInt_LessEq(mops::BigInt a, mops::BigInt b) {
  return !mops::Greater(a, b);
}

ArrayIndexEvaluator::ArrayIndexEvaluator() {
  ;  // pass
}

mops::BigInt ArrayIndexEvaluator::StringToBigInt(BigStr* s, syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&s);
  StackRoot _root1(&blame_loc);

  FAIL(kNotImplemented);  // Python NotImplementedError
}

bool InternalStringArray_IsEmpty(value::InternalStringArray* array_val) {
  StackRoot _root0(&array_val);

  return len(array_val->strs) == 0;
}

int InternalStringArray_Count(value::InternalStringArray* array_val) {
  int length;
  StackRoot _root0(&array_val);

  length = 0;
  for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    if (s != nullptr) {
      length += 1;
    }
  }
  return length;
}

int InternalStringArray_Length(value::InternalStringArray* array_val) {
  StackRoot _root0(&array_val);

  return len(array_val->strs);
}

List<int>* InternalStringArray_GetKeys(value::InternalStringArray* array_val) {
  List<int>* indices = nullptr;
  int i;
  StackRoot _root0(&array_val);
  StackRoot _root1(&indices);

  indices = Alloc<List<int>>();
  i = 0;
  for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next(), ++i) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    if (s != nullptr) {
      indices->append(i);
    }
  }
  return indices;
}

List<BigStr*>* InternalStringArray_GetValues(value::InternalStringArray* array_val) {
  StackRoot _root0(&array_val);

  return array_val->strs;
}

void InternalStringArray_AppendValues(value::InternalStringArray* array_val, List<BigStr*>* strs) {
  StackRoot _root0(&array_val);
  StackRoot _root1(&strs);

  array_val->strs->extend(strs);
}

Tuple3<int, int, runtime_asdl::error_code_t> _InternalStringArray_CanonicalizeIndex(value::InternalStringArray* array_val, int index) {
  int n;
  StackRoot _root0(&array_val);

  n = len(array_val->strs);
  if (index < 0) {
    index += n;
    if (index < 0) {
      return Tuple3<int, int, runtime_asdl::error_code_t>(-1, n, error_code_e::IndexOutOfRange);
    }
  }
  return Tuple3<int, int, runtime_asdl::error_code_t>(index, n, error_code_e::OK);
}

Tuple2<bool, runtime_asdl::error_code_t> InternalStringArray_HasElement(value::InternalStringArray* array_val, int index) {
  int n;
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&array_val);

  Tuple3<int, int, runtime_asdl::error_code_t> tup0 = _InternalStringArray_CanonicalizeIndex(array_val, index);
  index = tup0.at0();
  n = tup0.at1();
  error_code = tup0.at2();
  if (error_code != error_code_e::OK) {
    return Tuple2<bool, runtime_asdl::error_code_t>(false, error_code);
  }
  if (index < n) {
    return Tuple2<bool, runtime_asdl::error_code_t>(array_val->strs->at(index) != nullptr, error_code_e::OK);
  }
  return Tuple2<bool, runtime_asdl::error_code_t>(false, error_code_e::OK);
}

Tuple2<BigStr*, runtime_asdl::error_code_t> InternalStringArray_GetElement(value::InternalStringArray* array_val, int index) {
  int n;
  runtime_asdl::error_code_t error_code;
  BigStr* s = nullptr;
  StackRoot _root0(&array_val);
  StackRoot _root1(&s);

  Tuple3<int, int, runtime_asdl::error_code_t> tup1 = _InternalStringArray_CanonicalizeIndex(array_val, index);
  index = tup1.at0();
  n = tup1.at1();
  error_code = tup1.at2();
  if (error_code != error_code_e::OK) {
    return Tuple2<BigStr*, runtime_asdl::error_code_t>(nullptr, error_code);
  }
  if (index < n) {
    s = array_val->strs->at(index);
  }
  else {
    s = nullptr;
  }
  return Tuple2<BigStr*, runtime_asdl::error_code_t>(s, error_code_e::OK);
}

runtime_asdl::error_code_t InternalStringArray_SetElement(value::InternalStringArray* array_val, int index, BigStr* s) {
  List<BigStr*>* strs = nullptr;
  int n;
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&array_val);
  StackRoot _root1(&s);
  StackRoot _root2(&strs);

  strs = array_val->strs;
  Tuple3<int, int, runtime_asdl::error_code_t> tup2 = _InternalStringArray_CanonicalizeIndex(array_val, index);
  index = tup2.at0();
  n = tup2.at1();
  error_code = tup2.at2();
  if (error_code != error_code_e::OK) {
    return error_code;
  }
  if (index < n) {
    array_val->strs->set(index, s);
  }
  else {
    for (int i = 0; i < ((index - n) + 1); ++i) {
      array_val->strs->append(nullptr);
    }
    array_val->strs->set(index, s);
  }
  return error_code_e::OK;
}

runtime_asdl::error_code_t InternalStringArray_UnsetElement(value::InternalStringArray* array_val, int index) {
  List<BigStr*>* strs = nullptr;
  int n;
  int last_index;
  StackRoot _root0(&array_val);
  StackRoot _root1(&strs);

  strs = array_val->strs;
  n = len(strs);
  last_index = (n - 1);
  if (index < 0) {
    index += n;
    if (index < 0) {
      return error_code_e::IndexOutOfRange;
    }
  }
  if (index == last_index) {
    strs->pop();
    while ((len(strs) > 0 and strs->at(-1) == nullptr)) {
      strs->pop();
    }
  }
  else {
    if (index < last_index) {
      strs->set(index, nullptr);
    }
    else {
      ;  // pass
    }
  }
  return error_code_e::OK;
}

bool InternalStringArray_Equals(value::InternalStringArray* lhs, value::InternalStringArray* rhs) {
  int len_lhs;
  int len_rhs;
  StackRoot _root0(&lhs);
  StackRoot _root1(&rhs);

  len_lhs = len(lhs->strs);
  len_rhs = len(rhs->strs);
  if (len_lhs != len_rhs) {
    return false;
  }
  for (int i = 0; i < len_lhs; ++i) {
    if (!(str_equals(lhs->strs->at(i), rhs->strs->at(i)))) {
      return false;
    }
  }
  return true;
}

bool _InternalStringArray_HasHoles(value::InternalStringArray* array_val) {
  StackRoot _root0(&array_val);

  for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    if (s == nullptr) {
      return true;
    }
  }
  return false;
}

BigStr* InternalStringArray_ToStrForShellPrint(value::InternalStringArray* array_val, BigStr* name) {
  List<BigStr*>* buff = nullptr;
  bool first;
  int i;
  StackRoot _root0(&array_val);
  StackRoot _root1(&name);
  StackRoot _root2(&buff);

  buff = Alloc<List<BigStr*>>();
  first = true;
  if (_InternalStringArray_HasHoles(array_val)) {
    if (name != nullptr) {
      buff->append(S_zxb);
      i = 0;
      for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next(), ++i) {
        BigStr* element = it.Value();
        StackRoot _for(&element      );
        if (element != nullptr) {
          if (first) {
            buff->append(S_nbf);
            first = false;
          }
          buff->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_yfw, name, S_Eax, str(i), S_nuz, j8_lite::MaybeShellEncode(element)}));
        }
      }
    }
    else {
      buff->append(S_ijB);
      i = 0;
      for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next(), ++i) {
        BigStr* element = it.Value();
        StackRoot _for(&element      );
        if (element != nullptr) {
          if (!first) {
            buff->append(S_yfw);
          }
          else {
            first = false;
            buff->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_Eax, str(i), S_nuz, j8_lite::MaybeShellEncode(element)}));
          }
        }
      }
      buff->append(S_hxb);
    }
  }
  else {
    buff->append(S_ijB);
    for (ListIter<BigStr*> it(array_val->strs); !it.Done(); it.Next()) {
      BigStr* element = it.Value();
      StackRoot _for(&element    );
      if (!first) {
        buff->append(S_yfw);
      }
      else {
        first = false;
      }
      buff->append(j8_lite::MaybeShellEncode(element));
    }
    buff->append(S_hxb);
  }
  return S_Aoo->join(buff);
}

value::BashAssoc* BashAssoc_New() {
  Dict<BigStr*, BigStr*>* d = nullptr;
  StackRoot _root0(&d);

  d = Alloc<Dict<BigStr*, BigStr*>>();
  return Alloc<value::BashAssoc>(d);
}

value::BashAssoc* BashAssoc_Copy(value::BashAssoc* val) {
  Dict<BigStr*, BigStr*>* d = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&d);

  d = Alloc<Dict<BigStr*, BigStr*>>();
  for (DictIter<BigStr*, BigStr*> it(val->d); !it.Done(); it.Next()) {
    BigStr* key = it.Key();
    StackRoot _for(&key  );
    d->set(key, val->d->at(key));
  }
  return Alloc<value::BashAssoc>(d);
}

void BashAssoc_ListInitialize(value::BashAssoc* val, value::InitializerList* initializer, bool has_plus, optview::Exec* exec_opts, syntax_asdl::loc_t* blame_loc) {
  BigStr* k = nullptr;
  BigStr* s = nullptr;
  BigStr* old_s = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&initializer);
  StackRoot _root2(&exec_opts);
  StackRoot _root3(&blame_loc);
  StackRoot _root4(&k);
  StackRoot _root5(&s);
  StackRoot _root6(&old_s);

  if (!has_plus) {
    val->d->clear();
  }
  if ((len(initializer->assigns) > 0 and initializer->assigns->at(0)->key == nullptr)) {
    if (exec_opts->strict_array()) {
      e_die(S_jgc, blame_loc);
    }
    k = nullptr;
    for (ListIter<value_asdl::InitializerValue*> it(initializer->assigns); !it.Done(); it.Next()) {
      value_asdl::InitializerValue* assign = it.Value();
      StackRoot _for(&assign    );
      s = assign->rval;
      if (assign->key != nullptr) {
        s = StrFormat("[%s]%s%s", assign->key, assign->plus_eq ? S_Coy : S_bby, s);
      }
      if (k != nullptr) {
        val->d->set(k, s);
        k = nullptr;
      }
      else {
        k = s;
      }
    }
    if (k != nullptr) {
      val->d->set(k, S_Aoo);
    }
    return ;
  }
  for (ListIter<value_asdl::InitializerValue*> it(initializer->assigns); !it.Done(); it.Next()) {
    value_asdl::InitializerValue* triplet = it.Value();
    StackRoot _for(&triplet  );
    if (triplet->key == nullptr) {
      e_die(StrFormat("Key is missing. BashAssoc requires a key for %r", triplet->rval), blame_loc);
    }
    s = triplet->rval;
    if (triplet->plus_eq) {
      old_s = val->d->get(triplet->key);
      if (old_s != nullptr) {
        s = str_concat(old_s, s);
      }
    }
    val->d->set(triplet->key, s);
  }
}

bool BashAssoc_IsEmpty(value::BashAssoc* assoc_val) {
  StackRoot _root0(&assoc_val);

  return len(assoc_val->d) == 0;
}

int BashAssoc_Count(value::BashAssoc* assoc_val) {
  StackRoot _root0(&assoc_val);

  return len(assoc_val->d);
}

Dict<BigStr*, BigStr*>* BashAssoc_GetDict(value::BashAssoc* assoc_val) {
  StackRoot _root0(&assoc_val);

  return assoc_val->d;
}

void BashAssoc_AppendDict(value::BashAssoc* assoc_val, Dict<BigStr*, BigStr*>* d) {
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&d);

  for (DictIter<BigStr*, BigStr*> it(d); !it.Done(); it.Next()) {
    BigStr* key = it.Key();
    StackRoot _for(&key  );
    assoc_val->d->set(key, d->at(key));
  }
}

List<BigStr*>* BashAssoc_GetKeys(value::BashAssoc* assoc_val) {
  StackRoot _root0(&assoc_val);

  return assoc_val->d->keys();
}

List<BigStr*>* BashAssoc_GetValues(value::BashAssoc* assoc_val) {
  StackRoot _root0(&assoc_val);

  return assoc_val->d->values();
}

bool BashAssoc_HasElement(value::BashAssoc* assoc_val, BigStr* s) {
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&s);

  return dict_contains(assoc_val->d, s);
}

BigStr* BashAssoc_GetElement(value::BashAssoc* assoc_val, BigStr* s) {
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&s);

  return assoc_val->d->get(s);
}

void BashAssoc_SetElement(value::BashAssoc* assoc_val, BigStr* key, BigStr* s) {
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&key);
  StackRoot _root2(&s);

  assoc_val->d->set(key, s);
}

void BashAssoc_UnsetElement(value::BashAssoc* assoc_val, BigStr* key) {
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&key);

  mylib::dict_erase(assoc_val->d, key);
}

bool BashAssoc_Equals(value::BashAssoc* lhs, value::BashAssoc* rhs) {
  StackRoot _root0(&lhs);
  StackRoot _root1(&rhs);

  if (len(lhs->d) != len(rhs->d)) {
    return false;
  }
  for (DictIter<BigStr*, BigStr*> it(lhs->d); !it.Done(); it.Next()) {
    BigStr* k = it.Key();
    StackRoot _for(&k  );
    if ((!dict_contains(rhs->d, k) or !(str_equals(rhs->d->at(k), lhs->d->at(k))))) {
      return false;
    }
  }
  return true;
}

BigStr* BashAssoc_ToStrForShellPrint(value::BashAssoc* assoc_val) {
  List<BigStr*>* buff = nullptr;
  bool first;
  BigStr* key_quoted = nullptr;
  BigStr* value_quoted = nullptr;
  StackRoot _root0(&assoc_val);
  StackRoot _root1(&buff);
  StackRoot _root2(&key_quoted);
  StackRoot _root3(&value_quoted);

  buff = NewList<BigStr*>(std::initializer_list<BigStr*>{S_ijB});
  first = true;
  for (ListIter<BigStr*> it(sorted(assoc_val->d)); !it.Done(); it.Next()) {
    BigStr* key = it.Value();
    StackRoot _for(&key  );
    if (!first) {
      buff->append(S_yfw);
    }
    else {
      first = false;
    }
    key_quoted = j8_lite::ShellEncode(key);
    value_quoted = j8_lite::MaybeShellEncode(assoc_val->d->at(key));
    buff->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_Eax, key_quoted, S_nuz, value_quoted}));
  }
  buff->append(S_hxb);
  return S_Aoo->join(buff);
}

value::BashArray* BashArray_New() {
  Dict<mops::BigInt, BigStr*>* d = nullptr;
  mops::BigInt max_index;
  StackRoot _root0(&d);

  d = Alloc<Dict<mops::BigInt, BigStr*>>();
  max_index = mops::MINUS_ONE;
  return Alloc<value::BashArray>(d, max_index);
}

value::BashArray* BashArray_Copy(value::BashArray* val) {
  Dict<mops::BigInt, BigStr*>* d = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&d);

  d = Alloc<Dict<mops::BigInt, BigStr*>>();
  for (DictIter<mops::BigInt, BigStr*> it(val->d); !it.Done(); it.Next()) {
    mops::BigInt index = it.Key();
    d->set(index, val->d->at(index));
  }
  return Alloc<value::BashArray>(d, val->max_index);
}

value::BashArray* BashArray_FromList(List<BigStr*>* strs) {
  Dict<mops::BigInt, BigStr*>* d = nullptr;
  mops::BigInt max_index;
  StackRoot _root0(&strs);
  StackRoot _root1(&d);

  d = Alloc<Dict<mops::BigInt, BigStr*>>();
  max_index = mops::MINUS_ONE;
  for (ListIter<BigStr*> it(strs); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    max_index = mops::Add(max_index, mops::ONE);
    if (s != nullptr) {
      d->set(max_index, s);
    }
  }
  return Alloc<value::BashArray>(d, max_index);
}

void BashArray_ListInitialize(value::BashArray* val, value::InitializerList* initializer, bool has_plus, syntax_asdl::loc_t* blame_loc, bash_impl::ArrayIndexEvaluator* arith_ev) {
  mops::BigInt array_index;
  BigStr* s = nullptr;
  BigStr* old_s = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&initializer);
  StackRoot _root2(&blame_loc);
  StackRoot _root3(&arith_ev);
  StackRoot _root4(&s);
  StackRoot _root5(&old_s);

  if (!has_plus) {
    val->d->clear();
    val->max_index = mops::MINUS_ONE;
  }
  array_index = val->max_index;
  for (ListIter<value_asdl::InitializerValue*> it(initializer->assigns); !it.Done(); it.Next()) {
    value_asdl::InitializerValue* triplet = it.Value();
    StackRoot _for(&triplet  );
    if (triplet->key != nullptr) {
      array_index = arith_ev->StringToBigInt(triplet->key, blame_loc);
    }
    else {
      array_index = mops::Add(array_index, mops::ONE);
    }
    s = triplet->rval;
    if (triplet->plus_eq) {
      old_s = val->d->get(array_index);
      if (old_s != nullptr) {
        s = str_concat(old_s, s);
      }
    }
    val->d->set(array_index, s);
    if (BigInt_Greater(array_index, val->max_index)) {
      val->max_index = array_index;
    }
  }
}

bool BashArray_IsEmpty(value::BashArray* sparse_val) {
  StackRoot _root0(&sparse_val);

  return len(sparse_val->d) == 0;
}

int BashArray_Count(value::BashArray* sparse_val) {
  StackRoot _root0(&sparse_val);

  return len(sparse_val->d);
}

mops::BigInt BashArray_Length(value::BashArray* sparse_val) {
  StackRoot _root0(&sparse_val);

  return mops::Add(sparse_val->max_index, mops::ONE);
}

List<mops::BigInt>* BashArray_GetKeys(value::BashArray* sparse_val) {
  List<mops::BigInt>* keys = nullptr;
  StackRoot _root0(&sparse_val);
  StackRoot _root1(&keys);

  keys = sparse_val->d->keys();
  mylib::BigIntSort(keys);
  return keys;
}

List<BigStr*>* BashArray_GetValues(value::BashArray* sparse_val) {
  List<BigStr*>* values = nullptr;
  StackRoot _root0(&sparse_val);
  StackRoot _root1(&values);

  values = Alloc<List<BigStr*>>();
  for (ListIter<mops::BigInt> it(BashArray_GetKeys(sparse_val)); !it.Done(); it.Next()) {
    mops::BigInt index = it.Value();
    values->append(sparse_val->d->at(index));
  }
  return values;
}

void BashArray_AppendValues(value::BashArray* sparse_val, List<BigStr*>* strs) {
  StackRoot _root0(&sparse_val);
  StackRoot _root1(&strs);

  for (ListIter<BigStr*> it(strs); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    sparse_val->max_index = mops::Add(sparse_val->max_index, mops::ONE);
    sparse_val->d->set(sparse_val->max_index, s);
  }
}

Tuple2<mops::BigInt, runtime_asdl::error_code_t> _BashArray_CanonicalizeIndex(value::BashArray* sparse_val, mops::BigInt index) {
  StackRoot _root0(&sparse_val);

  if (BigInt_Less(index, mops::ZERO)) {
    index = mops::Add(index, mops::Add(sparse_val->max_index, mops::ONE));
    if (BigInt_Less(index, mops::ZERO)) {
      return Tuple2<mops::BigInt, runtime_asdl::error_code_t>(mops::MINUS_ONE, error_code_e::IndexOutOfRange);
    }
  }
  return Tuple2<mops::BigInt, runtime_asdl::error_code_t>(index, error_code_e::OK);
}

Tuple2<bool, runtime_asdl::error_code_t> BashArray_HasElement(value::BashArray* sparse_val, mops::BigInt index) {
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&sparse_val);

  Tuple2<mops::BigInt, runtime_asdl::error_code_t> tup3 = _BashArray_CanonicalizeIndex(sparse_val, index);
  index = tup3.at0();
  error_code = tup3.at1();
  if (error_code != error_code_e::OK) {
    return Tuple2<bool, runtime_asdl::error_code_t>(false, error_code);
  }
  return Tuple2<bool, runtime_asdl::error_code_t>(dict_contains(sparse_val->d, index), error_code_e::OK);
}

Tuple2<BigStr*, runtime_asdl::error_code_t> BashArray_GetElement(value::BashArray* sparse_val, mops::BigInt index) {
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&sparse_val);

  Tuple2<mops::BigInt, runtime_asdl::error_code_t> tup4 = _BashArray_CanonicalizeIndex(sparse_val, index);
  index = tup4.at0();
  error_code = tup4.at1();
  if (error_code != error_code_e::OK) {
    return Tuple2<BigStr*, runtime_asdl::error_code_t>(nullptr, error_code);
  }
  return Tuple2<BigStr*, runtime_asdl::error_code_t>(sparse_val->d->get(index), error_code_e::OK);
}

runtime_asdl::error_code_t BashArray_SetElement(value::BashArray* sparse_val, mops::BigInt index, BigStr* s) {
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&sparse_val);
  StackRoot _root1(&s);

  Tuple2<mops::BigInt, runtime_asdl::error_code_t> tup5 = _BashArray_CanonicalizeIndex(sparse_val, index);
  index = tup5.at0();
  error_code = tup5.at1();
  if (error_code != error_code_e::OK) {
    return error_code;
  }
  if (BigInt_Greater(index, sparse_val->max_index)) {
    sparse_val->max_index = index;
  }
  sparse_val->d->set(index, s);
  return error_code_e::OK;
}

runtime_asdl::error_code_t BashArray_UnsetElement(value::BashArray* sparse_val, mops::BigInt index) {
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&sparse_val);

  Tuple2<mops::BigInt, runtime_asdl::error_code_t> tup6 = _BashArray_CanonicalizeIndex(sparse_val, index);
  index = tup6.at0();
  error_code = tup6.at1();
  if (error_code != error_code_e::OK) {
    return error_code;
  }
  mylib::dict_erase(sparse_val->d, index);
  if (mops::Equal(index, sparse_val->max_index)) {
    sparse_val->max_index = mops::MINUS_ONE;
    for (DictIter<mops::BigInt, BigStr*> it(sparse_val->d); !it.Done(); it.Next()) {
      mops::BigInt index = it.Key();
      if (mops::Greater(index, sparse_val->max_index)) {
        sparse_val->max_index = index;
      }
    }
  }
  return error_code_e::OK;
}

bool BashArray_Equals(value::BashArray* lhs, value::BashArray* rhs) {
  int len_lhs;
  int len_rhs;
  StackRoot _root0(&lhs);
  StackRoot _root1(&rhs);

  len_lhs = len(lhs->d);
  len_rhs = len(rhs->d);
  if (len_lhs != len_rhs) {
    return false;
  }
  for (DictIter<mops::BigInt, BigStr*> it(lhs->d); !it.Done(); it.Next()) {
    mops::BigInt index = it.Key();
    if ((!dict_contains(rhs->d, index) or !(str_equals(rhs->d->at(index), lhs->d->at(index))))) {
      return false;
    }
  }
  return true;
}

BigStr* BashArray_ToStrForShellPrint(value::BashArray* sparse_val) {
  List<BigStr*>* body = nullptr;
  bool is_sparse;
  StackRoot _root0(&sparse_val);
  StackRoot _root1(&body);

  body = Alloc<List<BigStr*>>();
  is_sparse = !mops::Equal(mops::IntWiden(BashArray_Count(sparse_val)), BashArray_Length(sparse_val));
  for (ListIter<mops::BigInt> it(BashArray_GetKeys(sparse_val)); !it.Done(); it.Next()) {
    mops::BigInt index = it.Value();
    if (len(body) > 0) {
      body->append(S_yfw);
    }
    if (is_sparse) {
      body->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_Eax, mops::ToStr(index), S_nuz}));
    }
    body->append(j8_lite::MaybeShellEncode(sparse_val->d->at(index)));
  }
  return StrFormat("(%s)", S_Aoo->join(body));
}

BigStr* InitializerList_ToStrForShellPrint(value::InitializerList* val) {
  List<BigStr*>* body = nullptr;
  BigStr* key = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&body);
  StackRoot _root2(&key);

  body = Alloc<List<BigStr*>>();
  for (ListIter<value_asdl::InitializerValue*> it(val->assigns); !it.Done(); it.Next()) {
    value_asdl::InitializerValue* init = it.Value();
    StackRoot _for(&init  );
    if (len(body) > 0) {
      body->append(S_yfw);
    }
    if (init->key != nullptr) {
      key = j8_lite::MaybeShellEncode(init->key);
      if (init->plus_eq) {
        body->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_Eax, key, S_ldx}));
      }
      else {
        body->extend(NewList<BigStr*>(std::initializer_list<BigStr*>{S_Eax, key, S_nuz}));
      }
    }
    body->append(j8_lite::MaybeShellEncode(init->rval));
  }
  return StrFormat("(%s)", S_Aoo->join(body));
}

}  // define namespace bash_impl

namespace error {  // define

using syntax_asdl::loc_e;
using syntax_asdl::loc_t;
using syntax_asdl::loc;
using value_asdl::value;
using value_asdl::value_t;
using value_asdl::value_str;

BigStr* _ValType(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return value_str(val->tag(), false);
}

_ErrorWithLocation::_ErrorWithLocation(BigStr* msg, syntax_asdl::loc_t* location) {
  this->msg = msg;
  if (location == nullptr) {
    this->location = loc::Missing;
  }
  else {
    this->location = location;
  }
}

bool _ErrorWithLocation::HasLocation() {
  return this->location->tag() != loc_e::Missing;
}

BigStr* _ErrorWithLocation::UserErrorString() {
  return this->msg;
}

Usage::Usage(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

Parse::Parse(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

WordFailure::WordFailure(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

FailGlob::FailGlob(BigStr* msg, syntax_asdl::loc_t* location) : ::error::WordFailure(str_concat(S_xho, msg), location) {
}

VarSubFailure::VarSubFailure(BigStr* msg, syntax_asdl::loc_t* location) : ::error::WordFailure(msg, location) {
}

RedirectEval::RedirectEval(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

FatalRuntime::FatalRuntime(int exit_status, BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
  this->exit_status = exit_status;
}

int FatalRuntime::ExitStatus() {
  return this->exit_status;
}

Strict::Strict(BigStr* msg, syntax_asdl::loc_t* location) : ::error::FatalRuntime(1, msg, location) {
}

ErrExit::ErrExit(int exit_status, BigStr* msg, syntax_asdl::loc_t* location, bool show_code) : ::error::FatalRuntime(exit_status, msg, location) {
  this->show_code = show_code;
}

Expr::Expr(BigStr* msg, syntax_asdl::loc_t* location) : ::error::FatalRuntime(3, msg, location) {
}

Structured::Structured(int status, BigStr* msg, syntax_asdl::loc_t* location, Dict<BigStr*, value_asdl::value_t*>* properties) : ::error::FatalRuntime(status, msg, location) {
  this->properties = properties;
}

value::Dict* Structured::ToDict() {
  Dict<BigStr*, value_asdl::value_t*>* d = nullptr;
  StackRoot _root0(&d);

  d = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  if (this->properties != nullptr) {
    d->update(this->properties);
  }
  d->set(S_gFE, num::ToBig(this->ExitStatus()));
  d->set(S_pBg, Alloc<value::Str>(this->msg));
  return Alloc<value::Dict>(d);
}

AssertionErr::AssertionErr(BigStr* msg, syntax_asdl::loc_t* location) : ::error::Expr(msg, location) {
}

TypeErrVerbose::TypeErrVerbose(BigStr* msg, syntax_asdl::loc_t* location) : ::error::Expr(msg, location) {
}

TypeErr::TypeErr(value_asdl::value_t* actual_val, BigStr* msg, syntax_asdl::loc_t* location) : ::error::TypeErrVerbose(StrFormat("%s, got %s", msg, _ValType(actual_val)), location) {
}

Runtime::Runtime(BigStr* msg) {
  this->msg = msg;
}

BigStr* Runtime::UserErrorString() {
  return this->msg;
}

Decode::Decode(BigStr* msg, BigStr* s, int start_pos, int end_pos, int line_num) {
  this->msg = msg;
  this->s = s;
  this->start_pos = start_pos;
  this->end_pos = end_pos;
  this->line_num = line_num;
}

BigStr* Decode::Message() {
  int start;
  int end;
  BigStr* part = nullptr;
  StackRoot _root0(&part);

  start = max(0, (this->start_pos - 4));
  end = min(len(this->s), (this->end_pos + 4));
  part = this->s->slice(start, end);
  return str_concat(this->msg, StrFormat(" (line %d, offset %d-%d: %r)", this->line_num, this->start_pos, this->end_pos, part));
}

BigStr* Decode::__str__() {
  return this->Message();
}

Encode::Encode(BigStr* msg) {
  this->msg = msg;
}

BigStr* Encode::Message() {
  return this->msg;
}

[[noreturn]] void e_usage(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Usage>(msg, location);
}

[[noreturn]] void e_strict(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Strict>(msg, location);
}

[[noreturn]] void p_die(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Parse>(msg, location);
}

[[noreturn]] void e_die(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<FatalRuntime>(1, msg, location);
}

[[noreturn]] void e_die_status(int status, BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<FatalRuntime>(status, msg, location);
}

}  // define namespace error

namespace num {  // define

using value_asdl::value;

value::Int* ToBig(int i) {
  return Alloc<value::Int>(mops::IntWiden(i));
}

mops::BigInt Exponent(mops::BigInt x, mops::BigInt y) {
  int y_int;
  mops::BigInt result;
  y_int = mops::BigTruncate(y);
  result = mops::BigInt(1);
  for (int i = 0; i < y_int; ++i) {
    result = mops::Mul(result, x);
  }
  return result;
}

}  // define namespace num

namespace state {  // define

using id_kind_asdl::Id;
using option_asdl::option_i;
using runtime_asdl::error_code_e;
using runtime_asdl::scope_e;
using runtime_asdl::scope_t;
using runtime_asdl::Cell;
using syntax_asdl::CompoundWord;
using syntax_asdl::loc;
using syntax_asdl::loc_t;
using syntax_asdl::Token;
using syntax_asdl::debug_frame;
using syntax_asdl::debug_frame_e;
using syntax_asdl::debug_frame_t;
using types_asdl::opt_group_i;
using value_asdl::value;
using value_asdl::value_e;
using value_asdl::value_t;
using value_asdl::Obj;
using value_asdl::sh_lvalue;
using value_asdl::sh_lvalue_e;
using value_asdl::sh_lvalue_t;
using value_asdl::LeftName;
using value_asdl::y_lvalue_e;
using value_asdl::regex_match;
using value_asdl::regex_match_e;
using value_asdl::regex_match_t;
using value_asdl::RegexMatch;
using error::e_usage;
using error::e_die;
using mylib::print_stderr;
int SetReadOnly = (1 << 0);
int ClearReadOnly = (1 << 1);
int SetExport = (1 << 2);
int ClearExport = (1 << 3);
int SetNameref = (1 << 4);
int ClearNameref = (1 << 5);
int YshDecl = (1 << 6);

ctx_Source::ctx_Source(state::Mem* mem, BigStr* source_name, List<BigStr*>* argv, syntax_asdl::CompoundWord* source_loc) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->argv)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->PushSource(source_name, argv, source_loc);
  this->mem = mem;
  this->argv = argv;
  this->to_restore = this->mem->is_main;
  this->mem->is_main = false;
}

ctx_Source::~ctx_Source() {
  this->mem->PopSource(this->argv);
  this->mem->is_main = this->to_restore;
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_DebugTrap::ctx_DebugTrap(state::Mem* mem) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->running_debug_trap = true;
  this->mem = mem;
}

ctx_DebugTrap::~ctx_DebugTrap() {
  this->mem->running_debug_trap = false;
  gHeap.PopRoot();
}

ctx_ErrTrap::ctx_ErrTrap(state::Mem* mem) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->running_err_trap = true;
  this->mem = mem;
}

ctx_ErrTrap::~ctx_ErrTrap() {
  this->mem->running_err_trap = false;
  gHeap.PopRoot();
}

ctx_Option::ctx_Option(state::MutableOpts* mutable_opts, List<int>* opt_nums, bool b) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mutable_opts)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->opt_nums)));
  for (ListIter<int> it(opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    mutable_opts->Push(opt_num, b);
    if (opt_num == option_i::errexit) {
      mutable_opts->errexit_disabled_tok->append(nullptr);
    }
  }
  this->mutable_opts = mutable_opts;
  this->opt_nums = opt_nums;
}

ctx_Option::~ctx_Option() {
  for (ListIter<int> it(this->opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    if (opt_num == option_i::errexit) {
      this->mutable_opts->errexit_disabled_tok->pop();
    }
    this->mutable_opts->Pop(opt_num);
  }
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_AssignBuiltin::ctx_AssignBuiltin(state::MutableOpts* mutable_opts) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mutable_opts)));
  this->strict = false;
  if (mutable_opts->Get(option_i::strict_errexit)) {
    mutable_opts->Push(option_i::_allow_command_sub, false);
    mutable_opts->Push(option_i::_allow_process_sub, false);
    this->strict = true;
  }
  this->mutable_opts = mutable_opts;
}

ctx_AssignBuiltin::~ctx_AssignBuiltin() {
  if (this->strict) {
    this->mutable_opts->Pop(option_i::_allow_command_sub);
    this->mutable_opts->Pop(option_i::_allow_process_sub);
  }
  gHeap.PopRoot();
}

ctx_YshExpr::ctx_YshExpr(state::MutableOpts* mutable_opts) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mutable_opts)));
  mutable_opts->Push(option_i::command_sub_errexit, true);
  mutable_opts->Push(option_i::errexit, true);
  mutable_opts->Push(option_i::pipefail, true);
  mutable_opts->Push(option_i::inherit_errexit, true);
  mutable_opts->Push(option_i::strict_errexit, true);
  this->mutable_opts = mutable_opts;
}

ctx_YshExpr::~ctx_YshExpr() {
  this->mutable_opts->Pop(option_i::command_sub_errexit);
  this->mutable_opts->Pop(option_i::errexit);
  this->mutable_opts->Pop(option_i::pipefail);
  this->mutable_opts->Pop(option_i::inherit_errexit);
  this->mutable_opts->Pop(option_i::strict_errexit);
  gHeap.PopRoot();
}

ctx_ErrExit::ctx_ErrExit(state::MutableOpts* mutable_opts, bool b, syntax_asdl::Token* disabled_tok) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mutable_opts)));
  mutable_opts->Push(option_i::errexit, b);
  mutable_opts->errexit_disabled_tok->append(disabled_tok);
  this->strict = false;
  if (mutable_opts->Get(option_i::strict_errexit)) {
    mutable_opts->Push(option_i::_allow_command_sub, false);
    mutable_opts->Push(option_i::_allow_process_sub, false);
    this->strict = true;
  }
  this->mutable_opts = mutable_opts;
}

ctx_ErrExit::~ctx_ErrExit() {
  this->mutable_opts->errexit_disabled_tok->pop();
  this->mutable_opts->Pop(option_i::errexit);
  if (this->strict) {
    this->mutable_opts->Pop(option_i::_allow_command_sub);
    this->mutable_opts->Pop(option_i::_allow_process_sub);
  }
  gHeap.PopRoot();
}

OptHook::OptHook() {
  ;  // pass
}

bool OptHook::OnChange(List<bool>* opt0_array, BigStr* opt_name, bool b) {
  StackRoot _root0(&opt0_array);
  StackRoot _root1(&opt_name);

  return true;
}

List<bool>* InitOpts() {
  List<bool>* opt0_array = nullptr;
  StackRoot _root0(&opt0_array);

  opt0_array = list_repeat(false, option_i::ARRAY_SIZE);
  for (ListIter<int> it(consts::DEFAULT_TRUE); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    opt0_array->set(opt_num, true);
  }
  return opt0_array;
}

Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*> MakeOpts(state::Mem* mem, Dict<BigStr*, BigStr*>* environ, state::OptHook* opt_hook) {
  List<bool>* opt0_array = nullptr;
  List<bool>* no_stack = nullptr;
  List<List<bool>*>* opt_stacks = nullptr;
  optview::Parse* parse_opts = nullptr;
  optview::Exec* exec_opts = nullptr;
  state::MutableOpts* mutable_opts = nullptr;
  StackRoot _root0(&mem);
  StackRoot _root1(&environ);
  StackRoot _root2(&opt_hook);
  StackRoot _root3(&opt0_array);
  StackRoot _root4(&no_stack);
  StackRoot _root5(&opt_stacks);
  StackRoot _root6(&parse_opts);
  StackRoot _root7(&exec_opts);
  StackRoot _root8(&mutable_opts);

  opt0_array = InitOpts();
  no_stack = nullptr;
  opt_stacks = list_repeat(no_stack, option_i::ARRAY_SIZE);
  parse_opts = Alloc<optview::Parse>(opt0_array, opt_stacks);
  exec_opts = Alloc<optview::Exec>(opt0_array, opt_stacks);
  mutable_opts = Alloc<MutableOpts>(mem, environ, opt0_array, opt_stacks, opt_hook);
  return Tuple3<optview::Parse*, optview::Exec*, state::MutableOpts*>(parse_opts, exec_opts, mutable_opts);
}

void _SetGroup(List<bool>* opt0_array, List<int>* opt_nums, bool b) {
  bool b2;
  StackRoot _root0(&opt0_array);
  StackRoot _root1(&opt_nums);

  for (ListIter<int> it(opt_nums); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    b2 = list_contains(consts::DEFAULT_TRUE, opt_num) ? !b : b;
    opt0_array->set(opt_num, b2);
  }
}

optview::Parse* MakeYshParseOpts() {
  List<bool>* opt0_array = nullptr;
  List<bool>* no_stack = nullptr;
  List<List<bool>*>* opt_stacks = nullptr;
  optview::Parse* parse_opts = nullptr;
  StackRoot _root0(&opt0_array);
  StackRoot _root1(&no_stack);
  StackRoot _root2(&opt_stacks);
  StackRoot _root3(&parse_opts);

  opt0_array = InitOpts();
  _SetGroup(opt0_array, consts::YSH_ALL, true);
  no_stack = nullptr;
  opt_stacks = list_repeat(no_stack, option_i::ARRAY_SIZE);
  parse_opts = Alloc<optview::Parse>(opt0_array, opt_stacks);
  return parse_opts;
}

int _AnyOptionNum(BigStr* opt_name, bool ignore_shopt_not_impl) {
  int opt_num;
  StackRoot _root0(&opt_name);

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == 0) {
    if (ignore_shopt_not_impl) {
      opt_num = consts::UnimplOptionNum(opt_name);
    }
    if (opt_num == 0) {
      e_usage(StrFormat("got invalid option %r", opt_name), loc::Missing);
    }
  }
  return opt_num;
}

int _SetOptionNum(BigStr* opt_name) {
  int opt_num;
  StackRoot _root0(&opt_name);

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == 0) {
    e_usage(StrFormat("got invalid option %r", opt_name), loc::Missing);
  }
  if (!list_contains(consts::SET_OPTION_NUMS, opt_num)) {
    e_usage(StrFormat("invalid option %r (try shopt)", opt_name), loc::Missing);
  }
  return opt_num;
}

void _MaybeWarnDotglob() {
  if (HAVE_GLOB_PERIOD == 0) {
    print_stderr(S_lAu);
  }
}

MutableOpts::MutableOpts(state::Mem* mem, Dict<BigStr*, BigStr*>* environ, List<bool>* opt0_array, List<List<bool>*>* opt_stacks, state::OptHook* opt_hook) {
  this->mem = mem;
  this->environ = environ;
  this->opt0_array = opt0_array;
  this->opt_stacks = opt_stacks;
  this->errexit_disabled_tok = Alloc<List<syntax_asdl::Token*>>();
  this->opt_hook = opt_hook;
}

void MutableOpts::InitFromEnv(BigStr* shellopts) {
  List<BigStr*>* lookup = nullptr;
  BigStr* name = nullptr;
  StackRoot _root0(&shellopts);
  StackRoot _root1(&lookup);
  StackRoot _root2(&name);

  lookup = shellopts->split(S_fyj);
  for (ListIter<int> it(consts::SET_OPTION_NUMS); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    name = consts::OptionName(opt_num);
    if (list_contains(lookup, name)) {
      this->_SetOldOption(name, true);
    }
  }
}

BigStr* MutableOpts::ShelloptsString() {
  List<BigStr*>* names = nullptr;
  BigStr* name = nullptr;
  StackRoot _root0(&names);
  StackRoot _root1(&name);

  names = Alloc<List<BigStr*>>();
  for (ListIter<int> it(consts::SET_OPTION_NUMS); !it.Done(); it.Next()) {
    int opt_num = it.Value();
    if (this->Get(opt_num)) {
      name = consts::OptionName(opt_num);
      names->append(name);
    }
  }
  return S_fyj->join(names);
}

void MutableOpts::Push(int opt_num, bool b) {
  List<bool>* overlay = nullptr;
  StackRoot _root0(&overlay);

  if (opt_num == option_i::dotglob) {
    _MaybeWarnDotglob();
  }
  overlay = this->opt_stacks->at(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    this->opt_stacks->set(opt_num, NewList<bool>(std::initializer_list<bool>{b}));
  }
  else {
    overlay->append(b);
  }
}

bool MutableOpts::Pop(int opt_num) {
  List<bool>* overlay = nullptr;
  StackRoot _root0(&overlay);

  overlay = this->opt_stacks->at(opt_num);
  return overlay->pop();
}

void MutableOpts::PushDynamicScope(bool b) {
  if (!this->Get(option_i::dynamic_scope)) {
    b = false;
  }
  this->Push(option_i::dynamic_scope, b);
}

void MutableOpts::PopDynamicScope() {
  this->Pop(option_i::dynamic_scope);
}

bool MutableOpts::Get(int opt_num) {
  List<bool>* overlay = nullptr;
  StackRoot _root0(&overlay);

  overlay = this->opt_stacks->at(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    return this->opt0_array->at(opt_num);
  }
  else {
    return overlay->at(-1);
  }
}

void MutableOpts::_Set(int opt_num, bool b) {
  List<bool>* overlay = nullptr;
  StackRoot _root0(&overlay);

  if (opt_num == option_i::dotglob) {
    _MaybeWarnDotglob();
  }
  overlay = this->opt_stacks->at(opt_num);
  if ((overlay == nullptr or len(overlay) == 0)) {
    this->opt0_array->set(opt_num, b);
  }
  else {
    overlay->set(-1, b);
  }
}

void MutableOpts::set_interactive() {
  this->_Set(option_i::interactive, true);
}

void MutableOpts::set_redefine_const() {
  this->_Set(option_i::redefine_const, true);
}

void MutableOpts::set_redefine_source() {
  this->_Set(option_i::redefine_source, true);
}

void MutableOpts::set_emacs() {
  this->_Set(option_i::emacs, true);
}

void MutableOpts::_SetArrayByNum(int opt_num, bool b) {
  this->_Set(opt_num, b);
}

void MutableOpts::SetDeferredErrExit(bool b) {
  this->opt0_array->set(option_i::errexit, b);
}

void MutableOpts::DisableErrExit() {
  this->_Set(option_i::errexit, false);
}

syntax_asdl::Token* MutableOpts::ErrExitDisabledToken() {
  if (this->Get(option_i::_running_trap)) {
    return nullptr;
  }
  if (len(this->errexit_disabled_tok) == 0) {
    return nullptr;
  }
  return this->errexit_disabled_tok->at(-1);
}

bool MutableOpts::ErrExitIsDisabled() {
  if (len(this->errexit_disabled_tok) == 0) {
    return false;
  }
  return this->errexit_disabled_tok->at(-1) != nullptr;
}

void MutableOpts::_SetOldOption(BigStr* opt_name, bool b) {
  int opt_num;
  bool success;
  StackRoot _root0(&opt_name);

  opt_num = consts::OptionNum(opt_name);
  if (opt_num == option_i::errexit) {
    this->SetDeferredErrExit(b);
  }
  else {
    if ((opt_num == option_i::verbose and b)) {
      print_stderr(S_nAz);
    }
    this->_SetArrayByNum(opt_num, b);
  }
  success = this->opt_hook->OnChange(this->opt0_array, opt_name, b);
}

void MutableOpts::SetOldOption(BigStr* opt_name, bool b) {
  int unused;
  (void)unused;
  value_asdl::value_t* UP_val = nullptr;
  BigStr* shellopts = nullptr;
  BigStr* new_val = nullptr;
  List<BigStr*>* names = nullptr;
  StackRoot _root0(&opt_name);
  StackRoot _root1(&UP_val);
  StackRoot _root2(&shellopts);
  StackRoot _root3(&new_val);
  StackRoot _root4(&names);

  unused = _SetOptionNum(opt_name);
  this->_SetOldOption(opt_name, b);
  if (!this->Get(option_i::no_init_globals)) {
    UP_val = this->mem->GetValue(S_cvm);
    value::Str* val = static_cast<value::Str*>(UP_val);
    shellopts = val->s;
    if (b) {
      if (!str_contains(shellopts, opt_name)) {
        if (len(shellopts) == 0) {
          new_val = opt_name;
        }
        else {
          new_val = StrFormat("%s:%s", shellopts, opt_name);
        }
        this->mem->InternalSetGlobal(S_cvm, Alloc<value::Str>(new_val));
      }
    }
    else {
      if (str_contains(shellopts, opt_name)) {
        names = Alloc<List<BigStr*>>();
        for (ListIter<BigStr*> it(shellopts->split(S_fyj)); !it.Done(); it.Next()) {
          BigStr* n = it.Value();
          if (!(str_equals(n, opt_name))) {
            names->append(n);
          }
        }
        new_val = S_fyj->join(names);
        this->mem->InternalSetGlobal(S_cvm, Alloc<value::Str>(new_val));
      }
    }
  }
}

void MutableOpts::SetAnyOption(BigStr* opt_name, bool b, bool ignore_shopt_not_impl) {
  int opt_group;
  int opt_num;
  StackRoot _root0(&opt_name);

  opt_group = consts::OptionGroupNum(opt_name);
  if (opt_group == opt_group_i::YshUpgrade) {
    _SetGroup(this->opt0_array, consts::YSH_UPGRADE, b);
    this->SetDeferredErrExit(b);
    if (b) {
      this->mem->MaybeInitEnvDict(this->environ);
    }
    return ;
  }
  if (opt_group == opt_group_i::YshAll) {
    _SetGroup(this->opt0_array, consts::YSH_ALL, b);
    this->SetDeferredErrExit(b);
    if (b) {
      this->mem->MaybeInitEnvDict(this->environ);
    }
    return ;
  }
  if (opt_group == opt_group_i::StrictAll) {
    _SetGroup(this->opt0_array, consts::STRICT_ALL, b);
    return ;
  }
  opt_num = _AnyOptionNum(opt_name, ignore_shopt_not_impl);
  if (opt_num == option_i::errexit) {
    this->SetDeferredErrExit(b);
    return ;
  }
  this->_SetArrayByNum(opt_num, b);
}

_ArgFrame::_ArgFrame(List<BigStr*>* argv) {
  this->argv = argv;
  this->num_shifted = 0;
}

Dict<BigStr*, value_asdl::value_t*>* _ArgFrame::Dump() {
  List<value_asdl::value_t*>* items = nullptr;
  value::List* argv = nullptr;
  StackRoot _root0(&items);
  StackRoot _root1(&argv);

  items = Alloc<List<value_asdl::value_t*>>();
  for (ListIter<BigStr*> it(this->argv); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    items->append(Alloc<value::Str>(s));
  }
  argv = Alloc<value::List>(items);
  return Alloc<Dict<BigStr*, value_asdl::value_t*>>(std::initializer_list<BigStr*>{S_esE, S_owh}, std::initializer_list<value_asdl::value_t*>{argv, num::ToBig(this->num_shifted)});
}

value_asdl::value_t* _ArgFrame::GetArgNum(int arg_num) {
  int index;
  index = ((this->num_shifted + arg_num) - 1);
  if (index >= len(this->argv)) {
    return value::Undef;
  }
  return Alloc<value::Str>(this->argv->at(index));
}

List<BigStr*>* _ArgFrame::GetArgv() {
  return this->argv->slice(this->num_shifted);
}

int _ArgFrame::GetNumArgs() {
  return (len(this->argv) - this->num_shifted);
}

void _ArgFrame::SetArgv(List<BigStr*>* argv) {
  StackRoot _root0(&argv);

  this->argv = argv;
  this->num_shifted = 0;
}

Dict<BigStr*, value_asdl::value_t*>* _DumpVarFrame(Dict<BigStr*, runtime_asdl::Cell*>* frame) {
  Dict<BigStr*, value_asdl::value_t*>* vars_json = nullptr;
  Dict<BigStr*, value_asdl::value_t*>* cell_json = nullptr;
  mylib::BufWriter* buf = nullptr;
  BigStr* flags = nullptr;
  StackRoot _root0(&frame);
  StackRoot _root1(&vars_json);
  StackRoot _root2(&cell_json);
  StackRoot _root3(&buf);
  StackRoot _root4(&flags);

  vars_json = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  for (DictIter<BigStr*, runtime_asdl::Cell*> it(frame); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    runtime_asdl::Cell* cell = it.Value();
    cell_json = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
    buf = Alloc<mylib::BufWriter>();
    if (cell->exported) {
      buf->write(S_rqD);
    }
    if (cell->readonly) {
      buf->write(S_nAr);
    }
    flags = buf->getvalue();
    if (len(flags)) {
      cell_json->set(S_boy, Alloc<value::Str>(flags));
    }
    switch (cell->val->tag()) {
      case value_e::Undef: {
        cell_json->set(S_zrD, value::Null);
      }
        break;
      case value_e::Str: 
      case value_e::InternalStringArray: 
      case value_e::BashAssoc: 
      case value_e::BashArray: {
        cell_json->set(S_zrD, cell->val);
      }
        break;
      default: {
        ;  // pass
      }
    }
    vars_json->set(name, Alloc<value::Dict>(cell_json));
  }
  return vars_json;
}

BigStr* _LineNumber(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  if (tok == nullptr) {
    return S_zdb;
  }
  return str(tok->line->line_num);
}

void _AddCallToken(Dict<BigStr*, value_asdl::value_t*>* d, syntax_asdl::Token* token) {
  StackRoot _root0(&d);
  StackRoot _root1(&token);

  if (token == nullptr) {
    return ;
  }
  d->set(S_ogo, Alloc<value::Str>(ui::GetLineSourceString(token->line)));
  d->set(S_eqz, num::ToBig(token->line->line_num));
  d->set(S_tzb, Alloc<value::Str>(token->line->content));
}

ctx_FuncCall::ctx_FuncCall(state::Mem* mem, value::Func* func, syntax_asdl::Token* blame_tok) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->saved_globals)));
  this->saved_globals = mem->var_stack->at(0);
  mem->var_stack->set(0, func->module_frame);
  auto* frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  frame->set(S_hub, Alloc<Cell>(false, false, false, Alloc<value::Frame>(func->captured_frame)));
  mem->var_stack->append(frame);
  mem->debug_stack->append(blame_tok);
  this->mem = mem;
}

ctx_FuncCall::~ctx_FuncCall() {
  this->mem->debug_stack->pop();
  this->mem->var_stack->pop();
  this->mem->var_stack->set(0, this->saved_globals);
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_ProcCall::ctx_ProcCall(state::Mem* mem, state::MutableOpts* mutable_opts, value::Proc* proc, List<BigStr*>* argv, syntax_asdl::CompoundWord* invoke_loc) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mutable_opts)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->saved_globals)));
  this->saved_globals = mem->var_stack->at(0);
  mem->var_stack->set(0, proc->module_frame);
  auto* frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  if (proc->captured_frame != nullptr) {
    frame->set(S_hub, Alloc<Cell>(false, false, false, Alloc<value::Frame>(proc->captured_frame)));
  }
  if (proc->sh_compat) {
    mem->argv_stack->append(Alloc<_ArgFrame>(argv));
  }
  else {
    frame->set(S_wjA, _MakeArgvCell(argv));
  }
  mem->var_stack->append(frame);
  mem->debug_stack->append(Alloc<debug_frame::ProcLike>(invoke_loc, proc->name_tok, proc->name));
  mutable_opts->PushDynamicScope(proc->sh_compat);
  this->mem = mem;
  this->mutable_opts = mutable_opts;
  this->sh_compat = proc->sh_compat;
}

ctx_ProcCall::~ctx_ProcCall() {
  this->mutable_opts->PopDynamicScope();
  this->mem->debug_stack->pop();
  this->mem->var_stack->pop();
  if (this->sh_compat) {
    this->mem->argv_stack->pop();
  }
  this->mem->var_stack->set(0, this->saved_globals);
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_EvalInFrame::ctx_EvalInFrame(state::Mem* mem, Dict<BigStr*, runtime_asdl::Cell*>* frame) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->var_stack->append(frame);
  this->mem = mem;
}

ctx_EvalInFrame::~ctx_EvalInFrame() {
  this->mem->var_stack->pop();
  gHeap.PopRoot();
}

ctx_Temp::ctx_Temp(state::Mem* mem) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  this->mem = mem;
  mem->PushTemp();
}

ctx_Temp::~ctx_Temp() {
  this->mem->PopTemp();
  gHeap.PopRoot();
}

ctx_EnvObj::ctx_EnvObj(state::Mem* mem, Dict<BigStr*, value_asdl::value_t*>* bindings) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  this->mem = mem;
  mem->PushEnvObj(bindings);
}

ctx_EnvObj::~ctx_EnvObj() {
  this->mem->PopEnvObj();
  gHeap.PopRoot();
}

ctx_Registers::ctx_Registers(state::Mem* mem) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  int last = mem->last_status->at(-1);
  mem->last_status->append(last);
  mem->try_status->append(0);
  auto* tmp = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  mem->try_error->append(Alloc<value::Dict>(tmp));
  mem->pipe_status->append(Alloc<List<int>>());
  mem->process_sub_status->append(Alloc<List<int>>());
  mem->regex_match->append(regex_match::No);
  this->mem = mem;
}

ctx_Registers::~ctx_Registers() {
  this->mem->regex_match->pop();
  this->mem->process_sub_status->pop();
  this->mem->pipe_status->pop();
  this->mem->try_error->pop();
  this->mem->try_status->pop();
  this->mem->last_status->pop();
  gHeap.PopRoot();
}

ctx_ThisDir::ctx_ThisDir(state::Mem* mem, BigStr* filename) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  this->do_pop = false;
  if (filename != nullptr) {
    BigStr* d = os_path::dirname(os_path::abspath(filename));
    mem->this_dir->append(d);
    this->do_pop = true;
  }
  this->mem = mem;
}

ctx_ThisDir::~ctx_ThisDir() {
  if (this->do_pop) {
    this->mem->this_dir->pop();
  }
  gHeap.PopRoot();
}

runtime_asdl::Cell* _MakeArgvCell(List<BigStr*>* argv) {
  List<value_asdl::value_t*>* items = nullptr;
  StackRoot _root0(&argv);
  StackRoot _root1(&items);

  items = Alloc<List<value_asdl::value_t*>>();
  for (ListIter<BigStr*> it(argv); !it.Done(); it.Next()) {
    BigStr* a = it.Value();
    items->append(Alloc<value::Str>(a));
  }
  return Alloc<Cell>(false, false, false, Alloc<value::List>(items));
}

ctx_LoopFrame::ctx_LoopFrame(state::Mem* mem, bool do_new_frame) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->new_frame)));
  this->mem = mem;
  this->do_new_frame = do_new_frame;
  if (this->do_new_frame) {
    Dict<BigStr*, runtime_asdl::Cell*>* to_enclose = this->mem->var_stack->at(-1);
    this->new_frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
    this->new_frame->set(S_hub, Alloc<Cell>(false, false, false, Alloc<value::Frame>(to_enclose)));
    mem->var_stack->append(this->new_frame);
  }
}

ctx_LoopFrame::~ctx_LoopFrame() {
  if (this->do_new_frame) {
    this->mem->var_stack->pop();
  }
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_EnclosedFrame::ctx_EnclosedFrame(state::Mem* mem, Dict<BigStr*, runtime_asdl::Cell*>* to_enclose, Dict<BigStr*, runtime_asdl::Cell*>* module_frame, Dict<BigStr*, value_asdl::value_t*>* out_dict, bool inside) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->module_frame)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->new_frame)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->out_dict)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->saved_globals)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->to_enclose)));
  this->mem = mem;
  this->to_enclose = to_enclose;
  this->module_frame = module_frame;
  this->out_dict = out_dict;
  if (module_frame != nullptr) {
    this->saved_globals = this->mem->var_stack->at(0);
    this->mem->var_stack->set(0, module_frame);
  }
  if (inside) {
    this->new_frame = to_enclose;
  }
  else {
    this->new_frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
    this->new_frame->set(S_hub, Alloc<Cell>(false, false, false, Alloc<value::Frame>(to_enclose)));
  }
  mem->var_stack->append(this->new_frame);
}

ctx_EnclosedFrame::~ctx_EnclosedFrame() {
  if (this->out_dict != nullptr) {
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(this->new_frame); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      runtime_asdl::Cell* cell = it.Value();
      if (name->endswith(S_tci)) {
        continue;
      }
      this->out_dict->set(name, cell->val);
    }
  }
  this->mem->var_stack->pop();
  if (this->module_frame != nullptr) {
    this->mem->var_stack->set(0, this->saved_globals);
  }
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_CompoundWordDebugFrame::ctx_CompoundWordDebugFrame(state::Mem* mem, syntax_asdl::CompoundWord* w) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->debug_stack->append(w);
  this->mem = mem;
}

ctx_CompoundWordDebugFrame::~ctx_CompoundWordDebugFrame() {
  this->mem->debug_stack->pop();
  gHeap.PopRoot();
}

ctx_TokenDebugFrame::ctx_TokenDebugFrame(state::Mem* mem, syntax_asdl::Token* tok) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  mem->debug_stack->append(tok);
  this->mem = mem;
}

ctx_TokenDebugFrame::~ctx_TokenDebugFrame() {
  this->mem->debug_stack->pop();
  gHeap.PopRoot();
}

ctx_ModuleEval::ctx_ModuleEval(state::Mem* mem, syntax_asdl::CompoundWord* use_loc, Dict<BigStr*, value_asdl::value_t*>* out_dict, List<BigStr*>* out_errors) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->new_frame)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->out_dict)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->out_errors)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->saved_frame)));
  this->mem = mem;
  this->out_dict = out_dict;
  this->out_errors = out_errors;
  this->new_frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  this->saved_frame = mem->var_stack->at(0);
  runtime_asdl::Cell* ps4 = this->saved_frame->get(S_zyo);
  if (ps4) {
    this->new_frame->set(S_zyo, ps4);
  }
  runtime_asdl::Cell* env = this->saved_frame->get(S_iyA);
  if (env) {
    this->new_frame->set(S_iyA, env);
  }
  mem->var_stack->set(0, this->new_frame);
  this->to_restore = this->mem->is_main;
  this->mem->is_main = false;
  mem->debug_stack->append(use_loc);
}

void ctx_ModuleEval::ctx_EXIT() {
  this->mem->debug_stack->pop();
  this->mem->is_main = this->to_restore;
  this->mem->var_stack->set(0, this->saved_frame);
  runtime_asdl::Cell* cell = this->new_frame->get(S_zcz);
  if (cell == nullptr) {
    this->out_errors->append(S_ecq);
    return ;
  }
  value_asdl::value_t* provide_val = cell->val;
  switch (provide_val->tag()) {
    case value_e::List: {
      for (ListIter<value_asdl::value_t*> it(static_cast<value::List*>(provide_val)->items); !it.Done(); it.Next()) {
        value_asdl::value_t* val = it.Value();
        StackRoot _for(&val      );
        if (val->tag() == value_e::Str) {
          BigStr* name = static_cast<value::Str*>(val)->s;
          runtime_asdl::Cell* cell = this->new_frame->get(name);
          if (cell == nullptr) {
            this->out_errors->append(StrFormat("Name %r was provided, but not defined", name));
            continue;
          }
          this->out_dict->set(name, cell->val);
        }
        else {
          this->out_errors->append(StrFormat("Expected Str in __provide__ List, got %s", ui::ValType(val)));
        }
      }
    }
      break;
    default: {
      this->out_errors->append(StrFormat("__provide__ should be a List, got %s", ui::ValType(provide_val)));
    }
  }
}

ctx_ModuleEval::~ctx_ModuleEval() {
  ctx_EXIT();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
}

ctx_Eval::ctx_Eval(state::Mem* mem, BigStr* dollar0, List<BigStr*>* pos_args, Dict<BigStr*, value_asdl::value_t*>* vars) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->dollar0)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->mem)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->pos_args)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->restore)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->restore_dollar0)));
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->vars)));
  this->mem = mem;
  this->dollar0 = dollar0;
  this->pos_args = pos_args;
  this->vars = vars;
  if (dollar0 != nullptr) {
    this->restore_dollar0 = this->mem->dollar0;
    this->mem->dollar0 = dollar0;
  }
  if (pos_args != nullptr) {
    mem->argv_stack->append(Alloc<_ArgFrame>(pos_args));
  }
  if (vars != nullptr) {
    this->restore = Alloc<List<Tuple2<value_asdl::LeftName*, value_asdl::value_t*>*>>();
    this->_Push(vars);
  }
}

ctx_Eval::~ctx_Eval() {
  if (this->vars != nullptr) {
    this->_Pop();
  }
  if (this->pos_args != nullptr) {
    this->mem->argv_stack->pop();
  }
  if (this->dollar0 != nullptr) {
    this->mem->dollar0 = this->restore_dollar0;
  }
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
  gHeap.PopRoot();
}

void ctx_Eval::_Push(Dict<BigStr*, value_asdl::value_t*>* vars) {
  value_asdl::LeftName* lval = nullptr;
  value_asdl::value_t* old_val = nullptr;
  StackRoot _root0(&vars);
  StackRoot _root1(&lval);
  StackRoot _root2(&old_val);

  for (DictIter<BigStr*, value_asdl::value_t*> it(vars); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    StackRoot _for(&name  );
    lval = location::LName(name);
    old_val = this->mem->GetValue(name, scope_e::LocalOnly);
    this->restore->append((Alloc<Tuple2<value_asdl::LeftName*, value_asdl::value_t*>>(lval, old_val)));
    this->mem->SetNamed(lval, vars->at(name), scope_e::LocalOnly);
  }
}

void ctx_Eval::_Pop() {
  for (ListIter<Tuple2<value_asdl::LeftName*, value_asdl::value_t*>*> it(this->restore); !it.Done(); it.Next()) {
    Tuple2<value_asdl::LeftName*, value_asdl::value_t*>* tup0 = it.Value();
    value_asdl::LeftName* lval = tup0->at0();
    StackRoot _unpack_0(&lval);
    value_asdl::value_t* old_val = tup0->at1();
    StackRoot _unpack_1(&old_val);
    if (old_val->tag() == value_e::Undef) {
      this->mem->Unset(lval, scope_e::LocalOnly);
    }
    else {
      this->mem->SetNamed(lval, old_val, scope_e::LocalOnly);
    }
  }
}

Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> _FrameLookup(Dict<BigStr*, runtime_asdl::Cell*>* frame, BigStr* name, bool ysh_decl) {
  runtime_asdl::Cell* cell = nullptr;
  runtime_asdl::Cell* rear_cell = nullptr;
  value_asdl::value_t* rear_val = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* to_enclose = nullptr;
  StackRoot _root0(&frame);
  StackRoot _root1(&name);
  StackRoot _root2(&cell);
  StackRoot _root3(&rear_cell);
  StackRoot _root4(&rear_val);
  StackRoot _root5(&to_enclose);

  cell = frame->get(name);
  if (cell) {
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, frame);
  }
  if (!ysh_decl) {
    rear_cell = frame->get(S_hub);
    if (rear_cell) {
      rear_val = rear_cell->val;
      if (rear_val->tag() == value_e::Frame) {
        to_enclose = static_cast<value::Frame*>(rear_val)->frame;
        return _FrameLookup(to_enclose, name, ysh_decl);
      }
    }
  }
  return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, nullptr);
}

Mem::Mem(BigStr* dollar0, List<BigStr*>* argv, alloc::Arena* arena, List<syntax_asdl::debug_frame_t*>* debug_stack, Dict<BigStr*, value_asdl::value_t*>* env_dict, Dict<BigStr*, value_asdl::value_t*>* defaults) {
  this->exec_opts = nullptr;
  this->unsafe_arith = nullptr;
  this->dollar0 = dollar0;
  this->argv_stack = NewList<state::_ArgFrame*>(std::initializer_list<state::_ArgFrame*>{Alloc<_ArgFrame>(argv)});
  auto* frame0 = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  this->var_stack = NewList<Dict<BigStr*, runtime_asdl::Cell*>*>(std::initializer_list<Dict<BigStr*, runtime_asdl::Cell*>*>{frame0});
  this->debug_stack = debug_stack;
  this->env_dict = env_dict;
  this->env_object = Alloc<Obj>(nullptr, env_dict);
  if (defaults == nullptr) {
    this->defaults = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  }
  else {
    this->defaults = defaults;
  }
  this->pwd = nullptr;
  this->seconds_start = time_::time();
  this->token_for_line = nullptr;
  this->loc_for_expr = loc::Missing;
  this->last_arg = S_Aoo;
  this->line_num = Alloc<value::Str>(S_Aoo);
  this->root_pid = posix::getpid();
  this->last_status = NewList<int>(std::initializer_list<int>{0});
  this->try_status = NewList<int>(std::initializer_list<int>{0});
  auto* tmp = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  this->try_error = NewList<value::Dict*>(std::initializer_list<value::Dict*>{Alloc<value::Dict>(tmp)});
  this->pipe_status = NewList<List<int>*>(std::initializer_list<List<int>*>{Alloc<List<int>>()});
  this->process_sub_status = NewList<List<int>*>(std::initializer_list<List<int>*>{Alloc<List<int>>()});
  this->this_dir = Alloc<List<BigStr*>>();
  this->regex_match = NewList<value_asdl::regex_match_t*>(std::initializer_list<value_asdl::regex_match_t*>{regex_match::No});
  this->last_bg_pid = -1;
  this->running_debug_trap = false;
  this->running_err_trap = false;
  this->is_main = true;
  this->ctx_stack = Alloc<List<Dict<BigStr*, value_asdl::value_t*>*>>();
  this->builtins = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  value_asdl::Obj* builtins_module = Alloc<Obj>(nullptr, this->builtins);
  this->builtins->set(S_mmF, builtins_module);
  this->did_ysh_env = false;
  this->env_config = Alloc<sh_init::EnvConfig>(this, defaults);
}

void Mem::AddBuiltin(BigStr* name, value_asdl::value_t* val) {
  StackRoot _root0(&name);
  StackRoot _root1(&val);

  this->builtins->set(name, val);
}

void Mem::SetPwd(BigStr* pwd) {
  StackRoot _root0(&pwd);

  this->pwd = pwd;
}

Tuple3<List<value_asdl::value_t*>*, List<value_asdl::value_t*>*, List<value_asdl::value_t*>*> Mem::Dump() {
  List<value_asdl::value_t*>* var_stack = nullptr;
  List<value_asdl::value_t*>* argv_stack = nullptr;
  List<value_asdl::value_t*>* debug_stack = nullptr;
  value::Str* t_call = nullptr;
  value::Str* t_source = nullptr;
  syntax_asdl::debug_frame_t* UP_frame = nullptr;
  Dict<BigStr*, value_asdl::value_t*>* d = nullptr;
  syntax_asdl::Token* invoke_token = nullptr;
  StackRoot _root0(&var_stack);
  StackRoot _root1(&argv_stack);
  StackRoot _root2(&debug_stack);
  StackRoot _root3(&t_call);
  StackRoot _root4(&t_source);
  StackRoot _root5(&UP_frame);
  StackRoot _root6(&d);
  StackRoot _root7(&invoke_token);

  var_stack = Alloc<List<value_asdl::value_t*>>();
  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* frame = it.Value();
    var_stack->append(Alloc<value::Dict>(_DumpVarFrame(frame)));
  }
  argv_stack = Alloc<List<value_asdl::value_t*>>();
  for (ListIter<state::_ArgFrame*> it(this->argv_stack); !it.Done(); it.Next()) {
    state::_ArgFrame* frame = it.Value();
    argv_stack->append(Alloc<value::Dict>(frame->Dump()));
  }
  debug_stack = Alloc<List<value_asdl::value_t*>>();
  t_call = Alloc<value::Str>(S_jrg);
  t_source = Alloc<value::Str>(S_nli);
  for (ReverseListIter<syntax_asdl::debug_frame_t*> it(this->debug_stack); !it.Done(); it.Next()) {
    syntax_asdl::debug_frame_t* frame = it.Value();
    StackRoot _for(&frame  );
    UP_frame = frame;
    d = nullptr;
    switch (frame->tag()) {
      case debug_frame_e::ProcLike: {
        debug_frame::ProcLike* frame = static_cast<debug_frame::ProcLike*>(UP_frame);
        d = Alloc<Dict<BigStr*, value_asdl::value_t*>>(std::initializer_list<BigStr*>{S_qEi, S_rwo}, std::initializer_list<value_asdl::value_t*>{t_call, Alloc<value::Str>(frame->proc_name)});
        invoke_token = location::LeftTokenForCompoundWord(frame->invoke_loc);
        _AddCallToken(d, invoke_token);
      }
        break;
      case debug_frame_e::Source: {
        debug_frame::Source* frame = static_cast<debug_frame::Source*>(UP_frame);
        d = Alloc<Dict<BigStr*, value_asdl::value_t*>>(std::initializer_list<BigStr*>{S_qEi, S_gxr}, std::initializer_list<value_asdl::value_t*>{t_source, Alloc<value::Str>(frame->source_name)});
        invoke_token = location::LeftTokenForCompoundWord(frame->source_loc);
        _AddCallToken(d, invoke_token);
      }
        break;
      case debug_frame_e::CompoundWord: {
        ;  // pass
      }
        break;
      case debug_frame_e::Token: {
        ;  // pass
      }
        break;
    }
    if (d != nullptr) {
      debug_stack->append(Alloc<value::Dict>(d));
    }
  }
  return Tuple3<List<value_asdl::value_t*>*, List<value_asdl::value_t*>*, List<value_asdl::value_t*>*>(var_stack, argv_stack, debug_stack);
}

void Mem::SetLastArgument(BigStr* s) {
  StackRoot _root0(&s);

  this->last_arg = s;
}

void Mem::SetTokenForLine(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  if ((this->running_debug_trap or this->running_err_trap)) {
    return ;
  }
  this->loc_for_expr = loc::Missing;
  this->token_for_line = tok;
}

void Mem::SetLocationForExpr(syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&blame_loc);

  this->loc_for_expr = blame_loc;
}

syntax_asdl::loc_t* Mem::GetFallbackLocation() {
  if (this->loc_for_expr != loc::Missing) {
    return this->loc_for_expr;
  }
  if (this->token_for_line) {
    return this->token_for_line;
  }
  return loc::Missing;
}

int Mem::LastStatus() {
  return this->last_status->at(-1);
}

int Mem::TryStatus() {
  return this->try_status->at(-1);
}

value::Dict* Mem::TryError() {
  return this->try_error->at(-1);
}

List<int>* Mem::PipeStatus() {
  return this->pipe_status->at(-1);
}

void Mem::SetLastStatus(int x) {
  this->last_status->set(-1, x);
}

void Mem::SetTryStatus(int x) {
  this->try_status->set(-1, x);
}

void Mem::SetTryError(value::Dict* x) {
  StackRoot _root0(&x);

  this->try_error->set(-1, x);
}

void Mem::SetPipeStatus(List<int>* x) {
  StackRoot _root0(&x);

  this->pipe_status->set(-1, x);
}

void Mem::SetSimplePipeStatus(int status) {
  List<int>* top = nullptr;
  StackRoot _root0(&top);

  top = this->pipe_status->at(-1);
  if (len(top) == 1) {
    top->set(0, status);
  }
  else {
    this->pipe_status->set(-1, NewList<int>(std::initializer_list<int>{status}));
  }
}

void Mem::SetProcessSubStatus(List<int>* x) {
  StackRoot _root0(&x);

  this->process_sub_status->set(-1, x);
}

bool Mem::ShouldRunDebugTrap() {
  if (this->running_debug_trap) {
    return false;
  }
  if (len(this->var_stack) > 1) {
    return false;
  }
  return true;
}

bool Mem::IsGlobalScope() {
  return len(this->var_stack) == 1;
}

bool Mem::InsideFunction() {
  return len(this->var_stack) > 1;
}

Dict<BigStr*, runtime_asdl::Cell*>* Mem::GlobalFrame() {
  return this->var_stack->at(0);
}

Dict<BigStr*, runtime_asdl::Cell*>* Mem::CurrentFrame() {
  return this->var_stack->at(-1);
}

void Mem::PushSource(BigStr* source_name, List<BigStr*>* argv, syntax_asdl::CompoundWord* source_loc) {
  StackRoot _root0(&source_name);
  StackRoot _root1(&argv);
  StackRoot _root2(&source_loc);

  if (len(argv)) {
    this->argv_stack->append(Alloc<_ArgFrame>(argv));
  }
  this->debug_stack->append(Alloc<debug_frame::Source>(source_loc, source_name));
}

void Mem::PopSource(List<BigStr*>* argv) {
  StackRoot _root0(&argv);

  this->debug_stack->pop();
  if (len(argv)) {
    this->argv_stack->pop();
  }
}

void Mem::PushTemp() {
  Dict<BigStr*, runtime_asdl::Cell*>* frame = nullptr;
  StackRoot _root0(&frame);

  frame = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  this->var_stack->append(frame);
}

void Mem::PopTemp() {
  this->var_stack->pop();
}

void Mem::_BindEnvObj() {
  this->SetNamed(location::LName(S_iyA), this->env_object, scope_e::GlobalOnly);
}

void Mem::MaybeInitEnvDict(Dict<BigStr*, BigStr*>* environ) {
  StackRoot _root0(&environ);

  if (this->did_ysh_env) {
    return ;
  }
  for (DictIter<BigStr*, BigStr*> it(environ); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    BigStr* s = it.Value();
    this->env_dict->set(name, Alloc<value::Str>(s));
  }
  this->_BindEnvObj();
  this->did_ysh_env = true;
}

void Mem::PushEnvObj(Dict<BigStr*, value_asdl::value_t*>* bindings) {
  StackRoot _root0(&bindings);

  this->env_object = Alloc<Obj>(this->env_object, bindings);
  this->_BindEnvObj();
}

void Mem::PopEnvObj() {
  this->env_object = this->env_object->prototype;
  if (this->env_object == nullptr) {
    e_die(S_gur, loc::Missing);
  }
  this->_BindEnvObj();
}

int Mem::Shift(int n) {
  state::_ArgFrame* frame = nullptr;
  int num_args;
  StackRoot _root0(&frame);

  frame = this->argv_stack->at(-1);
  num_args = len(frame->argv);
  if ((frame->num_shifted + n) <= num_args) {
    frame->num_shifted += n;
    return 0;
  }
  else {
    return 1;
  }
}

value::Str* Mem::GetArg0() {
  return Alloc<value::Str>(this->dollar0);
}

value_asdl::value_t* Mem::GetArgNum(int arg_num) {
  if (arg_num == 0) {
    return Alloc<value::Str>(this->dollar0);
  }
  return this->argv_stack->at(-1)->GetArgNum(arg_num);
}

List<BigStr*>* Mem::GetArgv() {
  return this->argv_stack->at(-1)->GetArgv();
}

void Mem::SetArgv(List<BigStr*>* argv) {
  StackRoot _root0(&argv);

  this->argv_stack->at(-1)->SetArgv(argv);
}

value_asdl::value_t* Mem::GetSpecialVar(int op_id) {
  int n;
  if (op_id == Id::VSub_Bang) {
    n = this->last_bg_pid;
    if (n == -1) {
      return value::Undef;
    }
  }
  else {
    if (op_id == Id::VSub_QMark) {
      n = this->last_status->at(-1);
    }
    else {
      if (op_id == Id::VSub_Pound) {
        n = this->argv_stack->at(-1)->GetNumArgs();
      }
      else {
        if (op_id == Id::VSub_Dollar) {
          n = this->root_pid;
        }
        else {
          FAIL(kNotImplemented);  // Python NotImplementedError
        }
      }
    }
  }
  return Alloc<value::Str>(str(n));
}

Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> Mem::_ResolveNameForYshMutation(BigStr* name, runtime_asdl::scope_t which_scopes, bool ysh_decl) {
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* result_frame = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&var_frame);
  StackRoot _root2(&cell);
  StackRoot _root3(&result_frame);

  if (which_scopes == scope_e::LocalOnly) {
    var_frame = this->var_stack->at(-1);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup1 = _FrameLookup(var_frame, name, ysh_decl);
    cell = tup1.at0();
    result_frame = tup1.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, var_frame);
  }
  if (which_scopes == scope_e::GlobalOnly) {
    var_frame = this->var_stack->at(0);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup2 = _FrameLookup(var_frame, name, ysh_decl);
    cell = tup2.at0();
    result_frame = tup2.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, var_frame);
  }
  assert(0);  // AssertionError
}

Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> Mem::_ResolveNameOnly(BigStr* name, runtime_asdl::scope_t which_scopes) {
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* result_frame = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&var_frame);
  StackRoot _root2(&cell);
  StackRoot _root3(&result_frame);

  if (which_scopes == scope_e::Dynamic) {
    for (int i = (len(this->var_stack) - 1); i > -1; i += -1) {
      var_frame = this->var_stack->at(i);
      Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup3 = _FrameLookup(var_frame, name, false);
      cell = tup3.at0();
      result_frame = tup3.at1();
      if (cell) {
        return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
      }
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, this->var_stack->at(0));
  }
  if (which_scopes == scope_e::LocalOnly) {
    var_frame = this->var_stack->at(-1);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup4 = _FrameLookup(var_frame, name, false);
    cell = tup4.at0();
    result_frame = tup4.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, var_frame);
  }
  if (which_scopes == scope_e::GlobalOnly) {
    var_frame = this->var_stack->at(0);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup5 = _FrameLookup(var_frame, name, false);
    cell = tup5.at0();
    result_frame = tup5.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, var_frame);
  }
  if (which_scopes == scope_e::LocalOrGlobal) {
    var_frame = this->var_stack->at(-1);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup6 = _FrameLookup(var_frame, name, false);
    cell = tup6.at0();
    result_frame = tup6.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    var_frame = this->var_stack->at(0);
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup7 = _FrameLookup(var_frame, name, false);
    cell = tup7.at0();
    result_frame = tup7.at1();
    if (cell) {
      return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(cell, result_frame);
    }
    return Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*>(nullptr, var_frame);
  }
  assert(0);  // AssertionError
}

Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> Mem::_ResolveNameOrRef(BigStr* name, runtime_asdl::scope_t which_scopes, List<BigStr*>* ref_trail) {
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* UP_val = nullptr;
  BigStr* new_name = nullptr;
  BigStr* cell_name = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&ref_trail);
  StackRoot _root2(&cell);
  StackRoot _root3(&var_frame);
  StackRoot _root4(&val);
  StackRoot _root5(&UP_val);
  StackRoot _root6(&new_name);
  StackRoot _root7(&cell_name);

  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup8 = this->_ResolveNameOnly(name, which_scopes);
  cell = tup8.at0();
  var_frame = tup8.at1();
  if ((cell == nullptr or !cell->nameref)) {
    return Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*>(cell, var_frame, name);
  }
  val = cell->val;
  UP_val = val;
  switch (val->tag()) {
    case value_e::Undef: {
      if (this->exec_opts->strict_nameref()) {
        e_die(StrFormat("nameref %r is undefined", name));
      }
      else {
        return Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*>(cell, var_frame, name);
      }
    }
      break;
    case value_e::Str: {
      value::Str* val = static_cast<value::Str*>(UP_val);
      new_name = val->s;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  if (!match::IsValidVarName(new_name)) {
    if (this->exec_opts->strict_nameref()) {
      e_die(StrFormat("nameref %r contains invalid variable name %r", name, new_name));
    }
    else {
      cell->nameref = false;
      return Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*>(cell, var_frame, name);
    }
  }
  if (ref_trail == nullptr) {
    ref_trail = NewList<BigStr*>(std::initializer_list<BigStr*>{name});
  }
  else {
    if (list_contains(ref_trail, new_name)) {
      e_die(StrFormat("Circular nameref %s", S_gAe->join(ref_trail)));
    }
  }
  ref_trail->append(new_name);
  Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup9 = this->_ResolveNameOrRef(new_name, scope_e::Dynamic, ref_trail);
  cell = tup9.at0();
  var_frame = tup9.at1();
  cell_name = tup9.at2();
  return Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*>(cell, var_frame, cell_name);
}

bool Mem::IsBashAssoc(BigStr* name) {
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&cell);

  Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup10 = this->_ResolveNameOrRef(name, this->ScopesForReading());
  cell = tup10.at0();
  return (cell != nullptr and cell->val->tag() == value_e::BashAssoc);
}

void Mem::SetPlace(value::Place* place, value_asdl::value_t* val, syntax_asdl::loc_t* blame_loc) {
  value_asdl::y_lvalue_t* yval = nullptr;
  value_asdl::y_lvalue_t* UP_yval = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* frame = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&place);
  StackRoot _root1(&val);
  StackRoot _root2(&blame_loc);
  StackRoot _root3(&yval);
  StackRoot _root4(&UP_yval);
  StackRoot _root5(&frame);
  StackRoot _root6(&cell);

  yval = place->lval;
  UP_yval = yval;
  switch (yval->tag()) {
    case y_lvalue_e::Local: {
      LeftName* yval = static_cast<LeftName*>(UP_yval);
      frame = place->frame;
      cell = frame->get(yval->name);
      if (cell == nullptr) {
        cell = Alloc<Cell>(false, false, false, val);
        frame->set(yval->name, cell);
      }
      else {
        cell->val = val;
      }
    }
      break;
    case y_lvalue_e::Container: {
      e_die(S_AAe, blame_loc);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void Mem::SetLocalName(value_asdl::LeftName* lval, value_asdl::value_t* val) {
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&lval);
  StackRoot _root1(&val);
  StackRoot _root2(&var_frame);
  StackRoot _root3(&cell);

  var_frame = this->var_stack->at(-1);
  cell = var_frame->get(lval->name);
  if (cell) {
    if (cell->readonly) {
      e_die(StrFormat("Can't assign to readonly value %r", lval->name), lval->blame_loc);
    }
    cell->val = val;
  }
  else {
    cell = Alloc<Cell>(false, false, false, val);
    var_frame->set(lval->name, cell);
  }
}

void Mem::SetNamedYsh(value_asdl::LeftName* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags) {
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  StackRoot _root0(&lval);
  StackRoot _root1(&val);
  StackRoot _root2(&cell);
  StackRoot _root3(&var_frame);

  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup11 = this->_ResolveNameForYshMutation(lval->name, which_scopes, to_bool((flags & YshDecl)));
  cell = tup11.at0();
  var_frame = tup11.at1();
  if (cell) {
    if (cell->readonly) {
      e_die(StrFormat("Can't assign to readonly value %r", lval->name), lval->blame_loc);
    }
    cell->val = val;
    if ((flags & SetReadOnly)) {
      cell->readonly = true;
    }
  }
  else {
    cell = Alloc<Cell>(false, to_bool((flags & SetReadOnly)), false, val);
    var_frame->set(lval->name, cell);
  }
}

void Mem::SetNamed(value_asdl::LeftName* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags) {
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  BigStr* cell_name = nullptr;
  StackRoot _root0(&lval);
  StackRoot _root1(&val);
  StackRoot _root2(&cell);
  StackRoot _root3(&var_frame);
  StackRoot _root4(&cell_name);

  if (((flags & SetNameref) or (flags & ClearNameref))) {
    Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup12 = this->_ResolveNameOnly(lval->name, which_scopes);
    cell = tup12.at0();
    var_frame = tup12.at1();
    cell_name = lval->name;
  }
  else {
    Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup13 = this->_ResolveNameOrRef(lval->name, which_scopes);
    cell = tup13.at0();
    var_frame = tup13.at1();
    cell_name = tup13.at2();
  }
  if (cell) {
    if ((flags & ClearExport)) {
      cell->exported = false;
    }
    if ((flags & ClearReadOnly)) {
      cell->readonly = false;
    }
    if ((flags & ClearNameref)) {
      cell->nameref = false;
    }
    if (val != nullptr) {
      if (cell->readonly) {
        e_die(StrFormat("Can't assign to readonly value %r", lval->name), lval->blame_loc);
      }
      cell->val = val;
    }
    if ((flags & SetExport)) {
      cell->exported = true;
    }
    if ((flags & SetReadOnly)) {
      cell->readonly = true;
    }
    if ((flags & SetNameref)) {
      cell->nameref = true;
    }
  }
  else {
    if (val == nullptr) {
      val = value::Undef;
    }
    cell = Alloc<Cell>(to_bool((flags & SetExport)), to_bool((flags & SetReadOnly)), to_bool((flags & SetNameref)), val);
    var_frame->set(cell_name, cell);
  }
  if ((cell->val->tag() != value_e::Undef && cell->val->tag() != value_e::Str)) {
    if (cell->exported) {
      if (this->exec_opts->strict_array()) {
        e_die(S_ntu, lval->blame_loc);
      }
    }
    if (cell->nameref) {
      e_die(S_sAx, lval->blame_loc);
    }
  }
}

void Mem::SetValue(value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val, runtime_asdl::scope_t which_scopes, int flags) {
  value_asdl::sh_lvalue_t* UP_lval = nullptr;
  value::Str* rval = nullptr;
  syntax_asdl::loc_t* left_loc = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  value_asdl::value_t* UP_cell_val = nullptr;
  runtime_asdl::error_code_t error_code;
  int n;
  mops::BigInt n_big;
  value::BashAssoc* cell_val2 = nullptr;
  StackRoot _root0(&lval);
  StackRoot _root1(&val);
  StackRoot _root2(&UP_lval);
  StackRoot _root3(&rval);
  StackRoot _root4(&left_loc);
  StackRoot _root5(&cell);
  StackRoot _root6(&var_frame);
  StackRoot _root7(&UP_cell_val);
  StackRoot _root8(&cell_val2);

  UP_lval = lval;
  switch (lval->tag()) {
    case sh_lvalue_e::Var: {
      LeftName* lval = static_cast<LeftName*>(UP_lval);
      this->SetNamed(lval, val, which_scopes, flags);
    }
      break;
    case sh_lvalue_e::Indexed: {
      sh_lvalue::Indexed* lval = static_cast<sh_lvalue::Indexed*>(UP_lval);
      rval = static_cast<value::Str*>(val);
      left_loc = lval->blame_loc;
      Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup14 = this->_ResolveNameOrRef(lval->name, which_scopes);
      cell = tup14.at0();
      var_frame = tup14.at1();
      if (!cell) {
        this->_BindNewArrayWithEntry(var_frame, lval, rval, flags, left_loc);
        return ;
      }
      if (cell->readonly) {
        e_die(S_kxq, left_loc);
      }
      UP_cell_val = cell->val;
      switch (UP_cell_val->tag()) {
        case value_e::Undef: {
          this->_BindNewArrayWithEntry(var_frame, lval, rval, flags, left_loc);
          return ;
        }
          break;
        case value_e::Str: {
          e_die(S_Crq, left_loc);
        }
          break;
        case value_e::InternalStringArray: {
          value::InternalStringArray* cell_val = static_cast<value::InternalStringArray*>(UP_cell_val);
          error_code = bash_impl::InternalStringArray_SetElement(cell_val, lval->index, rval->s);
          if (error_code == error_code_e::IndexOutOfRange) {
            n = bash_impl::InternalStringArray_Length(cell_val);
            e_die(StrFormat("Index %d is out of bounds for array of length %d", lval->index, n), left_loc);
          }
          return ;
        }
          break;
        case value_e::BashArray: {
          value::BashArray* lhs_sp = static_cast<value::BashArray*>(UP_cell_val);
          error_code = bash_impl::BashArray_SetElement(lhs_sp, mops::IntWiden(lval->index), rval->s);
          if (error_code == error_code_e::IndexOutOfRange) {
            n_big = bash_impl::BashArray_Length(lhs_sp);
            e_die(StrFormat("Index %d is out of bounds for array of length %s", lval->index, mops::ToStr(n_big)), left_loc);
          }
          return ;
        }
          break;
      }
      e_die(StrFormat("Value of type %s can't be indexed", ui::ValType(cell->val)), left_loc);
    }
      break;
    case sh_lvalue_e::Keyed: {
      sh_lvalue::Keyed* lval = static_cast<sh_lvalue::Keyed*>(UP_lval);
      rval = static_cast<value::Str*>(val);
      left_loc = lval->blame_loc;
      Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup15 = this->_ResolveNameOrRef(lval->name, which_scopes);
      cell = tup15.at0();
      var_frame = tup15.at1();
      if (cell->readonly) {
        e_die(S_zFl, left_loc);
      }
      cell_val2 = static_cast<value::BashAssoc*>(cell->val);
      bash_impl::BashAssoc_SetElement(cell_val2, lval->key, rval->s);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void Mem::_BindNewArrayWithEntry(Dict<BigStr*, runtime_asdl::Cell*>* var_frame, sh_lvalue::Indexed* lval, value::Str* val, int flags, syntax_asdl::loc_t* blame_loc) {
  value::BashArray* new_value = nullptr;
  runtime_asdl::error_code_t error_code;
  bool readonly;
  StackRoot _root0(&var_frame);
  StackRoot _root1(&lval);
  StackRoot _root2(&val);
  StackRoot _root3(&blame_loc);
  StackRoot _root4(&new_value);

  new_value = bash_impl::BashArray_New();
  error_code = bash_impl::BashArray_SetElement(new_value, mops::IntWiden(lval->index), val->s);
  if (error_code == error_code_e::IndexOutOfRange) {
    e_die(S_Aam, blame_loc);
  }
  readonly = to_bool((flags & SetReadOnly));
  var_frame->set(lval->name, Alloc<Cell>(false, readonly, false, new_value));
}

void Mem::InternalSetGlobal(BigStr* name, value_asdl::value_t* new_val) {
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&new_val);
  StackRoot _root2(&cell);

  cell = this->var_stack->at(0)->at(name);
  cell->val = new_val;
}

value_asdl::value_t* Mem::GetValue(BigStr* name, runtime_asdl::scope_t which_scopes) {
  List<BigStr*>* strs2 = nullptr;
  List<value_asdl::value_t*>* items = nullptr;
  value_asdl::regex_match_t* top_match = nullptr;
  List<BigStr*>* groups = nullptr;
  value_asdl::RegexMatch* m = nullptr;
  List<BigStr*>* strs = nullptr;
  syntax_asdl::debug_frame_t* UP_frame = nullptr;
  BigStr* source_str = nullptr;
  syntax_asdl::Token* invoke_token = nullptr;
  double f;
  bool ok;
  mops::BigInt big_int;
  runtime_asdl::Cell* cell = nullptr;
  value_asdl::value_t* builtin_val = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&strs2);
  StackRoot _root2(&items);
  StackRoot _root3(&top_match);
  StackRoot _root4(&groups);
  StackRoot _root5(&m);
  StackRoot _root6(&strs);
  StackRoot _root7(&UP_frame);
  StackRoot _root8(&source_str);
  StackRoot _root9(&invoke_token);
  StackRoot _root10(&cell);
  StackRoot _root11(&builtin_val);

  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForReading();
  }
  switch (len(name)) {
    case 1: {
      if (str_equals_c(name, "_", 1)) {
        return Alloc<value::Str>(this->last_arg);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 6: {
      if (str_equals_c(name, "_error", 6)) {
        return this->TryError();
      }
      else if (str_equals_c(name, "LINENO", 6)) {
        this->line_num->s = str(this->token_for_line->line->line_num);
        return this->line_num;
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 7: {
      if (str_equals_c(name, "_status", 7)) {
        return num::ToBig(this->TryStatus());
      }
      else if (str_equals_c(name, "BASHPID", 7)) {
        return Alloc<value::Str>(str(posix::getpid()));
      }
      else if (str_equals_c(name, "SECONDS", 7)) {
        f = (time_::time() - this->seconds_start);
        Tuple2<bool, mops::BigInt> tup16 = mops::FromFloat(f);
        ok = tup16.at0();
        big_int = tup16.at1();
        return Alloc<value::Int>(big_int);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 8: {
      if (str_equals_c(name, "FUNCNAME", 8)) {
        strs = Alloc<List<BigStr*>>();
        for (ReverseListIter<syntax_asdl::debug_frame_t*> it(this->debug_stack); !it.Done(); it.Next()) {
          syntax_asdl::debug_frame_t* frame = it.Value();
          StackRoot _for(&frame        );
          UP_frame = frame;
          switch (frame->tag()) {
            case debug_frame_e::ProcLike: {
              debug_frame::ProcLike* frame = static_cast<debug_frame::ProcLike*>(UP_frame);
              strs->append(frame->proc_name);
            }
              break;
            case debug_frame_e::Source: {
              strs->append(S_cmd);
            }
              break;
            case debug_frame_e::MainFile: {
              strs->append(S_sDc);
            }
              break;
            default: {
              ;  // pass
            }
          }
        }
        return Alloc<value::InternalStringArray>(strs);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 9: {
      if (str_equals_c(name, "_this_dir", 9)) {
        if (len(this->this_dir) == 0) {
          return value::Undef;
        }
        else {
          return Alloc<value::Str>(this->this_dir->at(-1));
        }
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 10: {
      if (str_equals_c(name, "PIPESTATUS", 10)) {
        strs2 = Alloc<List<BigStr*>>();
        for (ListIter<int> it(this->pipe_status->at(-1)); !it.Done(); it.Next()) {
          int i = it.Value();
          strs2->append(str(i));
        }
        return Alloc<value::InternalStringArray>(strs2);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 11: {
      if (str_equals_c(name, "BASH_SOURCE", 11)) {
        strs = Alloc<List<BigStr*>>();
        for (ReverseListIter<syntax_asdl::debug_frame_t*> it(this->debug_stack); !it.Done(); it.Next()) {
          syntax_asdl::debug_frame_t* frame = it.Value();
          StackRoot _for(&frame        );
          UP_frame = frame;
          switch (frame->tag()) {
            case debug_frame_e::ProcLike: {
              debug_frame::ProcLike* frame = static_cast<debug_frame::ProcLike*>(UP_frame);
              source_str = ui::GetLineSourceString(frame->def_tok->line);
              strs->append(source_str);
            }
              break;
            case debug_frame_e::Source: {
              debug_frame::Source* frame = static_cast<debug_frame::Source*>(UP_frame);
              strs->append(frame->source_name);
            }
              break;
            case debug_frame_e::MainFile: {
              debug_frame::MainFile* frame = static_cast<debug_frame::MainFile*>(UP_frame);
              strs->append(frame->main_filename);
            }
              break;
            default: {
              ;  // pass
            }
          }
        }
        return Alloc<value::InternalStringArray>(strs);
      }
      else if (str_equals_c(name, "BASH_LINENO", 11)) {
        strs = Alloc<List<BigStr*>>();
        for (ReverseListIter<syntax_asdl::debug_frame_t*> it(this->debug_stack); !it.Done(); it.Next()) {
          syntax_asdl::debug_frame_t* frame = it.Value();
          StackRoot _for(&frame        );
          UP_frame = frame;
          switch (frame->tag()) {
            case debug_frame_e::ProcLike: {
              debug_frame::ProcLike* frame = static_cast<debug_frame::ProcLike*>(UP_frame);
              invoke_token = location::LeftTokenForCompoundWord(frame->invoke_loc);
              strs->append(_LineNumber(invoke_token));
            }
              break;
            case debug_frame_e::Source: {
              debug_frame::Source* frame = static_cast<debug_frame::Source*>(UP_frame);
              invoke_token = location::LeftTokenForCompoundWord(frame->source_loc);
              strs->append(_LineNumber(invoke_token));
            }
              break;
            case debug_frame_e::MainFile: {
              strs->append(S_wfw);
            }
              break;
            default: {
              ;  // pass
            }
          }
        }
        return Alloc<value::InternalStringArray>(strs);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 12: {
      if (str_equals_c(name, "BASH_REMATCH", 12)) {
        top_match = this->regex_match->at(-1);
        switch (top_match->tag()) {
          case regex_match_e::No: {
            groups = Alloc<List<BigStr*>>();
          }
            break;
          case regex_match_e::Yes: {
            m = static_cast<RegexMatch*>(top_match);
            groups = util::RegexGroupStrings(m->s, m->indices);
          }
            break;
        }
        return Alloc<value::InternalStringArray>(groups);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 16: {
      if (str_equals_c(name, "_pipeline_status", 16)) {
        items = Alloc<List<value_asdl::value_t*>>();
        for (ListIter<int> it(this->pipe_status->at(-1)); !it.Done(); it.Next()) {
          int i = it.Value();
          items->append(num::ToBig(i));
        }
        return Alloc<value::List>(items);
      }
      else {
        goto str_switch_default;
      }
    }
      break;
    case 19: {
      if (str_equals_c(name, "_process_sub_status", 19)) {
        items = Alloc<List<value_asdl::value_t*>>();
        for (ListIter<int> it(this->process_sub_status->at(-1)); !it.Done(); it.Next()) {
          int i = it.Value();
          items->append(num::ToBig(i));
        }
        return Alloc<value::List>(items);
      }
      else {
        goto str_switch_default;
      }
    }
      break;

    str_switch_default:
    default: {
      Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup17 = this->_ResolveNameOrRef(name, which_scopes);
      cell = tup17.at0();
      if (cell) {
        return cell->val;
      }
      builtin_val = this->builtins->get(name);
      if (builtin_val) {
        return builtin_val;
      }
      return value::Undef;
    }
  }
}

runtime_asdl::Cell* Mem::GetCell(BigStr* name, runtime_asdl::scope_t which_scopes) {
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&cell);

  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForReading();
  }
  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup18 = this->_ResolveNameOnly(name, which_scopes);
  cell = tup18.at0();
  return cell;
}

runtime_asdl::Cell* Mem::GetCellDeref(BigStr* name, runtime_asdl::scope_t which_scopes) {
  runtime_asdl::Cell* cell = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&cell);

  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForReading();
  }
  Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup19 = this->_ResolveNameOrRef(name, which_scopes);
  cell = tup19.at0();
  return cell;
}

bool Mem::Unset(value_asdl::sh_lvalue_t* lval, runtime_asdl::scope_t which_scopes) {
  value_asdl::sh_lvalue_t* UP_lval = nullptr;
  BigStr* var_name = nullptr;
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  BigStr* cell_name = nullptr;
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* UP_val = nullptr;
  runtime_asdl::error_code_t error_code;
  int n;
  mops::BigInt big_length;
  StackRoot _root0(&lval);
  StackRoot _root1(&UP_lval);
  StackRoot _root2(&var_name);
  StackRoot _root3(&cell);
  StackRoot _root4(&var_frame);
  StackRoot _root5(&cell_name);
  StackRoot _root6(&val);
  StackRoot _root7(&UP_val);

  UP_lval = lval;
  switch (lval->tag()) {
    case sh_lvalue_e::Var: {
      LeftName* lval = static_cast<LeftName*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case sh_lvalue_e::Indexed: {
      sh_lvalue::Indexed* lval = static_cast<sh_lvalue::Indexed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    case sh_lvalue_e::Keyed: {
      sh_lvalue::Keyed* lval = static_cast<sh_lvalue::Keyed*>(UP_lval);
      var_name = lval->name;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  if (which_scopes == scope_e::Shopt) {
    which_scopes = this->ScopesForWriting();
  }
  Tuple3<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*, BigStr*> tup20 = this->_ResolveNameOrRef(var_name, which_scopes);
  cell = tup20.at0();
  var_frame = tup20.at1();
  cell_name = tup20.at2();
  if (!cell) {
    return false;
  }
  if (cell->readonly) {
    throw Alloc<error::Runtime>(StrFormat("Can't unset readonly variable %r", var_name));
  }
  switch (lval->tag()) {
    case sh_lvalue_e::Var: {
      mylib::dict_erase(var_frame, cell_name);
    }
      break;
    case sh_lvalue_e::Indexed: {
      sh_lvalue::Indexed* lval = static_cast<sh_lvalue::Indexed*>(UP_lval);
      val = cell->val;
      UP_val = val;
      if (val->tag() == value_e::InternalStringArray) {
        value::InternalStringArray* val = static_cast<value::InternalStringArray*>(UP_val);
        error_code = bash_impl::InternalStringArray_UnsetElement(val, lval->index);
        if (error_code == error_code_e::IndexOutOfRange) {
          n = bash_impl::InternalStringArray_Length(val);
          throw Alloc<error::Runtime>(StrFormat("%s[%d]: Index is out of bounds for array of length %d", var_name, lval->index, n));
        }
      }
      else {
        if (val->tag() == value_e::BashArray) {
          value::BashArray* val = static_cast<value::BashArray*>(UP_val);
          error_code = bash_impl::BashArray_UnsetElement(val, mops::IntWiden(lval->index));
          if (error_code == error_code_e::IndexOutOfRange) {
            big_length = bash_impl::BashArray_Length(val);
            throw Alloc<error::Runtime>(StrFormat("%s[%d]: Index is out of bounds for array of length %s", var_name, lval->index, mops::ToStr(big_length)));
          }
        }
        else {
          throw Alloc<error::Runtime>(StrFormat("%r isn't an array", var_name));
        }
      }
    }
      break;
    case sh_lvalue_e::Keyed: {
      sh_lvalue::Keyed* lval = static_cast<sh_lvalue::Keyed*>(UP_lval);
      val = cell->val;
      UP_val = val;
      value::BashAssoc* val = static_cast<value::BashAssoc*>(UP_val);
      bash_impl::BashAssoc_UnsetElement(val, lval->key);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return true;
}

runtime_asdl::scope_t Mem::ScopesForReading() {
  return this->exec_opts->dynamic_scope() ? scope_e::Dynamic : scope_e::LocalOrGlobal;
}

runtime_asdl::scope_t Mem::ScopesForWriting() {
  return this->exec_opts->dynamic_scope() ? scope_e::Dynamic : scope_e::LocalOnly;
}

bool Mem::ClearFlag(BigStr* name, int flag) {
  runtime_asdl::Cell* cell = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* var_frame = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&cell);
  StackRoot _root2(&var_frame);

  Tuple2<runtime_asdl::Cell*, Dict<BigStr*, runtime_asdl::Cell*>*> tup21 = this->_ResolveNameOnly(name, this->ScopesForReading());
  cell = tup21.at0();
  var_frame = tup21.at1();
  if (cell) {
    if ((flag & ClearExport)) {
      cell->exported = false;
    }
    if ((flag & ClearNameref)) {
      cell->nameref = false;
    }
    return true;
  }
  else {
    return false;
  }
}

void Mem::_FillWithExported(Dict<BigStr*, BigStr*>* new_env) {
  value::Str* val = nullptr;
  StackRoot _root0(&new_env);
  StackRoot _root1(&val);

  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* scope = it.Value();
    StackRoot _for(&scope  );
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(scope); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      runtime_asdl::Cell* cell = it.Value();
      if ((cell->exported and cell->val->tag() == value_e::Str)) {
        val = static_cast<value::Str*>(cell->val);
        new_env->set(name, val->s);
      }
    }
  }
}

void Mem::_FillEnvObj(Dict<BigStr*, BigStr*>* new_env, value_asdl::Obj* env_object) {
  StackRoot _root0(&new_env);
  StackRoot _root1(&env_object);

  if (env_object->prototype != nullptr) {
    this->_FillEnvObj(new_env, env_object->prototype);
  }
  for (DictIter<BigStr*, value_asdl::value_t*> it(env_object->d); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    value_asdl::value_t* val = it.Value();
    if (val->tag() != value_e::Str) {
      continue;
    }
    new_env->set(name, static_cast<value::Str*>(val)->s);
  }
}

Dict<BigStr*, BigStr*>* Mem::GetEnv() {
  Dict<BigStr*, BigStr*>* new_env = nullptr;
  StackRoot _root0(&new_env);

  new_env = Alloc<Dict<BigStr*, BigStr*>>();
  if (!this->exec_opts->no_exported()) {
    this->_FillWithExported(new_env);
  }
  if (this->exec_opts->env_obj()) {
    this->_FillEnvObj(new_env, this->env_object);
  }
  return new_env;
}

List<BigStr*>* Mem::VarNames() {
  List<BigStr*>* ret = nullptr;
  StackRoot _root0(&ret);

  ret = Alloc<List<BigStr*>>();
  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* scope = it.Value();
    StackRoot _for(&scope  );
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(scope); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      StackRoot _for(&name    );
      ret->append(name);
    }
  }
  return ret;
}

List<BigStr*>* Mem::VarNamesStartingWith(BigStr* prefix) {
  List<BigStr*>* names = nullptr;
  StackRoot _root0(&prefix);
  StackRoot _root1(&names);

  names = Alloc<List<BigStr*>>();
  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* scope = it.Value();
    StackRoot _for(&scope  );
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(scope); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      StackRoot _for(&name    );
      if (name->startswith(prefix)) {
        names->append(name);
      }
    }
  }
  return names;
}

Dict<BigStr*, BigStr*>* Mem::GetAllVars() {
  Dict<BigStr*, BigStr*>* result = nullptr;
  value_asdl::value_t* val = nullptr;
  value::Str* str_val = nullptr;
  StackRoot _root0(&result);
  StackRoot _root1(&val);
  StackRoot _root2(&str_val);

  result = Alloc<Dict<BigStr*, BigStr*>>();
  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(this->var_stack); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* scope = it.Value();
    StackRoot _for(&scope  );
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(scope); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      runtime_asdl::Cell* cell = it.Value();
      val = cell->val;
      if (val->tag() == value_e::Str) {
        str_val = static_cast<value::Str*>(val);
        result->set(name, str_val->s);
      }
    }
  }
  return result;
}

Dict<BigStr*, runtime_asdl::Cell*>* Mem::GetAllCells(runtime_asdl::scope_t which_scopes) {
  Dict<BigStr*, runtime_asdl::Cell*>* result = nullptr;
  List<Dict<BigStr*, runtime_asdl::Cell*>*>* scopes = nullptr;
  StackRoot _root0(&result);
  StackRoot _root1(&scopes);

  result = Alloc<Dict<BigStr*, runtime_asdl::Cell*>>();
  if (which_scopes == scope_e::Dynamic) {
    scopes = this->var_stack;
  }
  else {
    if (which_scopes == scope_e::LocalOnly) {
      scopes = this->var_stack->slice(-1);
    }
    else {
      if (which_scopes == scope_e::GlobalOnly) {
        scopes = this->var_stack->slice(0, 1);
      }
      else {
        if (which_scopes == scope_e::LocalOrGlobal) {
          scopes = NewList<Dict<BigStr*, runtime_asdl::Cell*>*>(std::initializer_list<Dict<BigStr*, runtime_asdl::Cell*>*>{this->var_stack->at(0)});
          if (len(this->var_stack) > 1) {
            scopes->append(this->var_stack->at(-1));
          }
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
  }
  for (ListIter<Dict<BigStr*, runtime_asdl::Cell*>*> it(scopes); !it.Done(); it.Next()) {
    Dict<BigStr*, runtime_asdl::Cell*>* scope = it.Value();
    StackRoot _for(&scope  );
    for (DictIter<BigStr*, runtime_asdl::Cell*> it(scope); !it.Done(); it.Next()) {
      BigStr* name = it.Key();
      runtime_asdl::Cell* cell = it.Value();
      result->set(name, cell);
    }
  }
  return result;
}

void Mem::SetRegexMatch(value_asdl::regex_match_t* match) {
  StackRoot _root0(&match);

  this->regex_match->set(-1, match);
}

value_asdl::regex_match_t* Mem::GetRegexMatch() {
  return this->regex_match->at(-1);
}

void Mem::PushContextStack(Dict<BigStr*, value_asdl::value_t*>* context) {
  StackRoot _root0(&context);

  this->ctx_stack->append(context);
}

Dict<BigStr*, value_asdl::value_t*>* Mem::GetContext() {
  if (len(this->ctx_stack)) {
    return this->ctx_stack->at(-1);
  }
  return nullptr;
}

Dict<BigStr*, value_asdl::value_t*>* Mem::PopContextStack() {
  return this->ctx_stack->pop();
}

Tuple2<value_asdl::value_t*, value_asdl::Obj*> ValueIsInvokableObj(value_asdl::value_t* val) {
  value_asdl::Obj* obj = nullptr;
  value_asdl::value_t* invoke_val = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&obj);
  StackRoot _root2(&invoke_val);

  if (val->tag() != value_e::Obj) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(nullptr, nullptr);
  }
  obj = static_cast<Obj*>(val);
  if (!obj->prototype) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(nullptr, nullptr);
  }
  invoke_val = obj->prototype->d->get(S_fBo);
  if (invoke_val == nullptr) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(nullptr, nullptr);
  }
  if ((invoke_val->tag() == value_e::Proc || invoke_val->tag() == value_e::BuiltinProc)) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(invoke_val, obj);
  }
  return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(nullptr, nullptr);
}

void _AddNames(Dict<BigStr*, bool>* unique, Dict<BigStr*, runtime_asdl::Cell*>* frame) {
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* proc = nullptr;
  StackRoot _root0(&unique);
  StackRoot _root1(&frame);
  StackRoot _root2(&val);
  StackRoot _root3(&proc);

  for (DictIter<BigStr*, runtime_asdl::Cell*> it(frame); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    StackRoot _for(&name  );
    val = frame->at(name)->val;
    if (val->tag() == value_e::Proc) {
      unique->set(name, true);
    }
    Tuple2<value_asdl::value_t*, value_asdl::Obj*> tup22 = ValueIsInvokableObj(val);
    proc = tup22.at0();
    if (proc != nullptr) {
      unique->set(name, true);
    }
  }
}

Procs::Procs(state::Mem* mem) {
  this->mem = mem;
  this->sh_funcs = Alloc<Dict<BigStr*, value::Proc*>>();
}

void Procs::DefineShellFunc(BigStr* name, value::Proc* proc) {
  StackRoot _root0(&name);
  StackRoot _root1(&proc);

  this->sh_funcs->set(name, proc);
}

bool Procs::IsShellFunc(BigStr* name) {
  StackRoot _root0(&name);

  return dict_contains(this->sh_funcs, name);
}

value::Proc* Procs::GetShellFunc(BigStr* name) {
  StackRoot _root0(&name);

  return this->sh_funcs->get(name);
}

void Procs::EraseShellFunc(BigStr* to_del) {
  StackRoot _root0(&to_del);

  mylib::dict_erase(this->sh_funcs, to_del);
}

List<BigStr*>* Procs::ShellFuncNames() {
  List<BigStr*>* names = nullptr;
  StackRoot _root0(&names);

  names = this->sh_funcs->keys();
  names->sort();
  return names;
}

void Procs::DefineProc(BigStr* name, value::Proc* proc) {
  StackRoot _root0(&name);
  StackRoot _root1(&proc);

  this->mem->var_stack->at(-1)->set(name, Alloc<Cell>(false, false, false, proc));
}

bool Procs::IsProc(BigStr* name) {
  value_asdl::value_t* maybe_proc = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&maybe_proc);

  maybe_proc = this->mem->GetValue(name);
  return maybe_proc->tag() == value_e::Proc;
}

bool Procs::IsInvokableObj(BigStr* name) {
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* proc = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&val);
  StackRoot _root2(&proc);

  val = this->mem->GetValue(name);
  Tuple2<value_asdl::value_t*, value_asdl::Obj*> tup23 = ValueIsInvokableObj(val);
  proc = tup23.at0();
  return proc != nullptr;
}

List<BigStr*>* Procs::InvokableNames() {
  Dict<BigStr*, bool>* unique = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* top_frame = nullptr;
  Dict<BigStr*, runtime_asdl::Cell*>* global_frame = nullptr;
  List<BigStr*>* names = nullptr;
  StackRoot _root0(&unique);
  StackRoot _root1(&top_frame);
  StackRoot _root2(&global_frame);
  StackRoot _root3(&names);

  unique = Alloc<Dict<BigStr*, bool>>();
  for (DictIter<BigStr*, value::Proc*> it(this->sh_funcs); !it.Done(); it.Next()) {
    BigStr* name = it.Key();
    StackRoot _for(&name  );
    unique->set(name, true);
  }
  top_frame = this->mem->var_stack->at(-1);
  _AddNames(unique, top_frame);
  global_frame = this->mem->var_stack->at(0);
  if (global_frame != top_frame) {
    _AddNames(unique, global_frame);
  }
  names = unique->keys();
  names->sort();
  return names;
}

Tuple2<value_asdl::value_t*, value_asdl::Obj*> Procs::GetInvokable(BigStr* name) {
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* proc = nullptr;
  value_asdl::Obj* self_val = nullptr;
  StackRoot _root0(&name);
  StackRoot _root1(&val);
  StackRoot _root2(&proc);
  StackRoot _root3(&self_val);

  val = this->mem->GetValue(name);
  if (val->tag() == value_e::Proc) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(static_cast<value::Proc*>(val), nullptr);
  }
  Tuple2<value_asdl::value_t*, value_asdl::Obj*> tup24 = ValueIsInvokableObj(val);
  proc = tup24.at0();
  self_val = tup24.at1();
  if (proc) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(proc, self_val);
  }
  if (dict_contains(this->sh_funcs, name)) {
    return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(this->sh_funcs->at(name), nullptr);
  }
  return Tuple2<value_asdl::value_t*, value_asdl::Obj*>(nullptr, nullptr);
}

void OshLanguageSetValue(state::Mem* mem, value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val, int flags) {
  runtime_asdl::scope_t which_scopes;
  StackRoot _root0(&mem);
  StackRoot _root1(&lval);
  StackRoot _root2(&val);

  which_scopes = mem->ScopesForWriting();
  mem->SetValue(lval, val, which_scopes, flags);
}

void BuiltinSetValue(state::Mem* mem, value_asdl::sh_lvalue_t* lval, value_asdl::value_t* val) {
  StackRoot _root0(&mem);
  StackRoot _root1(&lval);
  StackRoot _root2(&val);

  mem->SetValue(lval, val, mem->ScopesForWriting());
}

void BuiltinSetString(state::Mem* mem, BigStr* name, BigStr* s) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&s);

  BuiltinSetValue(mem, location::LName(name), Alloc<value::Str>(s));
}

void BuiltinSetArray(state::Mem* mem, BigStr* name, List<BigStr*>* a) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&a);

  BuiltinSetValue(mem, location::LName(name), bash_impl::BashArray_FromList(a));
}

void SetGlobalString(state::Mem* mem, BigStr* name, BigStr* s) {
  value::Str* val = nullptr;
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&s);
  StackRoot _root3(&val);

  val = Alloc<value::Str>(s);
  mem->SetNamed(location::LName(name), val, scope_e::GlobalOnly);
}

void SetGlobalArray(state::Mem* mem, BigStr* name, List<BigStr*>* a) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&a);

  mem->SetNamed(location::LName(name), bash_impl::BashArray_FromList(a), scope_e::GlobalOnly);
}

void SetGlobalValue(state::Mem* mem, BigStr* name, value_asdl::value_t* val) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&val);

  mem->SetNamed(location::LName(name), val, scope_e::GlobalOnly);
}

void SetLocalValue(state::Mem* mem, BigStr* name, value_asdl::value_t* val) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&val);

  mem->SetNamed(location::LName(name), val, scope_e::LocalOnly);
}

void ExportGlobalString(state::Mem* mem, BigStr* name, BigStr* s) {
  value::Str* val = nullptr;
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&s);
  StackRoot _root3(&val);

  val = Alloc<value::Str>(s);
  mem->SetNamed(location::LName(name), val, scope_e::GlobalOnly, SetExport);
}

void SetStringInEnv(state::Mem* mem, BigStr* var_name, BigStr* s) {
  StackRoot _root0(&mem);
  StackRoot _root1(&var_name);
  StackRoot _root2(&s);

  if (mem->exec_opts->env_obj()) {
    mem->env_dict->set(var_name, Alloc<value::Str>(s));
  }
  else {
    SetGlobalString(mem, var_name, s);
  }
}

value_asdl::value_t* DynamicGetVar(state::Mem* mem, BigStr* name, runtime_asdl::scope_t which_scopes) {
  value_asdl::value_t* val = nullptr;
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&val);

  val = mem->GetValue(name, which_scopes);
  if (val->tag() == value_e::Undef) {
    return value::Null;
  }
  return val;
}

BigStr* GetString(state::Mem* mem, BigStr* name) {
  value_asdl::value_t* val = nullptr;
  value_asdl::value_t* UP_val = nullptr;
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&val);
  StackRoot _root3(&UP_val);

  val = mem->GetValue(name);
  UP_val = val;
  switch (val->tag()) {
    case value_e::Undef: {
      throw Alloc<error::Runtime>(StrFormat("$%s isn't defined", name));
    }
      break;
    case value_e::Str: {
      return static_cast<value::Str*>(UP_val)->s;
    }
      break;
    default: {
      throw Alloc<error::Runtime>(StrFormat("$%s should be a string", name));
    }
  }
}

BigStr* MaybeString(state::Mem* mem, BigStr* name) {
  StackRoot _root0(&mem);
  StackRoot _root1(&name);

  try {
    return GetString(mem, name);
  }
  catch (error::Runtime*) {
    return nullptr;
  }
}

int GetInteger(state::Mem* mem, BigStr* name) {
  value_asdl::value_t* val = nullptr;
  BigStr* s = nullptr;
  int i;
  StackRoot _root0(&mem);
  StackRoot _root1(&name);
  StackRoot _root2(&val);
  StackRoot _root3(&s);

  val = mem->GetValue(name);
  if (val->tag() != value_e::Str) {
    throw Alloc<error::Runtime>(StrFormat("$%s should be a string, got %s", name, ui::ValType(val)));
  }
  s = static_cast<value::Str*>(val)->s;
  try {
    i = to_int(s);
  }
  catch (ValueError*) {
    throw Alloc<error::Runtime>(StrFormat("$%s doesn't look like an integer, got %r", name, s));
  }
  return i;
}

}  // define namespace state

namespace util {  // define


List<BigStr*>* RegexGroupStrings(BigStr* s, List<int>* indices) {
  List<BigStr*>* groups = nullptr;
  int n;
  int start;
  int end;
  StackRoot _root0(&s);
  StackRoot _root1(&indices);
  StackRoot _root2(&groups);

  groups = Alloc<List<BigStr*>>();
  n = len(indices);
  for (int i = 0; i < (n / 2); ++i) {
    start = indices->at((2 * i));
    end = indices->at(((2 * i) + 1));
    if (start == -1) {
      groups->append(S_Aoo);
    }
    else {
      groups->append(s->slice(start, end));
    }
  }
  return groups;
}

List<BigStr*>* RegexSearch(BigStr* pat, BigStr* s) {
  List<int>* indices = nullptr;
  StackRoot _root0(&pat);
  StackRoot _root1(&s);
  StackRoot _root2(&indices);

  indices = libc::regex_search(pat, 0, s, 0);
  if (indices == nullptr) {
    return nullptr;
  }
  return RegexGroupStrings(s, indices);
}

UserExit::UserExit(int status) {
  this->status = status;
}

HistoryError::HistoryError(BigStr* msg) {
  this->msg = msg;
}

BigStr* HistoryError::UserErrorString() {
  return StrFormat("history: %s", this->msg);
}

_DebugFile::_DebugFile() {
  ;  // pass
}

void _DebugFile::write(BigStr* s) {
  StackRoot _root0(&s);

  ;  // pass
}

void _DebugFile::writeln(BigStr* s) {
  StackRoot _root0(&s);

  ;  // pass
}

bool _DebugFile::isatty() {
  return false;
}

NullDebugFile::NullDebugFile() : ::util::_DebugFile() {
}

DebugFile::DebugFile(mylib::Writer* f) : ::util::_DebugFile() {
  this->f = f;
}

void DebugFile::write(BigStr* s) {
  StackRoot _root0(&s);

  this->f->write(s);
}

void DebugFile::writeln(BigStr* s) {
  StackRoot _root0(&s);

  this->write(str_concat(s, S_nfs));
  this->f->flush();
}

bool DebugFile::isatty() {
  return this->f->isatty();
}

void PrintTopicHeader(BigStr* topic_id, mylib::Writer* f) {
  StackRoot _root0(&topic_id);
  StackRoot _root1(&f);

  if (f->isatty()) {
    f->write(StrFormat("%s %s %s\n", ansi::REVERSE, topic_id, ansi::RESET));
  }
  else {
    f->write(StrFormat("~~~ %s ~~~\n", topic_id));
  }
  f->write(S_nfs);
}

bool PrintEmbeddedHelp(pyutil::_ResourceLoader* loader, BigStr* topic_id, mylib::Writer* f) {
  BigStr* contents = nullptr;
  StackRoot _root0(&loader);
  StackRoot _root1(&topic_id);
  StackRoot _root2(&f);
  StackRoot _root3(&contents);

  try {
    contents = loader->Get(StrFormat("_devbuild/help/%s", topic_id));
  }
  catch (IOError_OSError*) {
    return false;
  }
  PrintTopicHeader(topic_id, f);
  f->write(contents);
  f->write(S_nfs);
  return true;
}

void _PrintVersionLine(pyutil::_ResourceLoader* loader, mylib::Writer* f) {
  BigStr* v = nullptr;
  StackRoot _root0(&loader);
  StackRoot _root1(&f);
  StackRoot _root2(&v);

  v = pyutil::GetVersion(loader);
  f->write(StrFormat("Oils %s\t\thttps://oils.pub/\n", v));
}

void HelpFlag(pyutil::_ResourceLoader* loader, BigStr* topic_id, mylib::Writer* f) {
  bool found;
  StackRoot _root0(&loader);
  StackRoot _root1(&topic_id);
  StackRoot _root2(&f);

  _PrintVersionLine(loader, f);
  f->write(S_nfs);
  found = PrintEmbeddedHelp(loader, topic_id, f);
  found = PrintEmbeddedHelp(loader, S_ulj, f);
}

void VersionFlag(pyutil::_ResourceLoader* loader, mylib::Writer* f) {
  StackRoot _root0(&loader);
  StackRoot _root1(&f);

  _PrintVersionLine(loader, f);
  f->write(S_nfs);
  pyutil::PrintVersionDetails(loader);
}

}  // define namespace util

namespace j8 {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using nil8_asdl::nvalue;
using nil8_asdl::nvalue_t;
using runtime_asdl::error_code_e;
using value_asdl::value;
using value_asdl::value_e;
using value_asdl::value_t;
using value_asdl::value_str;
using value_asdl::Obj;

BigStr* ValType(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return value_str(val->tag(), false);
}

int ValueId(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  switch (val->tag()) {
    case value_e::Null: 
    case value_e::Bool: 
    case value_e::Int: 
    case value_e::Float: 
    case value_e::Str: {
      return -1;
    }
      break;
    default: {
      return HeapValueId(val);
    }
  }
}

BigStr* ValueIdString(value_asdl::value_t* val) {
  int heap_id;
  StackRoot _root0(&val);

  heap_id = ValueId(val);
  if (heap_id == -1) {
    return S_Aoo;
  }
  else {
    return StrFormat(" 0x%s", mylib::hex_lower(heap_id));
  }
}

BigStr* Utf8Encode(int code) {
  int num_cont_bytes;
  List<int>* bytes_ = nullptr;
  int b;
  List<BigStr*>* tmp = nullptr;
  StackRoot _root0(&bytes_);
  StackRoot _root1(&tmp);

  num_cont_bytes = 0;
  if (code <= 127) {
    return chr((code & 127));
  }
  else {
    if (code <= 2047) {
      num_cont_bytes = 1;
    }
    else {
      if (code <= 65535) {
        num_cont_bytes = 2;
      }
      else {
        num_cont_bytes = 3;
      }
    }
  }
  bytes_ = Alloc<List<int>>();
  for (int _ = 0; _ < num_cont_bytes; ++_) {
    bytes_->append((128 | (code & 63)));
    code >>= 6;
  }
  b = ((30 << (6 - num_cont_bytes)) | (code & (63 >> num_cont_bytes)));
  bytes_->append(b);
  bytes_->reverse();
  tmp = Alloc<List<BigStr*>>();
  for (ListIter<int> it(bytes_); !it.Done(); it.Next()) {
    int b = it.Value();
    tmp->append(chr((b & 255)));
  }
  return S_Aoo->join(tmp);
}
int SHOW_CYCLES = (1 << 1);
int LOSSY_JSON_STRINGS = (1 << 3);
int INF_NAN_ARE_NULL = (1 << 4);
int NON_DATA_IS_NULL = (1 << 6);
int NON_DATA_IS_ERROR = (1 << 7);

void _Print(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, int options) {
  j8::InstancePrinter* p = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&buf);
  StackRoot _root2(&p);

  p = Alloc<InstancePrinter>(buf, indent, options);
  p->Print(val);
}

void PrintMessage(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, bool type_errors) {
  int options;
  StackRoot _root0(&val);
  StackRoot _root1(&buf);

  options = 0;
  if (type_errors) {
    options |= NON_DATA_IS_ERROR;
  }
  else {
    options |= NON_DATA_IS_NULL;
  }
  _Print(val, buf, indent, options);
}

void PrintJsonMessage(value_asdl::value_t* val, mylib::BufWriter* buf, int indent, bool type_errors) {
  int options;
  StackRoot _root0(&val);
  StackRoot _root1(&buf);

  options = (LOSSY_JSON_STRINGS | INF_NAN_ARE_NULL);
  if (type_errors) {
    options |= NON_DATA_IS_ERROR;
  }
  else {
    options |= NON_DATA_IS_NULL;
  }
  _Print(val, buf, indent, options);
}

void PrintLine(value_asdl::value_t* val, mylib::Writer* f) {
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&f);
  StackRoot _root2(&buf);

  buf = Alloc<mylib::BufWriter>();
  _Print(val, buf, -1, SHOW_CYCLES);
  f->write(buf->getvalue());
  f->write(S_nfs);
}

void EncodeString(BigStr* s, mylib::BufWriter* buf, bool unquoted_ok) {
  StackRoot _root0(&s);
  StackRoot _root1(&buf);

  if ((unquoted_ok and fastfunc::CanOmitQuotes(s))) {
    buf->write(s);
    return ;
  }
  _Print(Alloc<value::Str>(s), buf, -1);
}

BigStr* MaybeEncodeString(BigStr* s) {
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&buf);

  buf = Alloc<mylib::BufWriter>();
  _Print(Alloc<value::Str>(s), buf, -1);
  return buf->getvalue();
}

BigStr* MaybeEncodeJsonString(BigStr* s) {
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&buf);

  buf = Alloc<mylib::BufWriter>();
  _Print(Alloc<value::Str>(s), buf, -1, LOSSY_JSON_STRINGS);
  return buf->getvalue();
}

InstancePrinter::InstancePrinter(mylib::BufWriter* buf, int indent, int options) {
  this->buf = buf;
  this->indent = indent;
  this->options = options;
  this->visiting = Alloc<Dict<int, bool>>();
}

void InstancePrinter::_ItemIndent(int level) {
  if (this->indent == -1) {
    return ;
  }
  this->buf->write_spaces(((level + 1) * this->indent));
}

void InstancePrinter::_BracketIndent(int level) {
  if (this->indent == -1) {
    return ;
  }
  this->buf->write_spaces((level * this->indent));
}

void InstancePrinter::_MaybeNewline() {
  if (this->indent == -1) {
    return ;
  }
  this->buf->write(S_nfs);
}

void InstancePrinter::_MaybeSpace() {
  if (this->indent == -1) {
    return ;
  }
  this->buf->write(S_yfw);
}

void InstancePrinter::_PrintList(value::List* val, int level) {
  int i;
  StackRoot _root0(&val);

  if (len(val->items) == 0) {
    this->buf->write(S_xmu);
  }
  else {
    this->buf->write(S_Eax);
    this->_MaybeNewline();
    i = 0;
    for (ListIter<value_asdl::value_t*> it(val->items); !it.Done(); it.Next(), ++i) {
      value_asdl::value_t* item = it.Value();
      StackRoot _for(&item    );
      if (i != 0) {
        this->buf->write(S_Cce);
        this->_MaybeNewline();
      }
      this->_ItemIndent(level);
      this->Print(item, (level + 1));
    }
    this->_MaybeNewline();
    this->_BracketIndent(level);
    this->buf->write(S_pcD);
  }
}

void InstancePrinter::_PrintMapping(Dict<BigStr*, value_asdl::value_t*>* d, BigStr* left, BigStr* right, int level) {
  int i;
  StackRoot _root0(&d);
  StackRoot _root1(&left);
  StackRoot _root2(&right);

  if (len(d) == 0) {
    this->buf->write(left);
    this->buf->write(right);
  }
  else {
    this->buf->write(left);
    this->_MaybeNewline();
    i = 0;
    for (DictIter<BigStr*, value_asdl::value_t*> it(d); !it.Done(); it.Next()) {
      BigStr* k = it.Key();
      value_asdl::value_t* v = it.Value();
      if (i != 0) {
        this->buf->write(S_Cce);
        this->_MaybeNewline();
      }
      this->_ItemIndent(level);
      pyj8::WriteString(k, this->options, this->buf);
      this->buf->write(S_fyj);
      this->_MaybeSpace();
      this->Print(v, (level + 1));
      i += 1;
    }
    this->_MaybeNewline();
    this->_BracketIndent(level);
    this->buf->write(right);
  }
}

void InstancePrinter::_PrintDict(value::Dict* val, int level) {
  StackRoot _root0(&val);

  this->_PrintMapping(val->d, S_ato, S_cEn, level);
}

void InstancePrinter::_PrintObj(value_asdl::Obj* val, int level) {
  StackRoot _root0(&val);

  this->_PrintMapping(val->d, S_ijB, S_hxb, level);
  if (val->prototype) {
    this->buf->write(S_dtA);
    this->_PrintObj(val->prototype, level);
  }
}

void InstancePrinter::_PrintBashPrefix(BigStr* type_str, int level) {
  StackRoot _root0(&type_str);

  this->buf->write(S_ato);
  this->_MaybeNewline();
  this->_ItemIndent(level);
  this->buf->write(S_EDa);
  this->_MaybeSpace();
  this->buf->write(type_str);
  this->_MaybeNewline();
  this->_ItemIndent(level);
  this->buf->write(S_eqo);
  this->_MaybeSpace();
}

void InstancePrinter::_PrintBashSuffix(int level) {
  this->_MaybeNewline();
  this->_BracketIndent(level);
  this->buf->write(S_cEn);
}

void InstancePrinter::_PrintBashArray(value::BashArray* val, int level) {
  int i;
  BigStr* v = nullptr;
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&val);
  StackRoot _root1(&v);

  this->_PrintBashPrefix(S_xbi, level);
  if (bash_impl::BashArray_Count(val) == 0) {
    this->buf->write(S_Fni);
  }
  else {
    this->buf->write(S_ato);
    this->_MaybeNewline();
    i = 0;
    for (ListIter<mops::BigInt> it(bash_impl::BashArray_GetKeys(val)); !it.Done(); it.Next()) {
      mops::BigInt k = it.Value();
      if (i != 0) {
        this->buf->write(S_Cce);
        this->_MaybeNewline();
      }
      this->_ItemIndent((level + 1));
      pyj8::WriteString(mops::ToStr(k), this->options, this->buf);
      this->buf->write(S_fyj);
      this->_MaybeSpace();
      Tuple2<BigStr*, runtime_asdl::error_code_t> tup0 = bash_impl::BashArray_GetElement(val, k);
      v = tup0.at0();
      error_code = tup0.at1();
      pyj8::WriteString(v, this->options, this->buf);
      i += 1;
    }
    this->_MaybeNewline();
    this->_BracketIndent((level + 1));
    this->buf->write(S_cEn);
  }
  this->_PrintBashSuffix(level);
}

void InstancePrinter::_PrintInternalStringArray(value::InternalStringArray* val, int level) {
  bool first;
  int i;
  StackRoot _root0(&val);

  this->_PrintBashPrefix(S_Aav, level);
  if (bash_impl::InternalStringArray_Count(val) == 0) {
    this->buf->write(S_Fni);
  }
  else {
    this->buf->write(S_ato);
    this->_MaybeNewline();
    first = true;
    i = 0;
    for (ListIter<BigStr*> it(bash_impl::InternalStringArray_GetValues(val)); !it.Done(); it.Next(), ++i) {
      BigStr* s = it.Value();
      StackRoot _for(&s    );
      if (s == nullptr) {
        continue;
      }
      if (!first) {
        this->buf->write(S_Cce);
        this->_MaybeNewline();
      }
      this->_ItemIndent((level + 1));
      pyj8::WriteString(str(i), this->options, this->buf);
      this->buf->write(S_fyj);
      this->_MaybeSpace();
      pyj8::WriteString(s, this->options, this->buf);
      first = false;
    }
    this->_MaybeNewline();
    this->_BracketIndent((level + 1));
    this->buf->write(S_cEn);
  }
  this->_PrintBashSuffix(level);
}

void InstancePrinter::_PrintBashAssoc(value::BashAssoc* val, int level) {
  int i;
  StackRoot _root0(&val);

  this->_PrintBashPrefix(S_ojw, level);
  if (bash_impl::BashAssoc_Count(val) == 0) {
    this->buf->write(S_Fni);
  }
  else {
    this->buf->write(S_ato);
    this->_MaybeNewline();
    i = 0;
    for (DictIter<BigStr*, BigStr*> it(bash_impl::BashAssoc_GetDict(val)); !it.Done(); it.Next()) {
      BigStr* k2 = it.Key();
      BigStr* v2 = it.Value();
      if (i != 0) {
        this->buf->write(S_Cce);
        this->_MaybeNewline();
      }
      this->_ItemIndent((level + 1));
      pyj8::WriteString(k2, this->options, this->buf);
      this->buf->write(S_fyj);
      this->_MaybeSpace();
      pyj8::WriteString(v2, this->options, this->buf);
      i += 1;
    }
    this->_MaybeNewline();
    this->_BracketIndent((level + 1));
    this->buf->write(S_cEn);
  }
  this->_PrintBashSuffix(level);
}

void InstancePrinter::Print(value_asdl::value_t* val, int level) {
  value_asdl::value_t* UP_val = nullptr;
  double fl;
  BigStr* s = nullptr;
  int heap_id;
  BigStr* ysh_type = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&UP_val);
  StackRoot _root2(&s);
  StackRoot _root3(&ysh_type);

  UP_val = val;
  switch (val->tag()) {
    case value_e::Null: {
      this->buf->write(S_lbA);
    }
      break;
    case value_e::Bool: {
      value::Bool* val = static_cast<value::Bool*>(UP_val);
      this->buf->write(val->b ? S_FsF : S_Ctn);
    }
      break;
    case value_e::Int: {
      value::Int* val = static_cast<value::Int*>(UP_val);
      this->buf->write(mops::ToStr(val->i));
    }
      break;
    case value_e::Float: {
      value::Float* val = static_cast<value::Float*>(UP_val);
      fl = val->f;
      if (math::isinf(fl)) {
        if ((this->options & INF_NAN_ARE_NULL)) {
          s = S_lbA;
        }
        else {
          s = S_BvB;
          if (fl < 0) {
            s = str_concat(S_Bjq, s);
          }
        }
      }
      else {
        if (math::isnan(fl)) {
          if ((this->options & INF_NAN_ARE_NULL)) {
            s = S_lbA;
          }
          else {
            s = S_ywk;
          }
        }
        else {
          s = str(fl);
        }
      }
      this->buf->write(s);
    }
      break;
    case value_e::Str: {
      value::Str* val = static_cast<value::Str*>(UP_val);
      pyj8::WriteString(val->s, this->options, this->buf);
    }
      break;
    case value_e::List: {
      value::List* val = static_cast<value::List*>(UP_val);
      heap_id = HeapValueId(val);
      if (this->visiting->get(heap_id, false)) {
        if ((this->options & SHOW_CYCLES)) {
          this->buf->write(S_Aek);
          return ;
        }
        else {
          throw Alloc<error::Encode>(StrFormat("Can't encode List%s in object cycle", ValueIdString(val)));
        }
      }
      else {
        this->visiting->set(heap_id, true);
        this->_PrintList(val, level);
        this->visiting->set(heap_id, false);
      }
    }
      break;
    case value_e::Dict: {
      value::Dict* val = static_cast<value::Dict*>(UP_val);
      heap_id = HeapValueId(val);
      if (this->visiting->get(heap_id, false)) {
        if ((this->options & SHOW_CYCLES)) {
          this->buf->write(S_qnA);
          return ;
        }
        else {
          throw Alloc<error::Encode>(StrFormat("Can't encode Dict%s in object cycle", ValueIdString(val)));
        }
      }
      else {
        this->visiting->set(heap_id, true);
        this->_PrintDict(val, level);
        this->visiting->set(heap_id, false);
      }
    }
      break;
    case value_e::Obj: {
      Obj* val = static_cast<Obj*>(UP_val);
      if ((this->options & NON_DATA_IS_ERROR)) {
        throw Alloc<error::Encode>(S_kdC);
      }
      else {
        if ((this->options & NON_DATA_IS_NULL)) {
          this->buf->write(S_lbA);
          return ;
        }
      }
      heap_id = HeapValueId(val);
      if (this->visiting->get(heap_id, false)) {
        if ((this->options & SHOW_CYCLES)) {
          this->buf->write(S_Ehr);
          return ;
        }
        else {
          throw Alloc<error::Encode>(StrFormat("Can't encode Obj%s in object cycle", ValueIdString(val)));
        }
      }
      else {
        this->visiting->set(heap_id, true);
        this->_PrintObj(val, level);
        this->visiting->set(heap_id, false);
      }
    }
      break;
    case value_e::BashArray: {
      value::BashArray* val = static_cast<value::BashArray*>(UP_val);
      this->_PrintBashArray(val, level);
    }
      break;
    case value_e::InternalStringArray: {
      value::InternalStringArray* val = static_cast<value::InternalStringArray*>(UP_val);
      this->_PrintInternalStringArray(val, level);
    }
      break;
    case value_e::BashAssoc: {
      value::BashAssoc* val = static_cast<value::BashAssoc*>(UP_val);
      this->_PrintBashAssoc(val, level);
    }
      break;
    default: {
      ;  // pass
      if ((this->options & NON_DATA_IS_ERROR)) {
        throw Alloc<error::Encode>(StrFormat("Can't serialize object of type %s", ValType(val)));
      }
      else {
        if ((this->options & NON_DATA_IS_NULL)) {
          this->buf->write(S_lbA);
        }
        else {
          ysh_type = ValType(val);
          this->buf->write(StrFormat("<%s>", ysh_type));
        }
      }
    }
  }
}

LexerDecoder::LexerDecoder(BigStr* s, bool is_j8, BigStr* lang_str) {
  this->s = s;
  this->is_j8 = is_j8;
  this->lang_str = lang_str;
  this->pos = 0;
  this->cur_line_num = 1;
  this->decoded = Alloc<mylib::BufWriter>();
}

error::Decode* LexerDecoder::_Error(BigStr* msg, int end_pos) {
  StackRoot _root0(&msg);

  return Alloc<error::Decode>(msg, this->s, this->pos, end_pos, this->cur_line_num);
}

Tuple3<int, int, BigStr*> LexerDecoder::Next() {
  int tok_id;
  int end_pos;
  Tuple2<int, int> tup1 = match::MatchJ8Token(this->s, this->pos);
  tok_id = tup1.at0();
  end_pos = tup1.at1();
  if (!this->is_j8) {
    if ((tok_id == Id::Left_BSingleQuote || tok_id == Id::Left_USingleQuote)) {
      throw this->_Error(S_hBp, end_pos);
    }
    if (tok_id == Id::Ignored_Comment) {
      throw this->_Error(S_wac, end_pos);
    }
  }
  if ((tok_id == Id::Left_DoubleQuote || tok_id == Id::Left_BSingleQuote || tok_id == Id::Left_USingleQuote)) {
    return this->_DecodeString(tok_id, end_pos);
  }
  if (tok_id == Id::Left_JDoubleQuote) {
    if (this->is_j8) {
      return this->_DecodeString(tok_id, end_pos);
    }
    else {
      throw this->_Error(S_Ahj, end_pos);
    }
  }
  if (tok_id == Id::Ignored_Newline) {
    this->cur_line_num += 1;
  }
  this->pos = end_pos;
  return Tuple3<int, int, BigStr*>(tok_id, end_pos, nullptr);
}

Tuple3<int, int, BigStr*> LexerDecoder::NextForLines() {
  int tok_id;
  int end_pos;
  Tuple2<int, int> tup2 = match::MatchJ8LinesToken(this->s, this->pos);
  tok_id = tup2.at0();
  end_pos = tup2.at1();
  if ((tok_id == Id::Left_DoubleQuote || tok_id == Id::Left_JDoubleQuote || tok_id == Id::Left_BSingleQuote || tok_id == Id::Left_USingleQuote)) {
    return this->_DecodeString(tok_id, end_pos);
  }
  if ((tok_id == Id::Lit_Chars and !pyj8::PartIsUtf8(this->s, this->pos, end_pos))) {
    throw this->_Error(StrFormat("Invalid UTF-8 in %s string literal", this->lang_str), end_pos);
  }
  if (tok_id == Id::Char_AsciiControl) {
    throw this->_Error(S_ApC, end_pos);
  }
  if (tok_id == Id::J8_Newline) {
    this->cur_line_num += 1;
  }
  this->pos = end_pos;
  return Tuple3<int, int, BigStr*>(tok_id, end_pos, nullptr);
}

Tuple3<int, int, BigStr*> LexerDecoder::_DecodeString(int left_id, int str_pos) {
  int tok_id;
  int str_end;
  BigStr* s = nullptr;
  BigStr* part = nullptr;
  BigStr* ch = nullptr;
  BigStr* h = nullptr;
  int i;
  BigStr* h1 = nullptr;
  BigStr* h2 = nullptr;
  int i1;
  int i2;
  int code_point;
  StackRoot _root0(&s);
  StackRoot _root1(&part);
  StackRoot _root2(&ch);
  StackRoot _root3(&h);
  StackRoot _root4(&h1);
  StackRoot _root5(&h2);

  while (true) {
    if ((left_id == Id::Left_DoubleQuote || left_id == Id::Left_JDoubleQuote)) {
      Tuple2<int, int> tup3 = match::MatchJsonStrToken(this->s, str_pos);
      tok_id = tup3.at0();
      str_end = tup3.at1();
    }
    else {
      Tuple2<int, int> tup4 = match::MatchJ8StrToken(this->s, str_pos);
      tok_id = tup4.at0();
      str_end = tup4.at1();
    }
    if (tok_id == Id::Eol_Tok) {
      throw this->_Error(StrFormat("Unexpected EOF while lexing %s string", this->lang_str), str_end);
    }
    if (tok_id == Id::Unknown_Backslash) {
      throw this->_Error(StrFormat("Bad backslash escape in %s string", this->lang_str), str_end);
    }
    if (tok_id == Id::Char_AsciiControl) {
      throw this->_Error(StrFormat("%s strings can't have unescaped ASCII control chars", this->lang_str), str_end);
    }
    if ((tok_id == Id::Right_SingleQuote || tok_id == Id::Right_DoubleQuote)) {
      this->pos = str_end;
      s = this->decoded->getvalue();
      this->decoded->clear();
      return Tuple3<int, int, BigStr*>(Id::J8_String, str_end, s);
    }
    if (tok_id == Id::Lit_Chars) {
      part = this->s->slice(str_pos, str_end);
      if (!pyj8::PartIsUtf8(this->s, str_pos, str_end)) {
        throw this->_Error(StrFormat("Invalid UTF-8 in %s string literal", this->lang_str), str_end);
      }
    }
    else {
      if (tok_id == Id::Char_OneChar) {
        ch = this->s->at((str_pos + 1));
        part = consts::LookupCharC(ch);
      }
      else {
        if (tok_id == Id::Char_UBraced) {
          h = this->s->slice((str_pos + 3), (str_end - 1));
          i = to_int(h, 16);
          if (i > 1114111) {
            throw this->_Error(S_egA, str_end);
          }
          if ((55296 <= i and i < 57344)) {
            throw this->_Error(StrFormat("\\u{%s} escape is illegal because it's in the surrogate range", h), str_end);
          }
          part = Utf8Encode(i);
        }
        else {
          if (tok_id == Id::Char_YHex) {
            h = this->s->slice((str_pos + 2), str_end);
            if (left_id != Id::Left_BSingleQuote) {
              throw this->_Error(StrFormat("\\y%s escapes not allowed in u'' strings", h), str_end);
            }
            i = to_int(h, 16);
            part = chr(i);
          }
          else {
            if (tok_id == Id::Char_SurrogatePair) {
              h1 = this->s->slice((str_pos + 2), (str_pos + 6));
              h2 = this->s->slice((str_pos + 8), (str_pos + 12));
              i1 = (to_int(h1, 16) - 55296);
              i2 = (to_int(h2, 16) - 56320);
              code_point = ((65536 + (i1 << 10)) + i2);
              part = Utf8Encode(code_point);
            }
            else {
              if (tok_id == Id::Char_Unicode4) {
                h = this->s->slice((str_pos + 2), str_end);
                i = to_int(h, 16);
                part = Utf8Encode(i);
              }
              else {
                assert(0);  // AssertionError
              }
            }
          }
        }
      }
    }
    this->decoded->write(part);
    str_pos = str_end;
  }
}

_Parser::_Parser(BigStr* s, bool is_j8) {
  this->s = s;
  this->is_j8 = is_j8;
  this->lang_str = is_j8 ? S_Czs : S_dqg;
  this->lexer = Alloc<LexerDecoder>(s, is_j8, this->lang_str);
  this->tok_id = Id::Undefined_Tok;
  this->start_pos = 0;
  this->end_pos = 0;
  this->decoded = S_Aoo;
}

void _Parser::_Next() {
  while (true) {
    this->start_pos = this->end_pos;
    Tuple3<int, int, BigStr*> tup5 = this->lexer->Next();
    this->tok_id = tup5.at0();
    this->end_pos = tup5.at1();
    this->decoded = tup5.at2();
    if ((this->tok_id != Id::Ignored_Space && this->tok_id != Id::Ignored_Newline && this->tok_id != Id::Ignored_Comment)) {
      break;
    }
  }
}

void _Parser::_Eat(int tok_id) {
  if (this->tok_id != tok_id) {
    throw this->_ParseError(StrFormat("Expected %s, got %s", Id_str(tok_id), Id_str(this->tok_id)));
  }
  this->_Next();
}

void _Parser::_NextForLines() {
  this->start_pos = this->end_pos;
  Tuple3<int, int, BigStr*> tup6 = this->lexer->NextForLines();
  this->tok_id = tup6.at0();
  this->end_pos = tup6.at1();
  this->decoded = tup6.at2();
}

error::Decode* _Parser::_ParseError(BigStr* msg) {
  StackRoot _root0(&msg);

  return Alloc<error::Decode>(msg, this->s, this->start_pos, this->end_pos, this->lexer->cur_line_num);
}

Parser::Parser(BigStr* s, bool is_j8) : ::j8::_Parser(s, is_j8) {
}

Tuple2<BigStr*, value_asdl::value_t*> Parser::_ParsePair() {
  BigStr* k = nullptr;
  value_asdl::value_t* v = nullptr;
  StackRoot _root0(&k);
  StackRoot _root1(&v);

  k = this->decoded;
  this->_Eat(Id::J8_String);
  this->_Eat(Id::J8_Colon);
  v = this->_ParseValue();
  return Tuple2<BigStr*, value_asdl::value_t*>(k, v);
}

value_asdl::value_t* Parser::_ParseDict() {
  Dict<BigStr*, value_asdl::value_t*>* d = nullptr;
  BigStr* k = nullptr;
  value_asdl::value_t* v = nullptr;
  StackRoot _root0(&d);
  StackRoot _root1(&k);
  StackRoot _root2(&v);

  d = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  this->_Next();
  if (this->tok_id == Id::J8_RBrace) {
    this->_Next();
    return Alloc<value::Dict>(d);
  }
  Tuple2<BigStr*, value_asdl::value_t*> tup7 = this->_ParsePair();
  k = tup7.at0();
  v = tup7.at1();
  d->set(k, v);
  while (this->tok_id == Id::J8_Comma) {
    this->_Next();
    Tuple2<BigStr*, value_asdl::value_t*> tup8 = this->_ParsePair();
    k = tup8.at0();
    v = tup8.at1();
    d->set(k, v);
  }
  this->_Eat(Id::J8_RBrace);
  return Alloc<value::Dict>(d);
}

value_asdl::value_t* Parser::_ParseList() {
  List<value_asdl::value_t*>* items = nullptr;
  StackRoot _root0(&items);

  items = Alloc<List<value_asdl::value_t*>>();
  this->_Next();
  if (this->tok_id == Id::J8_RBracket) {
    this->_Next();
    return Alloc<value::List>(items);
  }
  items->append(this->_ParseValue());
  while (this->tok_id == Id::J8_Comma) {
    this->_Next();
    items->append(this->_ParseValue());
  }
  this->_Eat(Id::J8_RBracket);
  return Alloc<value::List>(items);
}

value_asdl::value_t* Parser::_ParseValue() {
  value::Bool* b = nullptr;
  BigStr* part = nullptr;
  bool ok;
  mops::BigInt big;
  value::Str* str_val = nullptr;
  StackRoot _root0(&b);
  StackRoot _root1(&part);
  StackRoot _root2(&str_val);

  if (this->tok_id == Id::J8_LBrace) {
    return this->_ParseDict();
  }
  else {
    if (this->tok_id == Id::J8_LBracket) {
      return this->_ParseList();
    }
    else {
      if (this->tok_id == Id::J8_Null) {
        this->_Next();
        return value::Null;
      }
      else {
        if (this->tok_id == Id::J8_Bool) {
          b = Alloc<value::Bool>(str_equals(this->s->at(this->start_pos), S_omF));
          this->_Next();
          return b;
        }
        else {
          if (this->tok_id == Id::J8_Int) {
            part = this->s->slice(this->start_pos, this->end_pos);
            this->_Next();
            Tuple2<bool, mops::BigInt> tup9 = mops::FromStr2(part);
            ok = tup9.at0();
            big = tup9.at1();
            if (!ok) {
              throw this->_ParseError(S_zDl);
            }
            return Alloc<value::Int>(big);
          }
          else {
            if (this->tok_id == Id::J8_Float) {
              part = this->s->slice(this->start_pos, this->end_pos);
              this->_Next();
              return Alloc<value::Float>(to_float(part));
            }
            else {
              if (this->tok_id == Id::J8_String) {
                str_val = Alloc<value::Str>(this->decoded);
                this->_Next();
                return str_val;
              }
              else {
                if (this->tok_id == Id::Eol_Tok) {
                  throw this->_ParseError(StrFormat("Unexpected EOF while parsing %s", this->lang_str));
                }
                else {
                  throw this->_ParseError(StrFormat("Invalid token while parsing %s: %s", this->lang_str, Id_str(this->tok_id)));
                }
              }
            }
          }
        }
      }
    }
  }
}

value_asdl::value_t* Parser::ParseValue() {
  value_asdl::value_t* obj = nullptr;
  int n;
  int extra;
  StackRoot _root0(&obj);

  this->_Next();
  obj = this->_ParseValue();
  n = len(this->s);
  if (this->start_pos != n) {
    extra = (n - this->start_pos);
    throw this->_ParseError(StrFormat("Got %d bytes of unexpected trailing input", extra));
  }
  return obj;
}

Nil8Parser::Nil8Parser(BigStr* s, bool is_j8) : ::j8::_Parser(s, is_j8) {
}

nil8_asdl::nvalue_t* Nil8Parser::_ParseRecord() {
  List<nil8_asdl::nvalue_t*>* items = nullptr;
  StackRoot _root0(&items);

  items = Alloc<List<nil8_asdl::nvalue_t*>>();
  this->_Next();
  if (this->tok_id == Id::J8_RParen) {
    this->_Next();
    return Alloc<nvalue::List>(items);
  }
  while (this->tok_id != Id::J8_RParen) {
    items->append(this->_ParseNil8());
  }
  this->_Eat(Id::J8_RParen);
  return Alloc<nvalue::List>(items);
}

nil8_asdl::nvalue_t* Nil8Parser::_ParseList8() {
  List<nil8_asdl::nvalue_t*>* items = nullptr;
  StackRoot _root0(&items);

  items = Alloc<List<nil8_asdl::nvalue_t*>>();
  this->_Next();
  if (this->tok_id == Id::J8_RBracket) {
    this->_Next();
    return Alloc<nvalue::List>(items);
  }
  while (this->tok_id != Id::J8_RBracket) {
    items->append(this->_ParseNil8());
  }
  this->_Eat(Id::J8_RBracket);
  return Alloc<nvalue::List>(items);
}

nil8_asdl::nvalue_t* Nil8Parser::_ParseNil8() {
  nil8_asdl::nvalue_t* obj = nullptr;
  nvalue::Bool* b = nullptr;
  BigStr* part = nullptr;
  nvalue::Str* str_val = nullptr;
  nvalue::Symbol* op = nullptr;
  nil8_asdl::nvalue_t* operand2 = nullptr;
  nil8_asdl::nvalue_t* infix = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&b);
  StackRoot _root2(&part);
  StackRoot _root3(&str_val);
  StackRoot _root4(&op);
  StackRoot _root5(&operand2);
  StackRoot _root6(&infix);

  if (this->tok_id == Id::J8_LParen) {
    obj = this->_ParseRecord();
  }
  else {
    if (this->tok_id == Id::J8_LBracket) {
      obj = this->_ParseList8();
    }
    else {
      if (this->tok_id == Id::J8_Null) {
        this->_Next();
        obj = nvalue::Null;
      }
      else {
        if (this->tok_id == Id::J8_Bool) {
          b = Alloc<nvalue::Bool>(str_equals(this->s->at(this->start_pos), S_omF));
          this->_Next();
          obj = b;
        }
        else {
          if (this->tok_id == Id::J8_Int) {
            part = this->s->slice(this->start_pos, this->end_pos);
            this->_Next();
            obj = Alloc<nvalue::Int>(to_int(part));
          }
          else {
            if (this->tok_id == Id::J8_Float) {
              part = this->s->slice(this->start_pos, this->end_pos);
              this->_Next();
              obj = Alloc<nvalue::Float>(to_float(part));
            }
            else {
              if (this->tok_id == Id::J8_String) {
                str_val = Alloc<nvalue::Str>(this->decoded);
                this->_Next();
                obj = str_val;
              }
              else {
                if ((this->tok_id == Id::J8_Identifier || this->tok_id == Id::J8_Operator || this->tok_id == Id::J8_Colon || this->tok_id == Id::J8_Comma)) {
                  part = this->s->slice(this->start_pos, this->end_pos);
                  this->_Next();
                  obj = Alloc<nvalue::Symbol>(part);
                }
                else {
                  if (this->tok_id == Id::Eol_Tok) {
                    throw this->_ParseError(StrFormat("Unexpected EOF while parsing %s", this->lang_str));
                  }
                  else {
                    throw this->_ParseError(StrFormat("Invalid token while parsing %s: %s", this->lang_str, Id_str(this->tok_id)));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ((this->tok_id == Id::J8_Operator || this->tok_id == Id::J8_Colon || this->tok_id == Id::J8_Comma)) {
    part = this->s->slice(this->start_pos, this->end_pos);
    op = Alloc<nvalue::Symbol>(part);
    this->_Next();
    operand2 = this->_ParseNil8();
    infix = Alloc<nvalue::List>(NewList<nil8_asdl::nvalue_t*>(std::initializer_list<nil8_asdl::nvalue_t*>{op, obj, operand2}));
    return infix;
  }
  return obj;
}

nil8_asdl::nvalue_t* Nil8Parser::ParseNil8() {
  nil8_asdl::nvalue_t* obj = nullptr;
  StackRoot _root0(&obj);

  this->_Next();
  obj = this->_ParseNil8();
  if (this->tok_id != Id::Eol_Tok) {
    throw this->_ParseError(S_oDA);
  }
  return obj;
}

J8LinesParser::J8LinesParser(BigStr* s) : ::j8::_Parser(s, true) {
}

void J8LinesParser::_Show(BigStr* s) {
  StackRoot _root0(&s);

  mylib::print_stderr(StrFormat("%s tok_id %s %d-%d", s, Id_str(this->tok_id), this->start_pos, this->end_pos));
}

void J8LinesParser::_ParseLine(List<BigStr*>* out) {
  int string_start;
  int prev_id;
  int prev_start;
  int string_end;
  StackRoot _root0(&out);

  if (this->tok_id == Id::WS_Space) {
    this->_NextForLines();
  }
  if ((this->tok_id == Id::J8_Newline || this->tok_id == Id::Eol_Tok)) {
    this->_NextForLines();
    return ;
  }
  if (this->tok_id == Id::J8_String) {
    out->append(this->decoded);
    this->_NextForLines();
    if (this->tok_id == Id::WS_Space) {
      this->_NextForLines();
    }
    if ((this->tok_id != Id::J8_Newline && this->tok_id != Id::Eol_Tok)) {
      throw this->_ParseError(StrFormat("Unexpected text after J8 Line (%s)", Id_str(this->tok_id)));
    }
    this->_NextForLines();
    return ;
  }
  if (this->tok_id == Id::Lit_Chars) {
    string_start = this->start_pos;
    while (true) {
      prev_id = this->tok_id;
      prev_start = this->start_pos;
      this->_NextForLines();
      if ((this->tok_id == Id::J8_Newline || this->tok_id == Id::Eol_Tok)) {
        break;
      }
    }
    if (prev_id == Id::WS_Space) {
      string_end = prev_start;
    }
    else {
      string_end = this->start_pos;
    }
    out->append(this->s->slice(string_start, string_end));
    this->_NextForLines();
    return ;
  }
  assert(0);  // AssertionError
}

List<BigStr*>* J8LinesParser::Parse() {
  List<BigStr*>* lines = nullptr;
  StackRoot _root0(&lines);

  this->_NextForLines();
  lines = Alloc<List<BigStr*>>();
  while (this->tok_id != Id::Eol_Tok) {
    this->_ParseLine(lines);
  }
  if (this->tok_id != Id::Eol_Tok) {
    throw this->_ParseError(S_mfF);
  }
  return lines;
}

List<BigStr*>* SplitJ8Lines(BigStr* s) {
  j8::J8LinesParser* p = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&p);

  p = Alloc<J8LinesParser>(s);
  return p->Parse();
}

}  // define namespace j8

namespace j8_lite {  // define


BigStr* EncodeString(BigStr* s, bool unquoted_ok) {
  StackRoot _root0(&s);

  if ((unquoted_ok and fastfunc::CanOmitQuotes(s))) {
    return s;
  }
  return fastfunc::J8EncodeString(s, 1);
}

BigStr* YshEncodeString(BigStr* s) {
  StackRoot _root0(&s);

  return fastfunc::ShellEncodeString(s, 1);
}

BigStr* MaybeShellEncode(BigStr* s) {
  StackRoot _root0(&s);

  if (fastfunc::CanOmitQuotes(s)) {
    return s;
  }
  return fastfunc::ShellEncodeString(s, 0);
}

BigStr* ShellEncode(BigStr* s) {
  StackRoot _root0(&s);

  return fastfunc::ShellEncodeString(s, 0);
}

BigStr* YshEncode(BigStr* s, bool unquoted_ok) {
  StackRoot _root0(&s);

  if ((unquoted_ok and fastfunc::CanOmitQuotes(s))) {
    return s;
  }
  return fastfunc::ShellEncodeString(s, 1);
}

}  // define namespace j8_lite

namespace ansi {  // define

BigStr* RESET = S_yfk;
BigStr* BOLD = S_aaF;
BigStr* UNDERLINE = S_sCc;
BigStr* REVERSE = S_woy;
BigStr* RED = S_sqm;
BigStr* GREEN = S_eda;
BigStr* YELLOW = S_ysf;
BigStr* BLUE = S_osl;
BigStr* MAGENTA = S_vie;
BigStr* CYAN = S_mmi;
BigStr* WHITE = S_rpo;

}  // define namespace ansi

namespace pp_hnode {  // define

using hnode_asdl::hnode;
using hnode_asdl::hnode_e;
using hnode_asdl::hnode_t;
using hnode_asdl::Field;
using hnode_asdl::color_e;
using pretty_asdl::doc;
using pretty_asdl::MeasuredDoc;
using pretty_asdl::Measure;
using pretty::_Break;
using pretty::_Concat;
using pretty::_Flat;
using pretty::_Group;
using pretty::_IfFlat;
using pretty::_Indent;
using pretty::_EmptyMeasure;
using pretty::AsciiText;

BaseEncoder::BaseEncoder() {
  this->indent = 4;
  this->use_styles = true;
  this->max_tabular_width = 22;
  this->visiting = Alloc<Dict<int, bool>>();
}

void BaseEncoder::SetIndent(int indent) {
  this->indent = indent;
}

void BaseEncoder::SetUseStyles(bool use_styles) {
  this->use_styles = use_styles;
}

void BaseEncoder::SetMaxTabularWidth(int max_tabular_width) {
  this->max_tabular_width = max_tabular_width;
}

pretty_asdl::MeasuredDoc* BaseEncoder::_Styled(BigStr* style, pretty_asdl::MeasuredDoc* mdoc) {
  StackRoot _root0(&style);
  StackRoot _root1(&mdoc);

  if (this->use_styles) {
    return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{Alloc<MeasuredDoc>(Alloc<doc::Text>(style), _EmptyMeasure()), mdoc, Alloc<MeasuredDoc>(Alloc<doc::Text>(ansi::RESET), _EmptyMeasure())}));
  }
  else {
    return mdoc;
  }
}

pretty_asdl::MeasuredDoc* BaseEncoder::_StyledAscii(BigStr* style, BigStr* s) {
  pretty_asdl::Measure* measure = nullptr;
  StackRoot _root0(&style);
  StackRoot _root1(&s);
  StackRoot _root2(&measure);

  measure = Alloc<Measure>(len(s), -1);
  if (this->use_styles) {
    s = StrFormat("%s%s%s", style, s, ansi::RESET);
  }
  return Alloc<MeasuredDoc>(Alloc<doc::Text>(s), measure);
}

pretty_asdl::MeasuredDoc* BaseEncoder::_Surrounded(BigStr* left, pretty_asdl::MeasuredDoc* mdoc, BigStr* right) {
  StackRoot _root0(&left);
  StackRoot _root1(&mdoc);
  StackRoot _root2(&right);

  return _Group(_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(left), _Indent(this->indent, _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{_Break(S_Aoo), mdoc}))), _Break(S_Aoo), AsciiText(right)})));
}

pretty_asdl::MeasuredDoc* BaseEncoder::_SurroundedAndPrefixed(BigStr* left, pretty_asdl::MeasuredDoc* prefix, BigStr* sep, pretty_asdl::MeasuredDoc* mdoc, BigStr* right) {
  StackRoot _root0(&left);
  StackRoot _root1(&prefix);
  StackRoot _root2(&sep);
  StackRoot _root3(&mdoc);
  StackRoot _root4(&right);

  return _Group(_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(left), prefix, _Indent(this->indent, _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{_Break(sep), mdoc}))), _Break(S_Aoo), AsciiText(right)})));
}

pretty_asdl::MeasuredDoc* BaseEncoder::_Join(List<pretty_asdl::MeasuredDoc*>* items, BigStr* sep, BigStr* space) {
  List<pretty_asdl::MeasuredDoc*>* seq = nullptr;
  int i;
  StackRoot _root0(&items);
  StackRoot _root1(&sep);
  StackRoot _root2(&space);
  StackRoot _root3(&seq);

  seq = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  i = 0;
  for (ListIter<pretty_asdl::MeasuredDoc*> it(items); !it.Done(); it.Next(), ++i) {
    pretty_asdl::MeasuredDoc* item = it.Value();
    StackRoot _for(&item  );
    if (i != 0) {
      seq->append(AsciiText(sep));
      seq->append(_Break(space));
    }
    seq->append(item);
  }
  return _Concat(seq);
}

pretty_asdl::MeasuredDoc* BaseEncoder::_Tabular(List<pretty_asdl::MeasuredDoc*>* items, BigStr* sep) {
  int max_flat_len;
  List<pretty_asdl::MeasuredDoc*>* seq = nullptr;
  int i;
  pretty_asdl::MeasuredDoc* non_tabular = nullptr;
  int sep_width;
  List<pretty_asdl::MeasuredDoc*>* tabular_seq = nullptr;
  int padding;
  pretty_asdl::MeasuredDoc* tabular = nullptr;
  StackRoot _root0(&items);
  StackRoot _root1(&sep);
  StackRoot _root2(&seq);
  StackRoot _root3(&non_tabular);
  StackRoot _root4(&tabular_seq);
  StackRoot _root5(&tabular);

  if (len(items) == 0) {
    return AsciiText(S_Aoo);
  }
  max_flat_len = 0;
  seq = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  i = 0;
  for (ListIter<pretty_asdl::MeasuredDoc*> it(items); !it.Done(); it.Next(), ++i) {
    pretty_asdl::MeasuredDoc* item = it.Value();
    StackRoot _for(&item  );
    if (i != 0) {
      seq->append(AsciiText(sep));
      seq->append(_Break(S_yfw));
    }
    seq->append(item);
    max_flat_len = max(max_flat_len, item->measure->flat);
  }
  non_tabular = _Concat(seq);
  sep_width = len(sep);
  if (((max_flat_len + sep_width) + 1) <= this->max_tabular_width) {
    tabular_seq = Alloc<List<pretty_asdl::MeasuredDoc*>>();
    i = 0;
    for (ListIter<pretty_asdl::MeasuredDoc*> it(items); !it.Done(); it.Next(), ++i) {
      pretty_asdl::MeasuredDoc* item = it.Value();
      StackRoot _for(&item    );
      tabular_seq->append(_Flat(item));
      if (i != (len(items) - 1)) {
        padding = ((max_flat_len - item->measure->flat) + 1);
        tabular_seq->append(AsciiText(sep));
        tabular_seq->append(_Group(_Break(str_repeat(S_yfw, padding))));
      }
    }
    tabular = _Concat(tabular_seq);
    return _Group(_IfFlat(non_tabular, tabular));
  }
  else {
    return non_tabular;
  }
}

HNodeEncoder::HNodeEncoder() : ::pp_hnode::BaseEncoder() {
  this->type_color = ansi::YELLOW;
  this->field_color = ansi::MAGENTA;
}

pretty_asdl::MeasuredDoc* HNodeEncoder::HNode(hnode_asdl::hnode_t* h) {
  StackRoot _root0(&h);

  this->visiting->clear();
  return this->_HNode(h);
}

pretty_asdl::MeasuredDoc* HNodeEncoder::_Field(hnode_asdl::Field* field) {
  pretty_asdl::MeasuredDoc* name = nullptr;
  StackRoot _root0(&field);
  StackRoot _root1(&name);

  name = AsciiText(str_concat(field->name, S_fyj));
  return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{name, this->_HNode(field->val)}));
}

pretty_asdl::MeasuredDoc* HNodeEncoder::_HNode(hnode_asdl::hnode_t* h) {
  hnode_asdl::hnode_t* UP_h = nullptr;
  BigStr* color = nullptr;
  BigStr* s = nullptr;
  List<pretty_asdl::MeasuredDoc*>* children = nullptr;
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  List<pretty_asdl::MeasuredDoc*>* m = nullptr;
  pretty_asdl::MeasuredDoc* child = nullptr;
  StackRoot _root0(&h);
  StackRoot _root1(&UP_h);
  StackRoot _root2(&color);
  StackRoot _root3(&s);
  StackRoot _root4(&children);
  StackRoot _root5(&type_name);
  StackRoot _root6(&mdocs);
  StackRoot _root7(&m);
  StackRoot _root8(&child);

  UP_h = h;
  switch (h->tag()) {
    case hnode_e::AlreadySeen: {
      hnode::AlreadySeen* h = static_cast<hnode::AlreadySeen*>(UP_h);
      return pretty::AsciiText(StrFormat("...0x%s", mylib::hex_lower(h->heap_id)));
    }
      break;
    case hnode_e::Leaf: {
      hnode::Leaf* h = static_cast<hnode::Leaf*>(UP_h);
      switch (h->color) {
        case color_e::TypeName: {
          color = ansi::YELLOW;
        }
          break;
        case color_e::StringConst: {
          color = ansi::BOLD;
        }
          break;
        case color_e::OtherConst: {
          color = ansi::GREEN;
        }
          break;
        case color_e::External: {
          color = str_concat(ansi::BOLD, ansi::BLUE);
        }
          break;
        case color_e::UserType: {
          color = ansi::GREEN;
        }
          break;
        default: {
          assert(0);  // AssertionError
        }
      }
      s = j8_lite::EncodeString(h->s, true);
      return this->_StyledAscii(color, s);
    }
      break;
    case hnode_e::Array: {
      hnode::Array* h = static_cast<hnode::Array*>(UP_h);
      mylib::MaybeCollect();
      if (len(h->children) == 0) {
        return AsciiText(S_xmu);
      }
      children = Alloc<List<pretty_asdl::MeasuredDoc*>>();
      for (ListIter<hnode_asdl::hnode_t*> it(h->children); !it.Done(); it.Next()) {
        hnode_asdl::hnode_t* item = it.Value();
        children->append(this->_HNode(item));
      }
      return this->_Surrounded(S_Eax, this->_Tabular(children, S_Aoo), S_pcD);
    }
      break;
    case hnode_e::Record: {
      hnode::Record* h = static_cast<hnode::Record*>(UP_h);
      type_name = nullptr;
      if (len(h->node_type)) {
        type_name = this->_StyledAscii(this->type_color, h->node_type);
      }
      mdocs = nullptr;
      if ((h->unnamed_fields != nullptr and len(h->unnamed_fields))) {
        mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
        for (ListIter<hnode_asdl::hnode_t*> it(h->unnamed_fields); !it.Done(); it.Next()) {
          hnode_asdl::hnode_t* item = it.Value();
          mdocs->append(this->_HNode(item));
        }
      }
      else {
        if (len(h->fields) != 0) {
          mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
          for (ListIter<hnode_asdl::Field*> it(h->fields); !it.Done(); it.Next()) {
            hnode_asdl::Field* field = it.Value();
            mdocs->append(this->_Field(field));
          }
        }
      }
      if (mdocs == nullptr) {
        m = NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(h->left)});
        if (type_name != nullptr) {
          m->append(type_name);
        }
        m->append(AsciiText(h->right));
        return _Concat(m);
      }
      child = this->_Join(mdocs, S_Aoo, S_yfw);
      if (type_name != nullptr) {
        return this->_SurroundedAndPrefixed(h->left, type_name, S_yfw, child, h->right);
      }
      else {
        return this->_Surrounded(h->left, child, h->right);
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

}  // define namespace pp_hnode

namespace pp_value {  // define

using pretty_asdl::doc;
using pretty_asdl::Measure;
using pretty_asdl::MeasuredDoc;
using runtime_asdl::error_code_e;
using value_asdl::Obj;
using value_asdl::value;
using value_asdl::value_e;
using value_asdl::value_t;
using value_asdl::value_str;
using pretty::_Break;
using pretty::_Concat;
using pretty::AsciiText;

BigStr* ValType(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return value_str(val->tag(), false);
}

BigStr* FloatString(double fl) {
  BigStr* s = nullptr;
  StackRoot _root0(&s);

  if (math::isinf(fl)) {
    s = S_BvB;
    if (fl < 0) {
      s = str_concat(S_Bjq, s);
    }
  }
  else {
    if (math::isnan(fl)) {
      s = S_ywk;
    }
    else {
      s = str(fl);
    }
  }
  return s;
}

int TryUnicodeWidth(BigStr* s) {
  int width;
  StackRoot _root0(&s);

  try {
    width = libc::wcswidth(s);
  }
  catch (UnicodeError*) {
    width = len(s);
  }
  if (width == -1) {
    return len(s);
  }
  return width;
}

pretty_asdl::MeasuredDoc* UText(BigStr* string) {
  StackRoot _root0(&string);

  return Alloc<MeasuredDoc>(Alloc<doc::Text>(string), Alloc<Measure>(TryUnicodeWidth(string), -1));
}

ValueEncoder::ValueEncoder() : ::pp_hnode::BaseEncoder() {
  this->ysh_style = true;
  this->int_style = ansi::YELLOW;
  this->float_style = ansi::BLUE;
  this->null_style = ansi::RED;
  this->bool_style = ansi::CYAN;
  this->string_style = ansi::GREEN;
  this->cycle_style = str_concat(ansi::BOLD, ansi::BLUE);
  this->type_style = ansi::MAGENTA;
}

List<pretty_asdl::MeasuredDoc*>* ValueEncoder::TypePrefix(BigStr* type_str) {
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  int n;
  BigStr* spaces = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&type_str);
  StackRoot _root1(&type_name);
  StackRoot _root2(&spaces);
  StackRoot _root3(&mdocs);

  type_name = this->_Styled(this->type_style, AsciiText(type_str));
  n = len(type_str);
  spaces = str_repeat(S_yfw, (6 - n));
  mdocs = NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ijB), type_name, AsciiText(S_hxb), _Break(spaces)});
  return mdocs;
}

pretty_asdl::MeasuredDoc* ValueEncoder::Value(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  this->visiting->clear();
  return this->_Value(val);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_DictKey(BigStr* s) {
  BigStr* encoded = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&encoded);

  if (match::IsValidVarName(s)) {
    encoded = s;
  }
  else {
    if (this->ysh_style) {
      encoded = j8_lite::YshEncodeString(s);
    }
    else {
      encoded = j8_lite::EncodeString(s);
    }
  }
  return UText(encoded);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_StringLiteral(BigStr* s) {
  BigStr* encoded = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&encoded);

  if (this->ysh_style) {
    encoded = j8_lite::YshEncodeString(s);
  }
  else {
    encoded = j8_lite::EncodeString(s);
  }
  return this->_Styled(this->string_style, UText(encoded));
}

pretty_asdl::MeasuredDoc* ValueEncoder::_BashStringLiteral(BigStr* s) {
  BigStr* encoded = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&encoded);

  encoded = j8_lite::ShellEncode(s);
  return this->_Styled(this->string_style, UText(encoded));
}

pretty_asdl::MeasuredDoc* ValueEncoder::_YshList(value::List* vlist) {
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&vlist);
  StackRoot _root1(&mdocs);

  if (len(vlist->items) == 0) {
    return AsciiText(S_xmu);
  }
  mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  for (ListIter<value_asdl::value_t*> it(vlist->items); !it.Done(); it.Next()) {
    value_asdl::value_t* item = it.Value();
    mdocs->append(this->_Value(item));
  }
  return this->_Surrounded(S_Eax, this->_Tabular(mdocs, S_Cce), S_pcD);
}

List<pretty_asdl::MeasuredDoc*>* ValueEncoder::_DictMdocs(Dict<BigStr*, value_asdl::value_t*>* d) {
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&d);
  StackRoot _root1(&mdocs);

  mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  for (DictIter<BigStr*, value_asdl::value_t*> it(d); !it.Done(); it.Next()) {
    BigStr* k = it.Key();
    value_asdl::value_t* v = it.Value();
    mdocs->append(_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{this->_DictKey(k), AsciiText(S_ows), this->_Value(v)})));
  }
  return mdocs;
}

pretty_asdl::MeasuredDoc* ValueEncoder::_YshDict(value::Dict* vdict) {
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&vdict);
  StackRoot _root1(&mdocs);

  if (len(vdict->d) == 0) {
    return AsciiText(S_Fni);
  }
  mdocs = this->_DictMdocs(vdict->d);
  return this->_Surrounded(S_ato, this->_Join(mdocs, S_Cce, S_yfw), S_cEn);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_InternalStringArray(value::InternalStringArray* varray) {
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&varray);
  StackRoot _root1(&type_name);
  StackRoot _root2(&mdocs);

  type_name = this->_Styled(this->type_style, AsciiText(S_Fcv));
  if (bash_impl::InternalStringArray_Count(varray) == 0) {
    return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ijB), type_name, AsciiText(S_hxb)}));
  }
  mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  for (ListIter<BigStr*> it(bash_impl::InternalStringArray_GetValues(varray)); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    StackRoot _for(&s  );
    if (s == nullptr) {
      mdocs->append(AsciiText(S_lbA));
    }
    else {
      mdocs->append(this->_BashStringLiteral(s));
    }
  }
  return this->_SurroundedAndPrefixed(S_ijB, type_name, S_yfw, this->_Tabular(mdocs, S_Aoo), S_hxb);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_BashAssoc(value::BashAssoc* vassoc) {
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&vassoc);
  StackRoot _root1(&type_name);
  StackRoot _root2(&mdocs);

  type_name = this->_Styled(this->type_style, AsciiText(S_Agv));
  if (bash_impl::BashAssoc_Count(vassoc) == 0) {
    return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ijB), type_name, AsciiText(S_hxb)}));
  }
  mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  for (DictIter<BigStr*, BigStr*> it(bash_impl::BashAssoc_GetDict(vassoc)); !it.Done(); it.Next()) {
    BigStr* k2 = it.Key();
    BigStr* v2 = it.Value();
    mdocs->append(_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_Eax), this->_BashStringLiteral(k2), AsciiText(S_nuz), this->_BashStringLiteral(v2)})));
  }
  return this->_SurroundedAndPrefixed(S_ijB, type_name, S_yfw, this->_Join(mdocs, S_Aoo, S_yfw), S_hxb);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_BashArray(value::BashArray* val) {
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  BigStr* v2 = nullptr;
  runtime_asdl::error_code_t error_code;
  StackRoot _root0(&val);
  StackRoot _root1(&type_name);
  StackRoot _root2(&mdocs);
  StackRoot _root3(&v2);

  type_name = this->_Styled(this->type_style, AsciiText(S_tDu));
  if (bash_impl::BashArray_Count(val) == 0) {
    return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ijB), type_name, AsciiText(S_hxb)}));
  }
  mdocs = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  for (ListIter<mops::BigInt> it(bash_impl::BashArray_GetKeys(val)); !it.Done(); it.Next()) {
    mops::BigInt k2 = it.Value();
    Tuple2<BigStr*, runtime_asdl::error_code_t> tup0 = bash_impl::BashArray_GetElement(val, k2);
    v2 = tup0.at0();
    error_code = tup0.at1();
    mdocs->append(_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_Eax), this->_Styled(this->int_style, AsciiText(mops::ToStr(k2))), AsciiText(S_nuz), this->_BashStringLiteral(v2)})));
  }
  return this->_SurroundedAndPrefixed(S_ijB, type_name, S_yfw, this->_Join(mdocs, S_Aoo, S_yfw), S_hxb);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_Obj(value_asdl::Obj* obj) {
  List<pretty_asdl::MeasuredDoc*>* chain = nullptr;
  value_asdl::Obj* cur = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&chain);
  StackRoot _root2(&cur);
  StackRoot _root3(&mdocs);

  chain = Alloc<List<pretty_asdl::MeasuredDoc*>>();
  cur = obj;
  while (cur != nullptr) {
    mdocs = this->_DictMdocs(cur->d);
    chain->append(this->_Surrounded(S_ijB, this->_Join(mdocs, S_Cce, S_yfw), S_hxb));
    cur = cur->prototype;
    if (cur != nullptr) {
      chain->append(AsciiText(S_dtA));
    }
  }
  return _Concat(chain);
}

pretty_asdl::MeasuredDoc* ValueEncoder::_Value(value_asdl::value_t* val) {
  bool b;
  mops::BigInt i;
  double f;
  BigStr* s = nullptr;
  value::Range* r = nullptr;
  pretty_asdl::MeasuredDoc* type_name = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  value::List* vlist = nullptr;
  int heap_id;
  pretty_asdl::MeasuredDoc* result = nullptr;
  value::Dict* vdict = nullptr;
  value::BashArray* sparse = nullptr;
  value::InternalStringArray* varray = nullptr;
  value::BashAssoc* vassoc = nullptr;
  value_asdl::Obj* vaobj = nullptr;
  BigStr* id_str = nullptr;
  StackRoot _root0(&val);
  StackRoot _root1(&s);
  StackRoot _root2(&r);
  StackRoot _root3(&type_name);
  StackRoot _root4(&mdocs);
  StackRoot _root5(&vlist);
  StackRoot _root6(&result);
  StackRoot _root7(&vdict);
  StackRoot _root8(&sparse);
  StackRoot _root9(&varray);
  StackRoot _root10(&vassoc);
  StackRoot _root11(&vaobj);
  StackRoot _root12(&id_str);

  switch (val->tag()) {
    case value_e::Null: {
      return this->_Styled(this->null_style, AsciiText(S_lbA));
    }
      break;
    case value_e::Bool: {
      b = static_cast<value::Bool*>(val)->b;
      return this->_Styled(this->bool_style, AsciiText(b ? S_FsF : S_Ctn));
    }
      break;
    case value_e::Int: {
      i = static_cast<value::Int*>(val)->i;
      return this->_Styled(this->int_style, AsciiText(mops::ToStr(i)));
    }
      break;
    case value_e::Float: {
      f = static_cast<value::Float*>(val)->f;
      return this->_Styled(this->float_style, AsciiText(FloatString(f)));
    }
      break;
    case value_e::Str: {
      s = static_cast<value::Str*>(val)->s;
      return this->_StringLiteral(s);
    }
      break;
    case value_e::Range: {
      r = static_cast<value::Range*>(val);
      type_name = this->_Styled(this->type_style, AsciiText(ValType(r)));
      mdocs = NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(str(r->lower)), AsciiText(S_jhC), AsciiText(str(r->upper))});
      return this->_SurroundedAndPrefixed(S_ijB, type_name, S_yfw, this->_Join(mdocs, S_Aoo, S_yfw), S_hxb);
    }
      break;
    case value_e::List: {
      vlist = static_cast<value::List*>(val);
      heap_id = j8::HeapValueId(vlist);
      if (this->visiting->get(heap_id, false)) {
        return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_Eax), this->_Styled(this->cycle_style, AsciiText(S_otl)), AsciiText(S_pcD)}));
      }
      else {
        this->visiting->set(heap_id, true);
        result = this->_YshList(vlist);
        this->visiting->set(heap_id, false);
        return result;
      }
    }
      break;
    case value_e::Dict: {
      vdict = static_cast<value::Dict*>(val);
      heap_id = j8::HeapValueId(vdict);
      if (this->visiting->get(heap_id, false)) {
        return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ato), this->_Styled(this->cycle_style, AsciiText(S_otl)), AsciiText(S_cEn)}));
      }
      else {
        this->visiting->set(heap_id, true);
        result = this->_YshDict(vdict);
        this->visiting->set(heap_id, false);
        return result;
      }
    }
      break;
    case value_e::BashArray: {
      sparse = static_cast<value::BashArray*>(val);
      return this->_BashArray(sparse);
    }
      break;
    case value_e::InternalStringArray: {
      varray = static_cast<value::InternalStringArray*>(val);
      return this->_InternalStringArray(varray);
    }
      break;
    case value_e::BashAssoc: {
      vassoc = static_cast<value::BashAssoc*>(val);
      return this->_BashAssoc(vassoc);
    }
      break;
    case value_e::Obj: {
      vaobj = static_cast<Obj*>(val);
      heap_id = j8::HeapValueId(vaobj);
      if (this->visiting->get(heap_id, false)) {
        return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_ijB), this->_Styled(this->cycle_style, AsciiText(S_otl)), AsciiText(S_hxb)}));
      }
      else {
        this->visiting->set(heap_id, true);
        result = this->_Obj(vaobj);
        this->visiting->set(heap_id, false);
        return result;
      }
    }
      break;
    case value_e::Stdin: 
    case value_e::Interrupted: {
      type_name = this->_Styled(this->type_style, AsciiText(ValType(val)));
      return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_eox), type_name, AsciiText(S_jye)}));
    }
      break;
    default: {
      type_name = this->_Styled(this->type_style, AsciiText(ValType(val)));
      id_str = j8::ValueIdString(val);
      return _Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{AsciiText(S_eox), type_name, AsciiText(str_concat(id_str, S_jye))}));
    }
  }
}

}  // define namespace pp_value

namespace pretty {  // define

using pretty_asdl::doc;
using pretty_asdl::doc_e;
using pretty_asdl::DocFragment;
using pretty_asdl::Measure;
using pretty_asdl::MeasuredDoc;
using pretty_asdl::List_Measured;
using mylib::BufWriter;

pretty_asdl::Measure* _EmptyMeasure() {
  return Alloc<Measure>(0, -1);
}

pretty_asdl::Measure* _FlattenMeasure(pretty_asdl::Measure* measure) {
  StackRoot _root0(&measure);

  return Alloc<Measure>(measure->flat, -1);
}

pretty_asdl::Measure* _ConcatMeasure(pretty_asdl::Measure* m1, pretty_asdl::Measure* m2) {
  StackRoot _root0(&m1);
  StackRoot _root1(&m2);

  if (m1->nonflat != -1) {
    return Alloc<Measure>((m1->flat + m2->flat), m1->nonflat);
  }
  else {
    if (m2->nonflat != -1) {
      return Alloc<Measure>((m1->flat + m2->flat), (m1->flat + m2->nonflat));
    }
    else {
      return Alloc<Measure>((m1->flat + m2->flat), -1);
    }
  }
}

int _SuffixLen(pretty_asdl::Measure* measure) {
  StackRoot _root0(&measure);

  if (measure->nonflat != -1) {
    return measure->nonflat;
  }
  else {
    return measure->flat;
  }
}

pretty_asdl::MeasuredDoc* AsciiText(BigStr* string) {
  StackRoot _root0(&string);

  return Alloc<MeasuredDoc>(Alloc<doc::Text>(string), Alloc<Measure>(len(string), -1));
}

pretty_asdl::MeasuredDoc* _Break(BigStr* string) {
  StackRoot _root0(&string);

  return Alloc<MeasuredDoc>(Alloc<doc::Break>(string), Alloc<Measure>(len(string), 0));
}

pretty_asdl::MeasuredDoc* _Indent(int indent, pretty_asdl::MeasuredDoc* mdoc) {
  StackRoot _root0(&mdoc);

  return Alloc<MeasuredDoc>(Alloc<doc::Indent>(indent, mdoc), mdoc->measure);
}

pretty_asdl::Measure* _Splice(List<pretty_asdl::MeasuredDoc*>* out, List<pretty_asdl::MeasuredDoc*>* mdocs) {
  pretty_asdl::Measure* measure = nullptr;
  pretty_asdl::List_Measured* child = nullptr;
  StackRoot _root0(&out);
  StackRoot _root1(&mdocs);
  StackRoot _root2(&measure);
  StackRoot _root3(&child);

  measure = _EmptyMeasure();
  for (ListIter<pretty_asdl::MeasuredDoc*> it(mdocs); !it.Done(); it.Next()) {
    pretty_asdl::MeasuredDoc* mdoc = it.Value();
    StackRoot _for(&mdoc  );
    switch (mdoc->doc->tag()) {
      case doc_e::Concat: {
        child = static_cast<List_Measured*>(mdoc->doc);
        _Splice(out, child);
      }
        break;
      default: {
        out->append(mdoc);
      }
    }
    measure = _ConcatMeasure(measure, mdoc->measure);
  }
  return measure;
}

pretty_asdl::MeasuredDoc* _Concat(List<pretty_asdl::MeasuredDoc*>* mdocs) {
  pretty_asdl::List_Measured* flattened = nullptr;
  pretty_asdl::Measure* measure = nullptr;
  StackRoot _root0(&mdocs);
  StackRoot _root1(&flattened);
  StackRoot _root2(&measure);

  flattened = List_Measured::New();
  measure = _Splice(flattened, mdocs);
  return Alloc<MeasuredDoc>(flattened, measure);
}

pretty_asdl::MeasuredDoc* _Group(pretty_asdl::MeasuredDoc* mdoc) {
  StackRoot _root0(&mdoc);

  return Alloc<MeasuredDoc>(mdoc, mdoc->measure);
}

pretty_asdl::MeasuredDoc* _IfFlat(pretty_asdl::MeasuredDoc* flat_mdoc, pretty_asdl::MeasuredDoc* nonflat_mdoc) {
  StackRoot _root0(&flat_mdoc);
  StackRoot _root1(&nonflat_mdoc);

  return Alloc<MeasuredDoc>(Alloc<doc::IfFlat>(flat_mdoc, nonflat_mdoc), Alloc<Measure>(flat_mdoc->measure->flat, nonflat_mdoc->measure->nonflat));
}

pretty_asdl::MeasuredDoc* _Flat(pretty_asdl::MeasuredDoc* mdoc) {
  StackRoot _root0(&mdoc);

  return Alloc<MeasuredDoc>(Alloc<doc::Flat>(mdoc), _FlattenMeasure(mdoc->measure));
}

PrettyPrinter::PrettyPrinter(int max_width) {
  this->max_width = max_width;
}

bool PrettyPrinter::_Fits(int prefix_len, pretty_asdl::MeasuredDoc* group, pretty_asdl::Measure* suffix_measure) {
  pretty_asdl::Measure* measure = nullptr;
  StackRoot _root0(&group);
  StackRoot _root1(&suffix_measure);
  StackRoot _root2(&measure);

  measure = _ConcatMeasure(_FlattenMeasure(group->measure), suffix_measure);
  return (prefix_len + _SuffixLen(measure)) <= this->max_width;
}

void PrettyPrinter::PrintDoc(pretty_asdl::MeasuredDoc* document, mylib::BufWriter* buf) {
  int prefix_len;
  List<pretty_asdl::DocFragment*>* fragments = nullptr;
  int max_stack;
  pretty_asdl::DocFragment* frag = nullptr;
  pretty_asdl::doc_t* UP_doc = nullptr;
  pretty_asdl::Measure* measure = nullptr;
  bool is_flat;
  pretty_asdl::MeasuredDoc* subdoc = nullptr;
  StackRoot _root0(&document);
  StackRoot _root1(&buf);
  StackRoot _root2(&fragments);
  StackRoot _root3(&frag);
  StackRoot _root4(&UP_doc);
  StackRoot _root5(&measure);
  StackRoot _root6(&subdoc);

  prefix_len = 0;
  fragments = NewList<pretty_asdl::DocFragment*>(std::initializer_list<pretty_asdl::DocFragment*>{Alloc<DocFragment>(_Group(document), 0, false, _EmptyMeasure())});
  max_stack = len(fragments);
  while (len(fragments) > 0) {
    max_stack = max(max_stack, len(fragments));
    frag = fragments->pop();
    UP_doc = frag->mdoc->doc;
    switch (UP_doc->tag()) {
      case doc_e::Text: {
        doc::Text* text = static_cast<doc::Text*>(UP_doc);
        buf->write(text->string);
        prefix_len += frag->mdoc->measure->flat;
      }
        break;
      case doc_e::Break: {
        doc::Break* break_ = static_cast<doc::Break*>(UP_doc);
        if (frag->is_flat) {
          buf->write(break_->string);
          prefix_len += frag->mdoc->measure->flat;
        }
        else {
          buf->write(S_nfs);
          buf->write_spaces(frag->indent);
          prefix_len = frag->indent;
        }
      }
        break;
      case doc_e::Indent: {
        doc::Indent* indented = static_cast<doc::Indent*>(UP_doc);
        fragments->append(Alloc<DocFragment>(indented->mdoc, (frag->indent + indented->indent), frag->is_flat, frag->measure));
      }
        break;
      case doc_e::Concat: {
        List_Measured* concat = static_cast<List_Measured*>(UP_doc);
        measure = frag->measure;
        for (ReverseListIter<pretty_asdl::MeasuredDoc*> it(concat); !it.Done(); it.Next()) {
          pretty_asdl::MeasuredDoc* mdoc = it.Value();
          StackRoot _for(&mdoc        );
          fragments->append(Alloc<DocFragment>(mdoc, frag->indent, frag->is_flat, measure));
          measure = _ConcatMeasure(mdoc->measure, measure);
        }
      }
        break;
      case doc_e::Group: {
        MeasuredDoc* group = static_cast<MeasuredDoc*>(UP_doc);
        is_flat = this->_Fits(prefix_len, group, frag->measure);
        fragments->append(Alloc<DocFragment>(group, frag->indent, is_flat, frag->measure));
      }
        break;
      case doc_e::IfFlat: {
        doc::IfFlat* if_flat = static_cast<doc::IfFlat*>(UP_doc);
        if (frag->is_flat) {
          subdoc = if_flat->flat_mdoc;
        }
        else {
          subdoc = if_flat->nonflat_mdoc;
        }
        fragments->append(Alloc<DocFragment>(subdoc, frag->indent, frag->is_flat, frag->measure));
      }
        break;
      case doc_e::Flat: {
        doc::Flat* flat_doc = static_cast<doc::Flat*>(UP_doc);
        fragments->append(Alloc<DocFragment>(flat_doc->mdoc, frag->indent, true, frag->measure));
      }
        break;
    }
  }
}

}  // define namespace pretty

namespace ui {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using syntax_asdl::Token;
using syntax_asdl::SourceLine;
using syntax_asdl::loc;
using syntax_asdl::loc_e;
using syntax_asdl::loc_t;
using syntax_asdl::command_t;
using syntax_asdl::command_str;
using syntax_asdl::source;
using syntax_asdl::source_e;
using value_asdl::value_e;
using value_asdl::value_t;
namespace fmt = format;
using mylib::print_stderr;

BigStr* ValType(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return pp_value::ValType(val);
}

BigStr* CommandType(syntax_asdl::command_t* cmd) {
  StackRoot _root0(&cmd);

  return command_str(cmd->tag(), false);
}

BigStr* PrettyId(int id_) {
  return Id_str(id_);
}

BigStr* PrettyToken(syntax_asdl::Token* tok) {
  BigStr* val = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&val);

  if (tok->id == Id::Eof_Real) {
    return S_ngj;
  }
  val = tok->line->content->slice(tok->col, (tok->col + tok->length));
  return repr(val);
}

BigStr* PrettyDir(BigStr* dir_name, BigStr* home_dir) {
  StackRoot _root0(&dir_name);
  StackRoot _root1(&home_dir);

  if (home_dir != nullptr) {
    if ((str_equals(dir_name, home_dir) or dir_name->startswith(str_concat(home_dir, S_ckc)))) {
      return str_concat(S_Bhp, dir_name->slice(len(home_dir)));
    }
  }
  return dir_name;
}

void PrintCaretLine(BigStr* line, int col, int length, mylib::Writer* f) {
  StackRoot _root0(&line);
  StackRoot _root1(&f);

  for (StrIter it(line->slice(0, col)); !it.Done(); it.Next()) {
    BigStr* c = it.Value();
    StackRoot _for(&c  );
    f->write(str_equals(c, S_mve) ? S_mve : S_yfw);
  }
  f->write(S_EAB);
  f->write(str_repeat(S_Bhp, (length - 1)));
  f->write(S_nfs);
}

void _PrintCodeExcerpt(BigStr* line, int col, int length, mylib::Writer* f) {
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&line);
  StackRoot _root1(&f);
  StackRoot _root2(&buf);

  buf = Alloc<mylib::BufWriter>();
  buf->write(S_jqf);
  buf->write(line->rstrip());
  buf->write(S_sEF);
  PrintCaretLine(line, col, length, buf);
  f->write(buf->getvalue());
}

void _PrintTokenTooLong(loc::TokenTooLong* loc_tok, mylib::Writer* f) {
  syntax_asdl::SourceLine* line = nullptr;
  int col;
  mylib::BufWriter* buf = nullptr;
  BigStr* source_str = nullptr;
  StackRoot _root0(&loc_tok);
  StackRoot _root1(&f);
  StackRoot _root2(&line);
  StackRoot _root3(&buf);
  StackRoot _root4(&source_str);

  line = loc_tok->line;
  col = loc_tok->col;
  buf = Alloc<mylib::BufWriter>();
  buf->write(S_jqf);
  buf->write(line->content->slice(0, (col + 10))->rstrip());
  buf->write(S_sEF);
  for (StrIter it(line->content->slice(0, col)); !it.Done(); it.Next()) {
    BigStr* c = it.Value();
    StackRoot _for(&c  );
    buf->write(str_equals(c, S_mve) ? S_mve : S_yfw);
  }
  buf->write(S_neq);
  source_str = GetLineSourceString(loc_tok->line, true);
  buf->write(StrFormat("%s:%d: Token starting at column %d is too long: %d bytes (%s)\n", source_str, line->line_num, loc_tok->col, loc_tok->length, Id_str(loc_tok->id)));
  f->write(buf->getvalue());
}

BigStr* GetFilenameString(syntax_asdl::SourceLine* line) {
  syntax_asdl::source_t* src = nullptr;
  syntax_asdl::source_t* UP_src = nullptr;
  BigStr* filename_str = nullptr;
  StackRoot _root0(&line);
  StackRoot _root1(&src);
  StackRoot _root2(&UP_src);
  StackRoot _root3(&filename_str);

  src = line->src;
  UP_src = src;
  filename_str = S_BAk;
  switch (src->tag()) {
    case source_e::CFlag: {
      filename_str = S_sDc;
    }
      break;
    case source_e::Stdin: {
      filename_str = S_sDc;
    }
      break;
    case source_e::MainFile: {
      source::MainFile* src = static_cast<source::MainFile*>(UP_src);
      filename_str = src->path;
    }
      break;
    case source_e::OtherFile: {
      source::OtherFile* src = static_cast<source::OtherFile*>(UP_src);
      filename_str = src->path;
    }
      break;
    default: {
      ;  // pass
    }
  }
  return filename_str;
}

BigStr* GetLineSourceString(syntax_asdl::SourceLine* line, bool quote_filename) {
  syntax_asdl::source_t* src = nullptr;
  syntax_asdl::source_t* UP_src = nullptr;
  BigStr* s = nullptr;
  syntax_asdl::Token* blame_tok = nullptr;
  int line_num;
  BigStr* outer_source = nullptr;
  BigStr* var_name = nullptr;
  BigStr* where = nullptr;
  syntax_asdl::Token* orig_tok = nullptr;
  syntax_asdl::Token* span2 = nullptr;
  StackRoot _root0(&line);
  StackRoot _root1(&src);
  StackRoot _root2(&UP_src);
  StackRoot _root3(&s);
  StackRoot _root4(&blame_tok);
  StackRoot _root5(&outer_source);
  StackRoot _root6(&var_name);
  StackRoot _root7(&where);
  StackRoot _root8(&orig_tok);
  StackRoot _root9(&span2);

  src = line->src;
  UP_src = src;
  switch (src->tag()) {
    case source_e::Interactive: {
      s = S_odD;
    }
      break;
    case source_e::Headless: {
      s = S_jgf;
    }
      break;
    case source_e::CFlag: {
      s = S_wxv;
    }
      break;
    case source_e::Stdin: {
      source::Stdin* src = static_cast<source::Stdin*>(UP_src);
      s = StrFormat("[ stdin%s ]", src->comment);
    }
      break;
    case source_e::MainFile: {
      source::MainFile* src = static_cast<source::MainFile*>(UP_src);
      s = src->path;
      if (quote_filename) {
        s = j8_lite::EncodeString(s, true);
      }
    }
      break;
    case source_e::OtherFile: {
      source::OtherFile* src = static_cast<source::OtherFile*>(UP_src);
      s = src->path;
      if (quote_filename) {
        s = j8_lite::EncodeString(s, true);
      }
    }
      break;
    case source_e::Dynamic: {
      source::Dynamic* src = static_cast<source::Dynamic*>(UP_src);
      blame_tok = location::TokenFor(src->location);
      if (blame_tok == nullptr) {
        s = StrFormat("[ %s at ? ]", src->what);
      }
      else {
        line = blame_tok->line;
        line_num = line->line_num;
        outer_source = GetLineSourceString(line, quote_filename);
        s = StrFormat("[ %s at line %d of %s ]", src->what, line_num, outer_source);
      }
    }
      break;
    case source_e::Variable: {
      source::Variable* src = static_cast<source::Variable*>(UP_src);
      if (src->var_name == nullptr) {
        var_name = S_BAk;
      }
      else {
        var_name = repr(src->var_name);
      }
      if (src->location->tag() == loc_e::Missing) {
        where = S_BAk;
      }
      else {
        blame_tok = location::TokenFor(src->location);
        line_num = blame_tok->line->line_num;
        outer_source = GetLineSourceString(blame_tok->line, quote_filename);
        where = StrFormat("line %d of %s", line_num, outer_source);
      }
      s = StrFormat("[ var %s at %s ]", var_name, where);
    }
      break;
    case source_e::VarRef: {
      source::VarRef* src = static_cast<source::VarRef*>(UP_src);
      orig_tok = src->orig_tok;
      line_num = orig_tok->line->line_num;
      outer_source = GetLineSourceString(orig_tok->line, quote_filename);
      where = StrFormat("line %d of %s", line_num, outer_source);
      var_name = lexer::TokenVal(orig_tok);
      s = StrFormat("[ contents of var %r at %s ]", var_name, where);
    }
      break;
    case source_e::Alias: {
      source::Alias* src = static_cast<source::Alias*>(UP_src);
      s = StrFormat("[ expansion of alias %r ]", src->argv0);
    }
      break;
    case source_e::Reparsed: {
      source::Reparsed* src = static_cast<source::Reparsed*>(UP_src);
      span2 = src->left_token;
      outer_source = GetLineSourceString(span2->line, quote_filename);
      s = StrFormat("[ %s in %s ]", src->what, outer_source);
    }
      break;
    case source_e::Synthetic: {
      source::Synthetic* src = static_cast<source::Synthetic*>(UP_src);
      s = StrFormat("-- %s", src->s);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return s;
}

void _PrintWithLocation(BigStr* prefix, BigStr* msg, syntax_asdl::loc_t* blame_loc, bool show_code) {
  mylib::Writer* f = nullptr;
  syntax_asdl::Token* blame_tok = nullptr;
  int orig_col;
  syntax_asdl::source_t* src = nullptr;
  BigStr* line = nullptr;
  int line_num;
  syntax_asdl::source_t* UP_src = nullptr;
  syntax_asdl::Token* tok2 = nullptr;
  BigStr* line2 = nullptr;
  int lbracket_col;
  BigStr* source_str = nullptr;
  StackRoot _root0(&prefix);
  StackRoot _root1(&msg);
  StackRoot _root2(&blame_loc);
  StackRoot _root3(&f);
  StackRoot _root4(&blame_tok);
  StackRoot _root5(&src);
  StackRoot _root6(&line);
  StackRoot _root7(&UP_src);
  StackRoot _root8(&tok2);
  StackRoot _root9(&line2);
  StackRoot _root10(&source_str);

  f = mylib::Stderr();
  if (blame_loc->tag() == loc_e::TokenTooLong) {
    _PrintTokenTooLong(static_cast<loc::TokenTooLong*>(blame_loc), f);
    return ;
  }
  blame_tok = location::TokenFor(blame_loc);
  if ((blame_tok == nullptr or blame_tok->line == nullptr)) {
    f->write(StrFormat("[??? no location ???] %s%s\n", prefix, msg));
    return ;
  }
  orig_col = blame_tok->col;
  src = blame_tok->line->src;
  line = blame_tok->line->content;
  line_num = blame_tok->line->line_num;
  if (show_code) {
    UP_src = src;
    switch (src->tag()) {
      case source_e::Reparsed: {
        source::Reparsed* src = static_cast<source::Reparsed*>(UP_src);
        tok2 = src->left_token;
        line_num = tok2->line->line_num;
        line2 = tok2->line->content;
        lbracket_col = (tok2->col + tok2->length);
        _PrintCodeExcerpt(line2, (orig_col + lbracket_col), 1, f);
      }
        break;
      case source_e::Dynamic: {
        source::Dynamic* src = static_cast<source::Dynamic*>(UP_src);
        _PrintCodeExcerpt(line, blame_tok->col, blame_tok->length, f);
        source_str = GetLineSourceString(blame_tok->line, true);
        f->write(StrFormat("%s:%d\n", source_str, line_num));
        f->write(S_nfs);
        _PrintWithLocation(prefix, msg, src->location, show_code);
        return ;
      }
        break;
      default: {
        _PrintCodeExcerpt(line, blame_tok->col, blame_tok->length, f);
      }
    }
  }
  source_str = GetLineSourceString(blame_tok->line, true);
  f->write(StrFormat("%s:%d: %s%s\n", source_str, line_num, prefix, msg));
}

Tuple2<BigStr*, BigStr*> CodeExcerptAndPrefix(syntax_asdl::Token* blame_tok) {
  syntax_asdl::SourceLine* line = nullptr;
  mylib::BufWriter* buf = nullptr;
  BigStr* source_str = nullptr;
  BigStr* prefix = nullptr;
  StackRoot _root0(&blame_tok);
  StackRoot _root1(&line);
  StackRoot _root2(&buf);
  StackRoot _root3(&source_str);
  StackRoot _root4(&prefix);

  line = blame_tok->line;
  buf = Alloc<mylib::BufWriter>();
  _PrintCodeExcerpt(line->content, blame_tok->col, blame_tok->length, buf);
  source_str = GetLineSourceString(line, true);
  prefix = StrFormat("%s:%d: ", source_str, blame_tok->line->line_num);
  return Tuple2<BigStr*, BigStr*>(buf->getvalue(), prefix);
}

ctx_Location::ctx_Location(ui::ErrorFormatter* errfmt, syntax_asdl::loc_t* location) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->errfmt)));
  errfmt->loc_stack->append(location);
  this->errfmt = errfmt;
}

ctx_Location::~ctx_Location() {
  this->errfmt->loc_stack->pop();
  gHeap.PopRoot();
}

ErrorFormatter::ErrorFormatter() {
  this->loc_stack = Alloc<List<syntax_asdl::loc_t*>>();
  this->one_line_errexit = false;
}

void ErrorFormatter::OneLineErrExit() {
  this->one_line_errexit = true;
}

syntax_asdl::loc_t* ErrorFormatter::_FallbackLocation(syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&blame_loc);

  if ((blame_loc == nullptr or blame_loc->tag() == loc_e::Missing)) {
    if (len(this->loc_stack)) {
      return this->loc_stack->at(-1);
    }
    return loc::Missing;
  }
  return blame_loc;
}

void ErrorFormatter::PrefixPrint(BigStr* msg, BigStr* prefix, syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&msg);
  StackRoot _root1(&prefix);
  StackRoot _root2(&blame_loc);

  _PrintWithLocation(prefix, msg, this->_FallbackLocation(blame_loc), true);
}

void ErrorFormatter::Print_(BigStr* msg, syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&msg);
  StackRoot _root1(&blame_loc);

  _PrintWithLocation(S_Aoo, msg, this->_FallbackLocation(blame_loc), true);
}

void ErrorFormatter::PrintMessage(BigStr* msg, syntax_asdl::loc_t* blame_loc) {
  StackRoot _root0(&msg);
  StackRoot _root1(&blame_loc);

  _PrintWithLocation(S_Aoo, msg, this->_FallbackLocation(blame_loc), false);
}

void ErrorFormatter::StderrLine(BigStr* msg) {
  StackRoot _root0(&msg);

  print_stderr(msg);
}

void ErrorFormatter::PrettyPrintError(error::_ErrorWithLocation* err, BigStr* prefix) {
  StackRoot _root0(&err);
  StackRoot _root1(&prefix);

  _PrintWithLocation(prefix, err->UserErrorString(), err->location, true);
}

void ErrorFormatter::PrintErrExit(error::ErrExit* err, int pid) {
  BigStr* prefix = nullptr;
  StackRoot _root0(&err);
  StackRoot _root1(&prefix);

  prefix = StrFormat("errexit PID %d: ", pid);
  _PrintWithLocation(prefix, err->UserErrorString(), err->location, err->show_code);
}

void PrintAst(syntax_asdl::command_t* node, arg_types::main* flag) {
  mylib::Writer* f = nullptr;
  bool do_abbrev;
  bool perf_stats;
  hnode_asdl::hnode_t* tree = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&flag);
  StackRoot _root2(&f);
  StackRoot _root3(&tree);

  if (maybe_str_equals(flag->ast_format, S_rdE)) {
    print_stderr(S_ztv);
  }
  else {
    f = mylib::Stdout();
    do_abbrev = str_contains(flag->ast_format, S_Btg);
    perf_stats = flag->ast_format->startswith(S_Cet);
    if (perf_stats) {
      mylib::print_stderr(S_Aoo);
      mylib::print_stderr(S_aEE);
      mylib::PrintGcStats();
      mylib::print_stderr(S_Aoo);
    }
    tree = node->PrettyTree(do_abbrev);
    if (perf_stats) {
      fmt::_HNodePrettyPrint(true, maybe_str_equals(flag->ast_format, S_myz), tree, f, _GetMaxWidth());
    }
    else {
      fmt::HNodePrettyPrint(tree, f, _GetMaxWidth());
    }
  }
}

bool TypeNotPrinted(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return (val->tag() == value_e::Null || val->tag() == value_e::Bool || val->tag() == value_e::Int || val->tag() == value_e::Float || val->tag() == value_e::Str || val->tag() == value_e::List || val->tag() == value_e::Dict || val->tag() == value_e::Obj);
}

int _GetMaxWidth() {
  int max_width;
  int width;
  max_width = 80;
  try {
    width = libc::get_terminal_width();
    if (width > 0) {
      max_width = width;
    }
  }
  catch (IOError_OSError*) {
    ;  // pass
  }
  return max_width;
}

void PrettyPrintValue(BigStr* prefix, value_asdl::value_t* val, mylib::Writer* f, int max_width) {
  pp_value::ValueEncoder* encoder = nullptr;
  List<pretty_asdl::MeasuredDoc*>* mdocs = nullptr;
  pretty_asdl::MeasuredDoc* doc = nullptr;
  pretty::PrettyPrinter* printer = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoot _root0(&prefix);
  StackRoot _root1(&val);
  StackRoot _root2(&f);
  StackRoot _root3(&encoder);
  StackRoot _root4(&mdocs);
  StackRoot _root5(&doc);
  StackRoot _root6(&printer);
  StackRoot _root7(&buf);

  encoder = Alloc<pp_value::ValueEncoder>();
  encoder->SetUseStyles(f->isatty());
  if (TypeNotPrinted(val)) {
    mdocs = encoder->TypePrefix(pp_value::ValType(val));
    mdocs->append(encoder->Value(val));
    doc = pretty::_Concat(mdocs);
  }
  else {
    doc = encoder->Value(val);
  }
  if (len(prefix)) {
    doc = pretty::_Concat(NewList<pretty_asdl::MeasuredDoc*>(std::initializer_list<pretty_asdl::MeasuredDoc*>{pretty::AsciiText(prefix), pretty::_Indent(4, doc)}));
  }
  if (max_width == -1) {
    max_width = _GetMaxWidth();
  }
  printer = Alloc<pretty::PrettyPrinter>(max_width);
  buf = Alloc<mylib::BufWriter>();
  printer->PrintDoc(doc, buf);
  f->write(buf->getvalue());
  f->write(S_nfs);
}

}  // define namespace ui

namespace lexer {  // define

using syntax_asdl::Token;
using syntax_asdl::SourceLine;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id;
using id_kind_asdl::Id_str;

bool IsPlusEquals(syntax_asdl::Token* tok) {
  int i;
  StackRoot _root0(&tok);

  i = ((tok->col + tok->length) - 2);
  return tok->line->content->find(S_jnE, i, (i + 1)) != -1;
}

bool TokenContains(syntax_asdl::Token* tok, BigStr* substr) {
  StackRoot _root0(&tok);
  StackRoot _root1(&substr);

  return tok->line->content->find(substr, tok->col, (tok->col + tok->length)) != -1;
}

bool TokenEquals(syntax_asdl::Token* tok, BigStr* s) {
  StackRoot _root0(&tok);
  StackRoot _root1(&s);

  if (len(s) != tok->length) {
    return false;
  }
  return TokenContains(tok, s);
}

bool TokenStartsWith(syntax_asdl::Token* tok, BigStr* s) {
  StackRoot _root0(&tok);
  StackRoot _root1(&s);

  return tok->line->content->find(s, tok->col, (tok->col + len(s))) != -1;
}

bool TokenEndsWith(syntax_asdl::Token* tok, BigStr* s) {
  int end;
  StackRoot _root0(&tok);
  StackRoot _root1(&s);

  end = (tok->col + tok->length);
  return tok->line->content->find(s, (end - len(s)), end) != -1;
}

BigStr* TokenVal(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  return tok->line->content->slice(tok->col, (tok->col + tok->length));
}

BigStr* TokenSliceLeft(syntax_asdl::Token* tok, int left_index) {
  int start;
  StackRoot _root0(&tok);

  start = (tok->col + left_index);
  return tok->line->content->slice(start, (tok->col + tok->length));
}

BigStr* TokenSliceRight(syntax_asdl::Token* tok, int right_index) {
  int end;
  StackRoot _root0(&tok);

  end = ((tok->col + tok->length) + right_index);
  return tok->line->content->slice(tok->col, end);
}

BigStr* TokenSlice(syntax_asdl::Token* tok, int left, int right) {
  int start;
  int end;
  StackRoot _root0(&tok);

  start = (tok->col + left);
  end = ((tok->col + tok->length) + right);
  return tok->line->content->slice(start, end);
}

BigStr* LazyStr(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  if (tok->tval == nullptr) {
    if ((tok->id == Id::VSub_DollarName || tok->id == Id::VSub_Number)) {
      tok->tval = TokenSliceLeft(tok, 1);
    }
    else {
      tok->tval = TokenVal(tok);
    }
  }
  return tok->tval;
}

syntax_asdl::Token* DummyToken(int id_, BigStr* val) {
  int col;
  int length;
  StackRoot _root0(&val);

  col = -1;
  length = -1;
  return Alloc<Token>(id_, length, col, nullptr, val);
}

LineLexer::LineLexer(alloc::Arena* arena) {
  this->arena = arena;
  this->replace_last_token = false;
  this->eol_tok = DummyToken(Id::Eol_Tok, S_Aoo);
  this->Reset(nullptr, 0);
}

void LineLexer::Reset(syntax_asdl::SourceLine* src_line, int line_pos) {
  StackRoot _root0(&src_line);

  this->src_line = src_line;
  this->line_pos = line_pos;
}

bool LineLexer::MaybeUnreadOne() {
  if (this->line_pos == 0) {
    return false;
  }
  else {
    this->line_pos -= 1;
    this->replace_last_token = true;
    return true;
  }
}

syntax_asdl::Token* LineLexer::GetEofToken(int id_) {
  syntax_asdl::SourceLine* src_line = nullptr;
  StackRoot _root0(&src_line);

  if (this->src_line == nullptr) {
    src_line = this->arena->AddLine(S_Aoo, 0);
  }
  else {
    src_line = this->src_line;
  }
  return this->arena->NewToken(id_, this->line_pos, 0, src_line);
}

int LineLexer::LookAheadOne(types_asdl::lex_mode_t lex_mode) {
  int pos;
  BigStr* line_str = nullptr;
  int n;
  int tok_type;
  StackRoot _root0(&line_str);

  pos = this->line_pos;
  line_str = this->src_line->content;
  n = len(line_str);
  if (pos == n) {
    return Id::Unknown_Tok;
  }
  else {
    Tuple2<int, int> tup0 = match::OneToken(lex_mode, line_str, pos);
    tok_type = tup0.at0();
    return tok_type;
  }
}

void LineLexer::AssertAtEndOfLine() {
}

int LineLexer::LookPastSpace(types_asdl::lex_mode_t lex_mode) {
  int pos;
  BigStr* line_str = nullptr;
  int n;
  int tok_type;
  int end_pos;
  StackRoot _root0(&line_str);

  pos = this->line_pos;
  line_str = this->src_line->content;
  n = len(line_str);
  while (true) {
    if (pos == n) {
      return Id::Unknown_Tok;
    }
    Tuple2<int, int> tup1 = match::OneToken(lex_mode, line_str, pos);
    tok_type = tup1.at0();
    end_pos = tup1.at1();
    if ((tok_type != Id::WS_Space and tok_type != Id::Ignored_Space)) {
      break;
    }
    pos = end_pos;
  }
  return tok_type;
}

bool LineLexer::LookAheadFuncParens(int unread) {
  int pos;
  int tok_type;
  pos = (this->line_pos - unread);
  Tuple2<int, int> tup2 = match::OneToken(lex_mode_e::FuncParens, this->src_line->content, pos);
  tok_type = tup2.at0();
  return tok_type == Id::LookAhead_FuncParens;
}

BigStr* LineLexer::ByteLookAhead() {
  int pos;
  pos = this->line_pos;
  if (pos == len(this->src_line->content)) {
    return S_Aoo;
  }
  else {
    return this->src_line->content->at(pos);
  }
}

int LineLexer::ByteLookBack() {
  int pos;
  pos = (this->line_pos - 2);
  if (pos < 0) {
    return -1;
  }
  else {
    return ord(this->src_line->content->at(pos));
  }
}

syntax_asdl::Token* LineLexer::Read(types_asdl::lex_mode_t lex_mode) {
  BigStr* line_str = nullptr;
  int line_pos;
  int tok_type;
  int end_pos;
  int tok_len;
  syntax_asdl::Token* t = nullptr;
  StackRoot _root0(&line_str);
  StackRoot _root1(&t);

  if (this->src_line) {
    line_str = this->src_line->content;
  }
  else {
    line_str = S_Aoo;
  }
  line_pos = this->line_pos;
  Tuple2<int, int> tup3 = match::OneToken(lex_mode, line_str, line_pos);
  tok_type = tup3.at0();
  end_pos = tup3.at1();
  if (tok_type == Id::Eol_Tok) {
    return this->eol_tok;
  }
  if (this->replace_last_token) {
    this->arena->UnreadOne();
    this->replace_last_token = false;
  }
  tok_len = (end_pos - line_pos);
  t = this->arena->NewToken(tok_type, line_pos, tok_len, this->src_line);
  this->line_pos = end_pos;
  return t;
}

Lexer::Lexer(lexer::LineLexer* line_lexer, reader::_Reader* line_reader) {
  this->line_lexer = line_lexer;
  this->line_reader = line_reader;
  this->line_id = -1;
  this->translation_stack = Alloc<List<Tuple2<int, int>*>>();
  this->emit_comp_dummy = false;
}

void Lexer::ResetInputObjects() {
  this->line_lexer->Reset(nullptr, 0);
}

bool Lexer::MaybeUnreadOne() {
  return this->line_lexer->MaybeUnreadOne();
}

int Lexer::LookAheadOne(types_asdl::lex_mode_t lex_mode) {
  return this->line_lexer->LookAheadOne(lex_mode);
}

int Lexer::LookPastSpace(types_asdl::lex_mode_t lex_mode) {
  return this->line_lexer->LookPastSpace(lex_mode);
}

bool Lexer::LookAheadFuncParens(int unread) {
  return this->line_lexer->LookAheadFuncParens(unread);
}

BigStr* Lexer::ByteLookAhead() {
  return this->line_lexer->ByteLookAhead();
}

int Lexer::ByteLookBack() {
  return this->line_lexer->ByteLookBack();
}

void Lexer::EmitCompDummy() {
  this->emit_comp_dummy = true;
}

void Lexer::PushHint(int old_id, int new_id) {
  this->translation_stack->append((Alloc<Tuple2<int, int>>(old_id, new_id)));
}

bool Lexer::MoveToNextLine() {
  syntax_asdl::SourceLine* src_line = nullptr;
  int line_pos;
  StackRoot _root0(&src_line);

  this->line_lexer->AssertAtEndOfLine();
  Tuple2<syntax_asdl::SourceLine*, int> tup4 = this->line_reader->GetLine();
  src_line = tup4.at0();
  line_pos = tup4.at1();
  if (src_line == nullptr) {
    return false;
  }
  this->line_lexer->Reset(src_line, line_pos);
  return true;
}

syntax_asdl::Token* Lexer::_Read(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* t = nullptr;
  syntax_asdl::SourceLine* src_line = nullptr;
  int line_pos;
  int id_;
  int old_id;
  int new_id;
  StackRoot _root0(&t);
  StackRoot _root1(&src_line);

  t = this->line_lexer->Read(lex_mode);
  if (t->id == Id::Eol_Tok) {
    Tuple2<syntax_asdl::SourceLine*, int> tup5 = this->line_reader->GetLine();
    src_line = tup5.at0();
    line_pos = tup5.at1();
    if (src_line == nullptr) {
      if (this->emit_comp_dummy) {
        id_ = Id::Lit_CompDummy;
        this->emit_comp_dummy = false;
      }
      else {
        id_ = Id::Eof_Real;
      }
      return this->line_lexer->GetEofToken(id_);
    }
    this->line_lexer->Reset(src_line, line_pos);
    t = this->line_lexer->Read(lex_mode);
  }
  if (len(this->translation_stack)) {
    Tuple2<int, int>* tup6 = this->translation_stack->at(-1);
    old_id = tup6->at0();
    new_id = tup6->at1();
    if (t->id == old_id) {
      this->translation_stack->pop();
      t->id = new_id;
    }
  }
  return t;
}

syntax_asdl::Token* Lexer::Read(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* t = nullptr;
  StackRoot _root0(&t);

  while (true) {
    t = this->_Read(lex_mode);
    if (t->id != Id::Ignored_LineCont) {
      break;
    }
  }
  return t;
}

}  // define namespace lexer

namespace location {  // define

using syntax_asdl::expr;
using syntax_asdl::expr_t;
using syntax_asdl::expr_e;
using syntax_asdl::loc;
using syntax_asdl::loc_t;
using syntax_asdl::loc_e;
using syntax_asdl::loc_str;
using syntax_asdl::command;
using syntax_asdl::command_e;
using syntax_asdl::command_t;
using syntax_asdl::sh_lhs;
using syntax_asdl::sh_lhs_e;
using syntax_asdl::sh_lhs_t;
using syntax_asdl::word;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word_part;
using syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using syntax_asdl::CompoundWord;
using syntax_asdl::Token;
using syntax_asdl::SimpleVarSub;
using syntax_asdl::YshArrayLiteral;
using syntax_asdl::SingleQuoted;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::CommandSub;
using syntax_asdl::BracedVarSub;
using syntax_asdl::BraceGroup;
using syntax_asdl::Subscript;
using syntax_asdl::Attribute;
using syntax_asdl::arith_expr;
using syntax_asdl::arith_expr_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::Eggex;
using value_asdl::LeftName;

value_asdl::LeftName* LName(BigStr* name) {
  StackRoot _root0(&name);

  return Alloc<LeftName>(name, loc::Missing);
}

syntax_asdl::Token* TokenFor(syntax_asdl::loc_t* loc_) {
  syntax_asdl::loc_t* UP_location = nullptr;
  StackRoot _root0(&loc_);
  StackRoot _root1(&UP_location);

  UP_location = loc_;
  switch (loc_->tag()) {
    case loc_e::Missing: {
      return nullptr;
    }
      break;
    case loc_e::Token: {
      Token* tok = static_cast<Token*>(UP_location);
      if (tok) {
        return tok;
      }
      else {
        return nullptr;
      }
    }
      break;
    case loc_e::ArgWord: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_location);
      return LeftTokenForWord(w);
    }
      break;
    case loc_e::WordPart: {
      loc::WordPart* loc_ = static_cast<loc::WordPart*>(UP_location);
      if (loc_->p) {
        return LeftTokenForWordPart(loc_->p);
      }
      else {
        return nullptr;
      }
    }
      break;
    case loc_e::Word: {
      loc::Word* loc_ = static_cast<loc::Word*>(UP_location);
      if (loc_->w) {
        return LeftTokenForWord(loc_->w);
      }
      else {
        return nullptr;
      }
    }
      break;
    case loc_e::Command: {
      loc::Command* loc_ = static_cast<loc::Command*>(UP_location);
      if (loc_->c) {
        return TokenForCommand(loc_->c);
      }
      else {
        return nullptr;
      }
    }
      break;
    case loc_e::Arith: {
      loc::Arith* loc_ = static_cast<loc::Arith*>(UP_location);
      if (loc_->a) {
        return TokenForArith(loc_->a);
      }
      else {
        return nullptr;
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

syntax_asdl::Token* TokenForCommand(syntax_asdl::command_t* node) {
  syntax_asdl::command_t* UP_node = nullptr;
  int tag;
  syntax_asdl::Redir* first = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&UP_node);
  StackRoot _root2(&first);

  UP_node = node;
  tag = node->tag();
  if (tag == command_e::Redirect) {
    command::Redirect* node = static_cast<command::Redirect*>(UP_node);
    first = node->redirects->at(0);
    return first->op;
  }
  if (tag == command_e::Sentence) {
    command::Sentence* node = static_cast<command::Sentence*>(UP_node);
    return node->terminator;
  }
  if (tag == command_e::Simple) {
    command::Simple* node = static_cast<command::Simple*>(UP_node);
    return node->blame_tok;
  }
  if (tag == command_e::ShAssignment) {
    command::ShAssignment* node = static_cast<command::ShAssignment*>(UP_node);
    return node->left;
  }
  if (tag == command_e::Pipeline) {
    command::Pipeline* node = static_cast<command::Pipeline*>(UP_node);
    if (len(node->ops)) {
      return node->ops->at(0);
    }
    else {
      return node->negated;
    }
  }
  if (tag == command_e::AndOr) {
    command::AndOr* node = static_cast<command::AndOr*>(UP_node);
    return node->ops->at(0);
  }
  if (tag == command_e::DoGroup) {
    command::DoGroup* node = static_cast<command::DoGroup*>(UP_node);
    return node->left;
  }
  if (tag == command_e::BraceGroup) {
    BraceGroup* node = static_cast<BraceGroup*>(UP_node);
    return node->left;
  }
  if (tag == command_e::Subshell) {
    command::Subshell* node = static_cast<command::Subshell*>(UP_node);
    return node->left;
  }
  if (tag == command_e::WhileUntil) {
    command::WhileUntil* node = static_cast<command::WhileUntil*>(UP_node);
    return node->keyword;
  }
  if (tag == command_e::If) {
    command::If* node = static_cast<command::If*>(UP_node);
    return node->if_kw;
  }
  if (tag == command_e::Case) {
    command::Case* node = static_cast<command::Case*>(UP_node);
    return node->case_kw;
  }
  if (tag == command_e::TimeBlock) {
    command::TimeBlock* node = static_cast<command::TimeBlock*>(UP_node);
    return node->keyword;
  }
  return nullptr;
}

syntax_asdl::Token* TokenForArith(syntax_asdl::arith_expr_t* node) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&UP_node);

  UP_node = node;
  switch (node->tag()) {
    case arith_expr_e::VarSub: {
      Token* vsub = static_cast<Token*>(UP_node);
      return vsub;
    }
      break;
    case arith_expr_e::Word: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_node);
      return LeftTokenForWord(w);
    }
      break;
    case arith_expr_e::Unary: {
      arith_expr::Unary* node = static_cast<arith_expr::Unary*>(UP_node);
      return TokenForArith(node->child);
    }
      break;
    case arith_expr_e::Binary: {
      arith_expr::Binary* node = static_cast<arith_expr::Binary*>(UP_node);
      return TokenForArith(node->op);
    }
      break;
    case arith_expr_e::TernaryOp: {
      arith_expr::TernaryOp* node = static_cast<arith_expr::TernaryOp*>(UP_node);
      return TokenForArith(node->cond);
    }
      break;
  }
  return nullptr;
}

syntax_asdl::Token* LeftTokenForWordPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  StackRoot _root0(&part);
  StackRoot _root1(&UP_part);

  UP_part = part;
  switch (part->tag()) {
    case word_part_e::YshArrayLiteral: {
      YshArrayLiteral* part = static_cast<YshArrayLiteral*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::InitializerLiteral: {
      word_part::InitializerLiteral* part = static_cast<word_part::InitializerLiteral*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return tok;
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part::EscapedLiteral* part = static_cast<word_part::EscapedLiteral*>(UP_part);
      return part->token;
    }
      break;
    case word_part_e::SingleQuoted: {
      SingleQuoted* part = static_cast<SingleQuoted*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::DoubleQuoted: {
      DoubleQuoted* part = static_cast<DoubleQuoted*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::SimpleVarSub: {
      SimpleVarSub* part = static_cast<SimpleVarSub*>(UP_part);
      return part->tok;
    }
      break;
    case word_part_e::BracedVarSub: {
      BracedVarSub* part = static_cast<BracedVarSub*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::CommandSub: {
      CommandSub* part = static_cast<CommandSub*>(UP_part);
      return part->left_token;
    }
      break;
    case word_part_e::TildeSub: {
      word_part::TildeSub* part = static_cast<word_part::TildeSub*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::ArithSub: {
      word_part::ArithSub* part = static_cast<word_part::ArithSub*>(UP_part);
      return part->left;
    }
      break;
    case word_part_e::ExtGlob: {
      word_part::ExtGlob* part = static_cast<word_part::ExtGlob*>(UP_part);
      return part->op;
    }
      break;
    case word_part_e::BracedRange: {
      word_part::BracedRange* part = static_cast<word_part::BracedRange*>(UP_part);
      return part->blame_tok;
    }
      break;
    case word_part_e::BracedRangeDigit: {
      word_part::BracedRangeDigit* part = static_cast<word_part::BracedRangeDigit*>(UP_part);
      return part->orig_tok;
    }
      break;
    case word_part_e::BracedTuple: {
      word_part::BracedTuple* part = static_cast<word_part::BracedTuple*>(UP_part);
      return nullptr;
    }
      break;
    case word_part_e::Splice: {
      word_part::Splice* part = static_cast<word_part::Splice*>(UP_part);
      return part->blame_tok;
    }
      break;
    case word_part_e::ExprSub: {
      word_part::ExprSub* part = static_cast<word_part::ExprSub*>(UP_part);
      return part->left;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

syntax_asdl::Token* _RightTokenForWordPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  StackRoot _root0(&part);
  StackRoot _root1(&UP_part);

  UP_part = part;
  switch (part->tag()) {
    case word_part_e::YshArrayLiteral: {
      YshArrayLiteral* part = static_cast<YshArrayLiteral*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::InitializerLiteral: {
      word_part::InitializerLiteral* part = static_cast<word_part::InitializerLiteral*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return tok;
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part::EscapedLiteral* part = static_cast<word_part::EscapedLiteral*>(UP_part);
      return part->token;
    }
      break;
    case word_part_e::SingleQuoted: {
      SingleQuoted* part = static_cast<SingleQuoted*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::DoubleQuoted: {
      DoubleQuoted* part = static_cast<DoubleQuoted*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::SimpleVarSub: {
      SimpleVarSub* part = static_cast<SimpleVarSub*>(UP_part);
      return part->tok;
    }
      break;
    case word_part_e::BracedVarSub: {
      BracedVarSub* part = static_cast<BracedVarSub*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::CommandSub: {
      CommandSub* part = static_cast<CommandSub*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::TildeSub: {
      word_part::TildeSub* part = static_cast<word_part::TildeSub*>(UP_part);
      if (part->name != nullptr) {
        return part->name;
      }
      else {
        return part->left;
      }
    }
      break;
    case word_part_e::ArithSub: {
      word_part::ArithSub* part = static_cast<word_part::ArithSub*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::ExtGlob: {
      word_part::ExtGlob* part = static_cast<word_part::ExtGlob*>(UP_part);
      return part->right;
    }
      break;
    case word_part_e::BracedRange: {
      word_part::BracedRange* part = static_cast<word_part::BracedRange*>(UP_part);
      return part->blame_tok;
    }
      break;
    case word_part_e::BracedTuple: {
      word_part::BracedTuple* part = static_cast<word_part::BracedTuple*>(UP_part);
      return nullptr;
    }
      break;
    case word_part_e::Splice: {
      word_part::Splice* part = static_cast<word_part::Splice*>(UP_part);
      return part->blame_tok;
    }
      break;
    case word_part_e::ExprSub: {
      word_part::ExprSub* part = static_cast<word_part::ExprSub*>(UP_part);
      return part->right;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

syntax_asdl::Token* LeftTokenForCompoundWord(syntax_asdl::CompoundWord* w) {
  StackRoot _root0(&w);

  if (len(w->parts)) {
    return LeftTokenForWordPart(w->parts->at(0));
  }
  else {
    return nullptr;
  }
}

syntax_asdl::Token* LeftTokenForWord(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&UP_w);

  if (w == nullptr) {
    return nullptr;
  }
  UP_w = w;
  switch (w->tag()) {
    case word_e::Compound: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      return LeftTokenForCompoundWord(w);
    }
      break;
    case word_e::Operator: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok;
    }
      break;
    case word_e::BracedTree: {
      word::BracedTree* w = static_cast<word::BracedTree*>(UP_w);
      return LeftTokenForWordPart(w->parts->at(0));
    }
      break;
    case word_e::String: {
      word::String* w = static_cast<word::String*>(UP_w);
      return LeftTokenForWord(w->blame_loc);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

syntax_asdl::Token* RightTokenForWord(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  syntax_asdl::word_part_t* end = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&UP_w);
  StackRoot _root2(&end);

  UP_w = w;
  switch (w->tag()) {
    case word_e::Compound: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      if (len(w->parts)) {
        end = w->parts->at(-1);
        return _RightTokenForWordPart(end);
      }
      else {
        return nullptr;
      }
    }
      break;
    case word_e::Operator: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok;
    }
      break;
    case word_e::BracedTree: {
      word::BracedTree* w = static_cast<word::BracedTree*>(UP_w);
      return _RightTokenForWordPart(w->parts->at(-1));
    }
      break;
    case word_e::String: {
      word::String* w = static_cast<word::String*>(UP_w);
      return RightTokenForWord(w->blame_loc);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

syntax_asdl::Token* TokenForLhsExpr(syntax_asdl::sh_lhs_t* node) {
  syntax_asdl::sh_lhs_t* UP_node = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&UP_node);

  UP_node = node;
  switch (node->tag()) {
    case sh_lhs_e::Name: {
      sh_lhs::Name* node = static_cast<sh_lhs::Name*>(UP_node);
      return node->left;
    }
      break;
    case sh_lhs_e::IndexedName: {
      sh_lhs::IndexedName* node = static_cast<sh_lhs::IndexedName*>(UP_node);
      return node->left;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  assert(0);  // AssertionError
}

syntax_asdl::loc_t* TokenForExpr(syntax_asdl::expr_t* node) {
  syntax_asdl::expr_t* UP_node = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&UP_node);

  UP_node = node;
  switch (node->tag()) {
    case expr_e::Const: {
      expr::Const* node = static_cast<expr::Const*>(UP_node);
      return node->c;
    }
      break;
    case expr_e::Var: {
      expr::Var* node = static_cast<expr::Var*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::Place: {
      expr::Place* node = static_cast<expr::Place*>(UP_node);
      return node->blame_tok;
    }
      break;
    case expr_e::CommandSub: {
      CommandSub* node = static_cast<CommandSub*>(UP_node);
      return node->left_token;
    }
      break;
    case expr_e::YshArrayLiteral: {
      YshArrayLiteral* node = static_cast<YshArrayLiteral*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::DoubleQuoted: {
      DoubleQuoted* node = static_cast<DoubleQuoted*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::SingleQuoted: {
      SingleQuoted* node = static_cast<SingleQuoted*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::BracedVarSub: {
      BracedVarSub* node = static_cast<BracedVarSub*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::SimpleVarSub: {
      SimpleVarSub* node = static_cast<SimpleVarSub*>(UP_node);
      return node->tok;
    }
      break;
    case expr_e::Unary: {
      expr::Unary* node = static_cast<expr::Unary*>(UP_node);
      return node->op;
    }
      break;
    case expr_e::Binary: {
      expr::Binary* node = static_cast<expr::Binary*>(UP_node);
      return node->op;
    }
      break;
    case expr_e::Slice: {
      expr::Slice* node = static_cast<expr::Slice*>(UP_node);
      return node->op;
    }
      break;
    case expr_e::Range: {
      expr::Range* node = static_cast<expr::Range*>(UP_node);
      return node->op;
    }
      break;
    case expr_e::Compare: {
      expr::Compare* node = static_cast<expr::Compare*>(UP_node);
      return TokenForExpr(node->left);
    }
      break;
    case expr_e::IfExp: {
      return loc::Missing;
    }
      break;
    case expr_e::List: {
      expr::List* node = static_cast<expr::List*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::Tuple: {
      expr::Tuple* node = static_cast<expr::Tuple*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::Dict: {
      expr::Dict* node = static_cast<expr::Dict*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::ListComp: {
      expr::ListComp* node = static_cast<expr::ListComp*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::GeneratorExp: {
      return loc::Missing;
    }
      break;
    case expr_e::Lambda: {
      return loc::Missing;
    }
      break;
    case expr_e::FuncCall: {
      expr::FuncCall* node = static_cast<expr::FuncCall*>(UP_node);
      return node->args->left;
    }
      break;
    case expr_e::Subscript: {
      Subscript* node = static_cast<Subscript*>(UP_node);
      return node->left;
    }
      break;
    case expr_e::Attribute: {
      Attribute* node = static_cast<Attribute*>(UP_node);
      return node->op;
    }
      break;
    case expr_e::Eggex: {
      Eggex* node = static_cast<Eggex*>(UP_node);
      return node->left;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

}  // define namespace location

namespace parse_lib {  // define

using id_kind_asdl::Id_t;
using syntax_asdl::Token;
using syntax_asdl::CompoundWord;
using syntax_asdl::expr_t;
using syntax_asdl::Redir;
using syntax_asdl::ArgList;
using syntax_asdl::Proc;
using syntax_asdl::Func;
using syntax_asdl::pat_t;
using syntax_asdl::VarDecl;
using syntax_asdl::Mutation;
using types_asdl::lex_mode_e;
namespace fmt = format;
using expr_parse::ctx_PNodeAllocator;

_BaseTrail::_BaseTrail() {
  this->words = Alloc<List<syntax_asdl::CompoundWord*>>();
  this->redirects = Alloc<List<syntax_asdl::Redir*>>();
  this->tokens = Alloc<List<syntax_asdl::Token*>>();
  this->alias_words = Alloc<List<syntax_asdl::CompoundWord*>>();
  this->_expanding_alias = false;
}

void _BaseTrail::Clear() {
  ;  // pass
}

void _BaseTrail::SetLatestWords(List<syntax_asdl::CompoundWord*>* words, List<syntax_asdl::Redir*>* redirects) {
  StackRoot _root0(&words);
  StackRoot _root1(&redirects);

  ;  // pass
}

void _BaseTrail::AppendToken(syntax_asdl::Token* token) {
  StackRoot _root0(&token);

  ;  // pass
}

void _BaseTrail::BeginAliasExpansion() {
  ;  // pass
}

void _BaseTrail::EndAliasExpansion() {
  ;  // pass
}

ctx_Alias::ctx_Alias(parse_lib::_BaseTrail* trail) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->trail)));
  trail->_expanding_alias = true;
  this->trail = trail;
}

ctx_Alias::~ctx_Alias() {
  this->trail->_expanding_alias = false;
  gHeap.PopRoot();
}

Trail::Trail() : ::parse_lib::_BaseTrail() {
}

void Trail::Clear() {
  this->words->clear();
  this->redirects->clear();
  this->tokens->clear();
  this->alias_words->clear();
}

void Trail::SetLatestWords(List<syntax_asdl::CompoundWord*>* words, List<syntax_asdl::Redir*>* redirects) {
  StackRoot _root0(&words);
  StackRoot _root1(&redirects);

  if (this->_expanding_alias) {
    this->alias_words = words;
    return ;
  }
  this->words = words;
  this->redirects = redirects;
}

void Trail::AppendToken(syntax_asdl::Token* token) {
  StackRoot _root0(&token);

  if (this->_expanding_alias) {
    return ;
  }
  this->tokens->append(token);
}

ParseContext::ParseContext(alloc::Arena* arena, optview::Parse* parse_opts, Dict<BigStr*, BigStr*>* aliases, grammar::Grammar* ysh_grammar, bool do_lossless) {
  this->arena = arena;
  this->parse_opts = parse_opts;
  this->aliases = aliases;
  this->ysh_grammar = ysh_grammar;
  this->do_lossless = do_lossless;
  if (ysh_grammar) {
    this->tr = Alloc<expr_to_ast::Transformer>(ysh_grammar);
  }
  else {
    this->tr = nullptr;
  }
  this->trail = Alloc<_BaseTrail>();
}

void ParseContext::Init_Trail(parse_lib::_BaseTrail* trail) {
  StackRoot _root0(&trail);

  this->trail = trail;
}

lexer::Lexer* ParseContext::MakeLexer(reader::_Reader* line_reader) {
  lexer::LineLexer* line_lexer = nullptr;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&line_lexer);

  line_lexer = Alloc<lexer::LineLexer>(line_reader->arena);
  return Alloc<lexer::Lexer>(line_lexer, line_reader);
}

cmd_parse::CommandParser* ParseContext::MakeOshParser(reader::_Reader* line_reader, bool emit_comp_dummy) {
  lexer::Lexer* lx = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&lx);
  StackRoot _root2(&w_parser);
  StackRoot _root3(&c_parser);

  lx = this->MakeLexer(line_reader);
  if (emit_comp_dummy) {
    lx->EmitCompDummy();
  }
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, this->parse_opts, w_parser, lx, line_reader);
  return c_parser;
}

cmd_parse::CommandParser* ParseContext::MakeConfigParser(reader::_Reader* line_reader) {
  lexer::Lexer* lx = nullptr;
  optview::Parse* parse_opts = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&lx);
  StackRoot _root2(&parse_opts);
  StackRoot _root3(&w_parser);
  StackRoot _root4(&c_parser);

  lx = this->MakeLexer(line_reader);
  parse_opts = state::MakeYshParseOpts();
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, parse_opts, w_parser, lx, line_reader);
  return c_parser;
}

word_parse::WordParser* ParseContext::MakeWordParserForHereDoc(reader::_Reader* line_reader) {
  lexer::Lexer* lx = nullptr;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&lx);

  lx = this->MakeLexer(line_reader);
  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

word_parse::WordParser* ParseContext::MakeWordParser(lexer::Lexer* lx, reader::_Reader* line_reader) {
  StackRoot _root0(&lx);
  StackRoot _root1(&line_reader);

  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

tdop::TdopParser* ParseContext::MakeArithParser(BigStr* code_str) {
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lx = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  tdop::TdopParser* a_parser = nullptr;
  StackRoot _root0(&code_str);
  StackRoot _root1(&line_reader);
  StackRoot _root2(&lx);
  StackRoot _root3(&w_parser);
  StackRoot _root4(&a_parser);

  line_reader = reader::StringLineReader(code_str, this->arena);
  lx = this->MakeLexer(line_reader);
  w_parser = Alloc<word_parse::WordParser>(this, lx, line_reader);
  w_parser->Init(lex_mode_e::Arith);
  a_parser = Alloc<tdop::TdopParser>(arith_parse::Spec(), w_parser, this->parse_opts);
  return a_parser;
}

cmd_parse::CommandParser* ParseContext::MakeParserForCommandSub(reader::_Reader* line_reader, lexer::Lexer* lexer, int eof_id) {
  word_parse::WordParser* w_parser = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&lexer);
  StackRoot _root2(&w_parser);
  StackRoot _root3(&c_parser);

  w_parser = Alloc<word_parse::WordParser>(this, lexer, line_reader);
  c_parser = Alloc<cmd_parse::CommandParser>(this, this->parse_opts, w_parser, lexer, line_reader, eof_id);
  return c_parser;
}

word_parse::WordParser* ParseContext::MakeWordParserForPlugin(BigStr* code_str) {
  reader::FileLineReader* line_reader = nullptr;
  lexer::Lexer* lx = nullptr;
  StackRoot _root0(&code_str);
  StackRoot _root1(&line_reader);
  StackRoot _root2(&lx);

  line_reader = reader::StringLineReader(code_str, this->arena);
  lx = this->MakeLexer(line_reader);
  return Alloc<word_parse::WordParser>(this, lx, line_reader);
}

expr_parse::ExprParser* ParseContext::_YshParser() {
  return Alloc<expr_parse::ExprParser>(this, this->ysh_grammar);
}

Tuple2<syntax_asdl::VarDecl*, syntax_asdl::Token*> ParseContext::ParseVarDecl(syntax_asdl::Token* kw_token, lexer::Lexer* lexer) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::VarDecl* ast_node = nullptr;
  StackRoot _root0(&kw_token);
  StackRoot _root1(&lexer);
  StackRoot _root2(&e_parser);
  StackRoot _root3(&last_token);
  StackRoot _root4(&ast_node);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup0 = e_parser->Parse(lexer, grammar_nt::ysh_var_decl);
    pnode = tup0.at0();
    last_token = tup0.at1();
    ast_node = this->tr->MakeVarDecl(pnode);
    ast_node->keyword = kw_token;
  }
  return Tuple2<syntax_asdl::VarDecl*, syntax_asdl::Token*>(ast_node, last_token);
}

Tuple2<syntax_asdl::Mutation*, syntax_asdl::Token*> ParseContext::ParseMutation(syntax_asdl::Token* kw_token, lexer::Lexer* lexer) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::Mutation* ast_node = nullptr;
  StackRoot _root0(&kw_token);
  StackRoot _root1(&lexer);
  StackRoot _root2(&e_parser);
  StackRoot _root3(&last_token);
  StackRoot _root4(&ast_node);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup1 = e_parser->Parse(lexer, grammar_nt::ysh_mutation);
    pnode = tup1.at0();
    last_token = tup1.at1();
    ast_node = this->tr->MakeMutation(pnode);
    ast_node->keyword = kw_token;
  }
  return Tuple2<syntax_asdl::Mutation*, syntax_asdl::Token*>(ast_node, last_token);
}

void ParseContext::ParseProcCallArgs(lexer::Lexer* lx, syntax_asdl::ArgList* out, int start_symbol) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&lx);
  StackRoot _root1(&out);
  StackRoot _root2(&e_parser);
  StackRoot _root3(&last_token);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup2 = e_parser->Parse(lx, start_symbol);
    pnode = tup2.at0();
    last_token = tup2.at1();
    this->tr->ProcCallArgs(pnode, out);
    out->right = last_token;
  }
}

Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> ParseContext::ParseYshExpr(lexer::Lexer* lx, int start_symbol) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::expr_t* ast_node = nullptr;
  StackRoot _root0(&lx);
  StackRoot _root1(&e_parser);
  StackRoot _root2(&last_token);
  StackRoot _root3(&ast_node);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup3 = e_parser->Parse(lx, start_symbol);
    pnode = tup3.at0();
    last_token = tup3.at1();
    ast_node = this->tr->Expr(pnode);
  }
  return Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*>(ast_node, last_token);
}

Tuple3<syntax_asdl::pat_t*, syntax_asdl::Token*, syntax_asdl::Token*> ParseContext::ParseYshCasePattern(lexer::Lexer* lexer) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::pat_t* pattern = nullptr;
  StackRoot _root0(&lexer);
  StackRoot _root1(&e_parser);
  StackRoot _root2(&last_token);
  StackRoot _root3(&left_tok);
  StackRoot _root4(&pattern);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup4 = e_parser->Parse(lexer, grammar_nt::ysh_case_pat);
    pnode = tup4.at0();
    last_token = tup4.at1();
    left_tok = pnode->GetChild(0)->tok;
    pattern = this->tr->YshCasePattern(pnode);
  }
  return Tuple3<syntax_asdl::pat_t*, syntax_asdl::Token*, syntax_asdl::Token*>(pattern, left_tok, last_token);
}

syntax_asdl::Token* ParseContext::ParseProc(lexer::Lexer* lexer, syntax_asdl::Proc* out) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&lexer);
  StackRoot _root1(&out);
  StackRoot _root2(&e_parser);
  StackRoot _root3(&last_token);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup5 = e_parser->Parse(lexer, grammar_nt::ysh_proc);
    pnode = tup5.at0();
    last_token = tup5.at1();
    out->sig = this->tr->Proc(pnode);
  }
  return last_token;
}

syntax_asdl::Token* ParseContext::ParseFunc(lexer::Lexer* lexer, syntax_asdl::Func* out) {
  expr_parse::ExprParser* e_parser = nullptr;
  pnode::PNode* pnode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&lexer);
  StackRoot _root1(&out);
  StackRoot _root2(&e_parser);
  StackRoot _root3(&last_token);

  e_parser = this->_YshParser();
  {  // with
    ctx_PNodeAllocator ctx{e_parser};

    Tuple2<pnode::PNode*, syntax_asdl::Token*> tup6 = e_parser->Parse(lexer, grammar_nt::ysh_func);
    pnode = tup6.at0();
    last_token = tup6.at1();
    this->tr->YshFunc(pnode, out);
  }
  return last_token;
}

}  // define namespace parse_lib

namespace reader {  // define

using id_kind_asdl::Id;
using error::p_die;
BigStr* _PS2 = S_olB;

_Reader::_Reader(alloc::Arena* arena) {
  this->arena = arena;
  this->line_num = 1;
}

void _Reader::SetLineOffset(int n) {
  this->line_num = n;
}

BigStr* _Reader::_GetLine() {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

Tuple2<syntax_asdl::SourceLine*, int> _Reader::GetLine() {
  BigStr* line_str = nullptr;
  syntax_asdl::SourceLine* eof_line = nullptr;
  syntax_asdl::SourceLine* src_line = nullptr;
  StackRoot _root0(&line_str);
  StackRoot _root1(&eof_line);
  StackRoot _root2(&src_line);

  line_str = this->_GetLine();
  if (line_str == nullptr) {
    eof_line = nullptr;
    return Tuple2<syntax_asdl::SourceLine*, int>(eof_line, 0);
  }
  src_line = this->arena->AddLine(line_str, this->line_num);
  this->line_num += 1;
  return Tuple2<syntax_asdl::SourceLine*, int>(src_line, 0);
}

void _Reader::Reset() {
  ;  // pass
}

bool _Reader::LastLineHint() {
  return false;
}

DisallowedLineReader::DisallowedLineReader(alloc::Arena* arena, syntax_asdl::Token* blame_token) : ::reader::_Reader(arena) {
  this->blame_token = blame_token;
}

BigStr* DisallowedLineReader::_GetLine() {
  p_die(S_jwu, this->blame_token);
}

FileLineReader::FileLineReader(mylib::LineReader* f, alloc::Arena* arena) : ::reader::_Reader(arena) {
  this->f = f;
  this->last_line_hint = false;
}

BigStr* FileLineReader::_GetLine() {
  BigStr* line = nullptr;
  StackRoot _root0(&line);

  line = this->f->readline();
  if (len(line) == 0) {
    return nullptr;
  }
  if (!line->endswith(S_nfs)) {
    this->last_line_hint = true;
  }
  return line;
}

bool FileLineReader::LastLineHint() {
  return this->last_line_hint;
}

reader::FileLineReader* StringLineReader(BigStr* s, alloc::Arena* arena) {
  StackRoot _root0(&s);
  StackRoot _root1(&arena);

  return Alloc<FileLineReader>(Alloc<mylib::BufLineReader>(s), arena);
}

VirtualLineReader::VirtualLineReader(alloc::Arena* arena, List<Tuple2<syntax_asdl::SourceLine*, int>*>* lines, bool do_lossless) : ::reader::_Reader(arena) {
  this->lines = lines;
  this->do_lossless = do_lossless;
  this->num_lines = len(lines);
  this->pos = 0;
}

Tuple2<syntax_asdl::SourceLine*, int> VirtualLineReader::GetLine() {
  syntax_asdl::SourceLine* eof_line = nullptr;
  syntax_asdl::SourceLine* src_line = nullptr;
  int start_offset;
  StackRoot _root0(&eof_line);
  StackRoot _root1(&src_line);

  if (this->pos == this->num_lines) {
    eof_line = nullptr;
    return Tuple2<syntax_asdl::SourceLine*, int>(eof_line, 0);
  }
  Tuple2<syntax_asdl::SourceLine*, int>* tup0 = this->lines->at(this->pos);
  src_line = tup0->at0();
  start_offset = tup0->at1();
  this->pos += 1;
  if (this->do_lossless) {
    if (start_offset != 0) {
      this->arena->NewToken(Id::Lit_CharsWithoutPrefix, start_offset, 0, src_line);
    }
  }
  return Tuple2<syntax_asdl::SourceLine*, int>(src_line, start_offset);
}

BigStr* _PlainPromptInput(BigStr* prompt) {
  mylib::Writer* w = nullptr;
  BigStr* line = nullptr;
  StackRoot _root0(&prompt);
  StackRoot _root1(&w);
  StackRoot _root2(&line);

  w = mylib::Stderr();
  w->write(prompt);
  w->flush();
  line = mylib::Stdin()->readline();
  if (len(line) == 0) {
    throw Alloc<EOFError>();
  }
  return line;
}

InteractiveLineReader::InteractiveLineReader(alloc::Arena* arena, prompt::Evaluator* prompt_ev, history::Evaluator* hist_ev, py_readline::Readline* line_input, comp_ui::PromptState* prompt_state) : ::reader::_Reader(arena) {
  this->prompt_ev = prompt_ev;
  this->hist_ev = hist_ev;
  this->line_input = line_input;
  this->prompt_state = prompt_state;
  this->prev_line = nullptr;
  this->prompt_str = S_Aoo;
  this->Reset();
}

void InteractiveLineReader::Reset() {
  this->render_ps1 = true;
}

BigStr* InteractiveLineReader::_ReadlinePromptInput() {
  BigStr* line = nullptr;
  StackRoot _root0(&line);

  // if MYCPP
  {
    line = this->line_input->prompt_input(this->prompt_str);
  }
  // endif MYCPP
  return line;
}

BigStr* InteractiveLineReader::_GetLine() {
  BigStr* line = nullptr;
  StackRoot _root0(&line);

  if (this->render_ps1) {
    this->prompt_str = this->prompt_ev->EvalFirstPrompt();
    this->prompt_state->SetLastPrompt(this->prompt_str);
  }
  line = nullptr;
  try {
    if ((!this->line_input or (!mylib::Stdout()->isatty() or !mylib::Stdin()->isatty()))) {
      line = _PlainPromptInput(this->prompt_str);
    }
    else {
      line = this->_ReadlinePromptInput();
    }
  }
  catch (EOFError*) {
    print(S_gch);
  }
  if (line != nullptr) {
    line = this->hist_ev->Eval(line);
    if ((len(line->strip()) and (!(maybe_str_equals(line, this->prev_line)) and this->line_input != nullptr))) {
      this->line_input->add_history(line->rstrip());
      this->prev_line = line;
    }
  }
  this->prompt_str = _PS2;
  this->prompt_state->SetLastPrompt(this->prompt_str);
  this->render_ps1 = false;
  return line;
}

}  // define namespace reader

namespace syntax_abbrev {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_str;
using hnode_asdl::hnode;
using hnode_asdl::hnode_t;
using hnode_asdl::color_e;

void _AbbreviateToken(syntax_asdl::Token* tok, List<hnode_asdl::hnode_t*>* out) {
  BigStr* tok_str = nullptr;
  hnode::Leaf* n1 = nullptr;
  hnode::Leaf* n2 = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&out);
  StackRoot _root2(&tok_str);
  StackRoot _root3(&n1);
  StackRoot _root4(&n2);

  tok_str = tok->line->content->slice(tok->col, (tok->col + tok->length));
  n1 = runtime::NewLeaf(Id_str(tok->id, false), color_e::OtherConst);
  out->append(n1);
  n2 = runtime::NewLeaf(tok_str, color_e::StringConst);
  out->append(n2);
}

hnode_asdl::hnode_t* _Token(syntax_asdl::Token* obj) {
  hnode::Record* p_node = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);

  p_node = runtime::NewRecord(S_Aoo);
  p_node->left = S_eox;
  p_node->right = S_jye;
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  _AbbreviateToken(obj, p_node->unnamed_fields);
  return p_node;
}

hnode_asdl::hnode_t* _CompoundWord(syntax_asdl::CompoundWord* obj) {
  hnode::Record* p_node = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);

  p_node = runtime::NewRecord(S_pfC);
  p_node->left = S_ijB;
  p_node->right = S_hxb;
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(obj->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    p_node->unnamed_fields->append(part->PrettyTree(true));
  }
  return p_node;
}

hnode_asdl::hnode_t* _DoubleQuoted(syntax_asdl::DoubleQuoted* obj) {
  hnode::Record* p_node = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);

  if (obj->left->id != Id::Left_DoubleQuote) {
    return nullptr;
  }
  p_node = runtime::NewRecord(S_lAz);
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(obj->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    p_node->unnamed_fields->append(part->PrettyTree(true));
  }
  return p_node;
}

hnode_asdl::hnode_t* _SingleQuoted(syntax_asdl::SingleQuoted* obj) {
  hnode::Record* p_node = nullptr;
  hnode::Leaf* n2 = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);
  StackRoot _root2(&n2);

  if (obj->left->id != Id::Left_SingleQuote) {
    return nullptr;
  }
  p_node = runtime::NewRecord(S_mip);
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  n2 = runtime::NewLeaf(obj->sval, color_e::StringConst);
  p_node->unnamed_fields->append(n2);
  return p_node;
}

hnode_asdl::hnode_t* _SimpleVarSub(syntax_asdl::SimpleVarSub* obj) {
  hnode::Record* p_node = nullptr;
  syntax_asdl::Token* tok = nullptr;
  BigStr* var_name = nullptr;
  hnode::Leaf* n1 = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);
  StackRoot _root2(&tok);
  StackRoot _root3(&var_name);
  StackRoot _root4(&n1);

  p_node = runtime::NewRecord(S_Czx);
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  if ((obj->tok->id == Id::VSub_DollarName || obj->tok->id == Id::VSub_Number)) {
    tok = obj->tok;
    var_name = tok->line->content->slice((tok->col + 1), (tok->col + tok->length));
    n1 = runtime::NewLeaf(var_name, color_e::StringConst);
    p_node->unnamed_fields->append(n1);
  }
  else {
    n1 = runtime::NewLeaf(Id_str(obj->tok->id, false), color_e::OtherConst);
    p_node->unnamed_fields->append(n1);
  }
  return p_node;
}

hnode_asdl::hnode_t* _BracedVarSub(syntax_asdl::BracedVarSub* obj) {
  hnode::Record* p_node = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);

  p_node = runtime::NewRecord(S_hqF);
  if ((obj->prefix_op != nullptr or (obj->bracket_op != nullptr or obj->suffix_op != nullptr))) {
    return nullptr;
  }
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  _AbbreviateToken(obj->name_tok, p_node->unnamed_fields);
  return p_node;
}

hnode_asdl::hnode_t* _command__Simple(command::Simple* obj) {
  hnode::Record* p_node = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);

  p_node = runtime::NewRecord(S_sjc);
  if ((len(obj->more_env) or (obj->typed_args != nullptr or (obj->block != nullptr or obj->is_last_cmd == true)))) {
    return nullptr;
  }
  p_node->unnamed_fields = Alloc<List<hnode_asdl::hnode_t*>>();
  for (ListIter<syntax_asdl::word_t*> it(obj->words); !it.Done(); it.Next()) {
    syntax_asdl::word_t* w = it.Value();
    StackRoot _for(&w  );
    p_node->unnamed_fields->append(w->PrettyTree(true));
  }
  return p_node;
}

hnode_asdl::hnode_t* _expr__Var(expr::Var* obj) {
  hnode::Record* p_node = nullptr;
  hnode::Leaf* n1 = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);
  StackRoot _root2(&n1);

  p_node = runtime::NewRecord(S_CsA);
  n1 = runtime::NewLeaf(obj->name, color_e::StringConst);
  p_node->unnamed_fields = NewList<hnode_asdl::hnode_t*>(std::initializer_list<hnode_asdl::hnode_t*>{n1});
  return p_node;
}

hnode_asdl::hnode_t* _expr__Const(expr::Const* obj) {
  hnode::Record* p_node = nullptr;
  syntax_asdl::Token* tok = nullptr;
  hnode::Leaf* n1 = nullptr;
  hnode::Leaf* n2 = nullptr;
  StackRoot _root0(&obj);
  StackRoot _root1(&p_node);
  StackRoot _root2(&tok);
  StackRoot _root3(&n1);
  StackRoot _root4(&n2);

  p_node = runtime::NewRecord(S_wcu);
  tok = obj->c;
  n1 = runtime::NewLeaf(Id_str(tok->id, false), color_e::OtherConst);
  n2 = runtime::NewLeaf(tok->tval, color_e::StringConst);
  p_node->unnamed_fields = NewList<hnode_asdl::hnode_t*>(std::initializer_list<hnode_asdl::hnode_t*>{n1, n2});
  return p_node;
}

}  // define namespace syntax_abbrev

namespace arith_parse {  // define

using id_kind_asdl::Id;
using syntax_asdl::loc;
using syntax_asdl::arith_expr;
using syntax_asdl::arith_expr_t;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::Token;
using error::p_die;

syntax_asdl::arith_expr_t* NullIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&right);

  right = p->ParseUntil(bp);
  tdop::CheckLhsExpr(right, w);
  return Alloc<arith_expr::UnaryAssign>(word_::ArithId(w), right);
}

syntax_asdl::arith_expr_t* NullUnaryPlus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&t);
  StackRoot _root2(&right);

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(Id::Node_UnaryPlus, right);
}

syntax_asdl::arith_expr_t* NullUnaryMinus(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&t);
  StackRoot _root2(&right);

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(Id::Node_UnaryMinus, right);
}

syntax_asdl::arith_expr_t* LeftIncDec(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  int arith_id;
  int op_id;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&left);

  arith_id = word_::ArithId(w);
  if (arith_id == Id::Arith_DPlus) {
    op_id = Id::Node_PostDPlus;
  }
  else {
    if (arith_id == Id::Arith_DMinus) {
      op_id = Id::Node_PostDMinus;
    }
    else {
      assert(0);  // AssertionError
    }
  }
  tdop::CheckLhsExpr(left, w);
  return Alloc<arith_expr::UnaryAssign>(op_id, left);
}

syntax_asdl::arith_expr_t* LeftIndex(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int unused_bp) {
  syntax_asdl::arith_expr_t* index = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&left);
  StackRoot _root3(&index);
  StackRoot _root4(&tok);

  if (!tdop::IsIndexable(left)) {
    p_die(S_fAu, Alloc<loc::Word>(w));
  }
  index = p->ParseUntil(0);
  p->Eat(Id::Arith_RBracket);
  tok = static_cast<Token*>(w);
  return Alloc<arith_expr::Binary>(tok, left, index);
}

syntax_asdl::arith_expr_t* LeftTernary(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int bp) {
  syntax_asdl::arith_expr_t* true_expr = nullptr;
  syntax_asdl::arith_expr_t* false_expr = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&t);
  StackRoot _root2(&left);
  StackRoot _root3(&true_expr);
  StackRoot _root4(&false_expr);

  true_expr = p->ParseUntil(0);
  p->Eat(Id::Arith_Colon);
  false_expr = p->ParseUntil(bp);
  return Alloc<arith_expr::TernaryOp>(left, true_expr, false_expr);
}

}  // define namespace arith_parse

namespace bool_parse {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Kind;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using syntax_asdl::loc;
using syntax_asdl::word_t;
using syntax_asdl::word_e;
using syntax_asdl::bool_expr;
using syntax_asdl::bool_expr_t;
using syntax_asdl::Token;
using error::p_die;

BoolParser::BoolParser(word_parse::WordEmitter* w_parser) {
  this->w_parser = w_parser;
  this->words = Alloc<List<syntax_asdl::word_t*>>();
  this->cur_word = nullptr;
  this->bool_id = Id::Undefined_Tok;
  this->bool_kind = Kind::Undefined;
}

void BoolParser::_NextOne(types_asdl::lex_mode_t lex_mode) {
  int n;
  syntax_asdl::word_t* w = nullptr;
  StackRoot _root0(&w);

  n = len(this->words);
  if (n == 2) {
    this->words->set(0, this->words->at(1));
    this->cur_word = this->words->at(0);
    this->words->pop();
  }
  else {
    if ((n == 0 || n == 1)) {
      w = this->w_parser->ReadWord(lex_mode);
      if (n == 0) {
        this->words->append(w);
      }
      else {
        this->words->set(0, w);
      }
      this->cur_word = w;
    }
  }
  this->bool_id = word_::BoolId(this->cur_word);
  this->bool_kind = consts::GetKind(this->bool_id);
}

void BoolParser::_Next(types_asdl::lex_mode_t lex_mode) {
  while (true) {
    this->_NextOne(lex_mode);
    if (this->bool_id != Id::Op_Newline) {
      break;
    }
  }
}

syntax_asdl::word_t* BoolParser::_LookAhead() {
  int n;
  syntax_asdl::word_t* w = nullptr;
  StackRoot _root0(&w);

  n = len(this->words);
  if (n != 1) {
    assert(0);  // AssertionError
  }
  w = this->w_parser->ReadWord(lex_mode_e::DBracket);
  this->words->append(w);
  return w;
}

Tuple2<syntax_asdl::bool_expr_t*, syntax_asdl::Token*> BoolParser::Parse() {
  syntax_asdl::bool_expr_t* node = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&right);

  this->_Next();
  node = this->ParseExpr();
  if (this->bool_id != Id::Lit_DRightBracket) {
    p_die(S_qul, Alloc<loc::Word>(this->cur_word));
  }
  right = word_::LiteralToken(this->cur_word);
  return Tuple2<syntax_asdl::bool_expr_t*, syntax_asdl::Token*>(node, right);
}

bool BoolParser::_TestAtEnd() {
  return this->bool_id == Id::Lit_DRightBracket;
}

syntax_asdl::bool_expr_t* BoolParser::ParseForBuiltin() {
  syntax_asdl::bool_expr_t* node = nullptr;
  StackRoot _root0(&node);

  this->_Next();
  node = this->ParseExpr();
  if (this->bool_id != Id::Eof_Real) {
    p_die(StrFormat("Unexpected trailing word %s", word_::Pretty(this->cur_word)), Alloc<loc::Word>(this->cur_word));
  }
  return node;
}

syntax_asdl::bool_expr_t* BoolParser::ParseExpr() {
  syntax_asdl::bool_expr_t* left = nullptr;
  syntax_asdl::bool_expr_t* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&right);

  left = this->ParseTerm();
  if ((this->bool_id == Id::Op_DPipe || this->bool_id == Id::BoolUnary_o)) {
    this->_Next();
    right = this->ParseExpr();
    return Alloc<bool_expr::LogicalOr>(left, right);
  }
  else {
    return left;
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseTerm() {
  syntax_asdl::bool_expr_t* left = nullptr;
  syntax_asdl::bool_expr_t* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&right);

  left = this->ParseNegatedFactor();
  if ((this->bool_id == Id::Op_DAmp || this->bool_id == Id::BoolUnary_a)) {
    this->_Next();
    right = this->ParseTerm();
    return Alloc<bool_expr::LogicalAnd>(left, right);
  }
  else {
    return left;
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseNegatedFactor() {
  syntax_asdl::bool_expr_t* child = nullptr;
  StackRoot _root0(&child);

  if (this->bool_id == Id::KW_Bang) {
    this->_Next();
    child = this->ParseFactor();
    return Alloc<bool_expr::LogicalNot>(child);
  }
  else {
    return this->ParseFactor();
  }
}

syntax_asdl::bool_expr_t* BoolParser::ParseFactor() {
  int op;
  syntax_asdl::word_t* w = nullptr;
  int tag;
  syntax_asdl::CompoundWord* tilde = nullptr;
  syntax_asdl::bool_expr_t* node = nullptr;
  syntax_asdl::word_t* t2 = nullptr;
  int t2_bool_id;
  id_kind_asdl::Kind_t t2_bool_kind;
  syntax_asdl::word_t* left = nullptr;
  syntax_asdl::word_t* right = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&tilde);
  StackRoot _root2(&node);
  StackRoot _root3(&t2);
  StackRoot _root4(&left);
  StackRoot _root5(&right);

  if (this->bool_kind == Kind::BoolUnary) {
    op = this->bool_id;
    this->_Next();
    w = this->cur_word;
    tag = w->tag();
    if ((tag != word_e::Compound and tag != word_e::String)) {
      p_die(S_scC, Alloc<loc::Word>(w));
    }
    this->_Next();
    tilde = word_::TildeDetect(w);
    if (tilde) {
      w = tilde;
    }
    node = Alloc<bool_expr::Unary>(op, w);
    return node;
  }
  if (this->bool_kind == Kind::Word) {
    t2 = this->_LookAhead();
    t2_bool_id = word_::BoolId(t2);
    t2_bool_kind = consts::GetKind(t2_bool_id);
    if ((t2_bool_kind == Kind::BoolBinary or (t2_bool_id == Id::Op_Less || t2_bool_id == Id::Op_Great))) {
      left = this->cur_word;
      this->_Next();
      op = this->bool_id;
      if (t2_bool_id == Id::BoolBinary_EqualTilde) {
        this->_Next(lex_mode_e::BashRegex);
      }
      else {
        this->_Next();
      }
      right = this->cur_word;
      this->_Next();
      tilde = word_::TildeDetect(left);
      if (tilde) {
        left = tilde;
      }
      tilde = word_::TildeDetect(right);
      if (tilde) {
        right = tilde;
      }
      return Alloc<bool_expr::Binary>(op, left, right);
    }
    else {
      w = this->cur_word;
      tilde = word_::TildeDetect(w);
      if (tilde) {
        w = tilde;
      }
      this->_Next();
      return Alloc<bool_expr::WordTest>(w);
    }
  }
  if (this->bool_id == Id::Op_LParen) {
    this->_Next();
    node = this->ParseExpr();
    if (this->bool_id != Id::Op_RParen) {
      p_die(StrFormat("Expected ), got %s", word_::Pretty(this->cur_word)), Alloc<loc::Word>(this->cur_word));
    }
    this->_Next();
    return node;
  }
  p_die(StrFormat("Unexpected token in boolean expression (%s)", ui::PrettyId(this->bool_id)), Alloc<loc::Word>(this->cur_word));
}

}  // define namespace bool_parse

namespace braces {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using syntax_asdl::Token;
using syntax_asdl::CompoundWord;
using syntax_asdl::word;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word_part;
using syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using error::p_die;
int NO_STEP = 0;

_NotARange::_NotARange(BigStr* s) {
  ;  // pass
}

_RangeParser::_RangeParser(match::SimpleLexer* lexer, syntax_asdl::Token* blame_tok) {
  this->lexer = lexer;
  this->blame_tok = blame_tok;
  this->token_type = Id::Undefined_Tok;
  this->token_val = S_Aoo;
}

void _RangeParser::_Next() {
  Tuple2<int, BigStr*> tup0 = this->lexer->Next();
  this->token_type = tup0.at0();
  this->token_val = tup0.at1();
}

BigStr* _RangeParser::_Eat(int token_type) {
  BigStr* val = nullptr;
  StackRoot _root0(&val);

  if (this->token_type != token_type) {
    throw Alloc<_NotARange>(StrFormat("Expected %d, got %d", token_type, this->token_type));
  }
  val = this->token_val;
  this->_Next();
  return val;
}

int _RangeParser::_ParseStep() {
  int step;
  this->_Next();
  step = to_int(this->_Eat(Id::Range_Int));
  if (step == 0) {
    p_die(S_Cwz, this->blame_tok);
  }
  return step;
}

word_part::BracedRange* _RangeParser::_ParseRange(int range_kind) {
  BigStr* start = nullptr;
  BigStr* end = nullptr;
  int step;
  word_part::BracedRange* part = nullptr;
  StackRoot _root0(&start);
  StackRoot _root1(&end);
  StackRoot _root2(&part);

  start = this->token_val;
  this->_Next();
  this->_Eat(Id::Range_Dots);
  end = this->_Eat(range_kind);
  if (this->token_type == Id::Range_Dots) {
    step = this->_ParseStep();
  }
  else {
    step = NO_STEP;
  }
  part = Alloc<word_part::BracedRange>(this->blame_tok, range_kind, start, end, step);
  return part;
}

word_part::BracedRange* _RangeParser::Parse() {
  word_part::BracedRange* part = nullptr;
  int start;
  int end;
  int start_num;
  int end_num;
  bool upper1;
  bool upper2;
  StackRoot _root0(&part);

  this->_Next();
  if (this->token_type == Id::Range_Int) {
    part = this->_ParseRange(this->token_type);
    start = to_int(part->start);
    end = to_int(part->end);
    if (start < end) {
      if (part->step == NO_STEP) {
        part->step = 1;
      }
      if (part->step <= 0) {
        p_die(StrFormat("Invalid step %d for ascending integer range", part->step), this->blame_tok);
      }
    }
    else {
      if (start > end) {
        if (part->step == NO_STEP) {
          part->step = -1;
        }
        if (part->step >= 0) {
          p_die(StrFormat("Invalid step %d for descending integer range", part->step), this->blame_tok);
        }
      }
      else {
        part->step = 1;
      }
    }
  }
  else {
    if (this->token_type == Id::Range_Char) {
      part = this->_ParseRange(this->token_type);
      start_num = ord(part->start->at(0));
      end_num = ord(part->end->at(0));
      if (start_num < end_num) {
        if (part->step == NO_STEP) {
          part->step = 1;
        }
        if (part->step <= 0) {
          p_die(StrFormat("Invalid step %d for ascending character range", part->step), this->blame_tok);
        }
      }
      else {
        if (start_num > end_num) {
          if (part->step == NO_STEP) {
            part->step = -1;
          }
          if (part->step >= 0) {
            p_die(StrFormat("Invalid step %d for descending character range", part->step), this->blame_tok);
          }
        }
        else {
          part->step = 1;
        }
      }
      upper1 = part->start->isupper();
      upper2 = part->end->isupper();
      if (upper1 != upper2) {
        p_die(S_eio, this->blame_tok);
      }
    }
    else {
      throw Alloc<_NotARange>(S_Aoo);
    }
  }
  this->_Eat(Id::Eol_Tok);
  return part;
}

word_part::BracedRange* _RangePartDetect(syntax_asdl::Token* tok) {
  match::SimpleLexer* lx = nullptr;
  braces::_RangeParser* p = nullptr;
  word_part::BracedRange* part = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&lx);
  StackRoot _root2(&p);
  StackRoot _root3(&part);

  lx = match::BraceRangeLexer(lexer::TokenVal(tok));
  p = Alloc<_RangeParser>(lx, tok);
  try {
    part = p->Parse();
  }
  catch (_NotARange* e) {
    return nullptr;
  }
  return part;
}

_StackFrame::_StackFrame(List<syntax_asdl::word_part_t*>* cur_parts) {
  this->cur_parts = cur_parts;
  this->alt_part = Alloc<word_part::BracedTuple>(Alloc<List<syntax_asdl::CompoundWord*>>());
  this->saw_comma = false;
}

word::BracedTree* BraceDetect(syntax_asdl::CompoundWord* w) {
  List<syntax_asdl::word_part_t*>* cur_parts = nullptr;
  List<braces::_StackFrame*>* stack = nullptr;
  bool found;
  int i;
  bool append;
  syntax_asdl::word_part_t* UP_part = nullptr;
  int id_;
  braces::_StackFrame* new_frame = nullptr;
  syntax_asdl::word_part_t* range_part = nullptr;
  syntax_asdl::word_part_t* part2 = nullptr;
  syntax_asdl::Token* tok = nullptr;
  braces::_StackFrame* frame = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&cur_parts);
  StackRoot _root2(&stack);
  StackRoot _root3(&UP_part);
  StackRoot _root4(&new_frame);
  StackRoot _root5(&range_part);
  StackRoot _root6(&part2);
  StackRoot _root7(&tok);
  StackRoot _root8(&frame);

  if (len(w->parts) < 3) {
    return nullptr;
  }
  cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
  stack = Alloc<List<braces::_StackFrame*>>();
  found = false;
  i = 0;
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next(), ++i) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    append = true;
    UP_part = part;
    if (part->tag() == word_part_e::Literal) {
      Token* part = static_cast<Token*>(UP_part);
      id_ = part->id;
      if (id_ == Id::Lit_LBrace) {
        new_frame = Alloc<_StackFrame>(cur_parts);
        stack->append(new_frame);
        cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
        append = false;
        found = true;
      }
      else {
        if (id_ == Id::Lit_Comma) {
          if (len(stack)) {
            stack->at(-1)->saw_comma = true;
            stack->at(-1)->alt_part->words->append(Alloc<CompoundWord>(cur_parts));
            cur_parts = Alloc<List<syntax_asdl::word_part_t*>>();
            append = false;
          }
        }
        else {
          if (id_ == Id::Lit_RBrace) {
            if (len(stack) == 0) {
              return nullptr;
            }
            range_part = nullptr;
            if ((!stack->at(-1)->saw_comma and len(cur_parts) == 1)) {
              part2 = cur_parts->at(0);
              if (part2->tag() == word_part_e::Literal) {
                tok = static_cast<Token*>(part2);
                if (tok->id == Id::Lit_Chars) {
                  range_part = _RangePartDetect(tok);
                  if (range_part) {
                    frame = stack->pop();
                    cur_parts = frame->cur_parts;
                    cur_parts->append(range_part);
                    append = false;
                  }
                }
              }
            }
            if (!range_part) {
              if (!stack->at(-1)->saw_comma) {
                return nullptr;
              }
              stack->at(-1)->alt_part->words->append(Alloc<CompoundWord>(cur_parts));
              frame = stack->pop();
              cur_parts = frame->cur_parts;
              cur_parts->append(frame->alt_part);
              append = false;
            }
          }
        }
      }
    }
    if (append) {
      cur_parts->append(part);
    }
  }
  if (len(stack) != 0) {
    return nullptr;
  }
  if (found) {
    return Alloc<word::BracedTree>(cur_parts);
  }
  else {
    return nullptr;
  }
}

List<syntax_asdl::word_t*>* BraceDetectAll(List<syntax_asdl::CompoundWord*>* words) {
  List<syntax_asdl::word_t*>* out = nullptr;
  word::BracedTree* brace_tree = nullptr;
  StackRoot _root0(&words);
  StackRoot _root1(&out);
  StackRoot _root2(&brace_tree);

  out = Alloc<List<syntax_asdl::word_t*>>();
  for (ListIter<syntax_asdl::CompoundWord*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::CompoundWord* w = it.Value();
    StackRoot _for(&w  );
    brace_tree = BraceDetect(w);
    if (brace_tree) {
      out->append(brace_tree);
      continue;
    }
    out->append(w);
  }
  return out;
}

int _LeadingZeros(BigStr* s) {
  int n;
  StackRoot _root0(&s);

  n = 0;
  for (StrIter it(s); !it.Done(); it.Next()) {
    BigStr* c = it.Value();
    StackRoot _for(&c  );
    if (str_equals(c, S_wfw)) {
      n += 1;
    }
    else {
      break;
    }
  }
  return n;
}

BigStr* _IntToString(int i, int width) {
  BigStr* s = nullptr;
  int n;
  BigStr* pad = nullptr;
  StackRoot _root0(&s);
  StackRoot _root1(&pad);

  s = str(i);
  n = len(s);
  if (n < width) {
    pad = str_repeat(S_wfw, (width - n));
    return str_concat(pad, s);
  }
  else {
    return s;
  }
}

List<BigStr*>* _RangeStrings(word_part::BracedRange* part) {
  List<BigStr*>* nums = nullptr;
  int z1;
  int z2;
  int width;
  int n;
  int end;
  int step;
  List<BigStr*>* chars = nullptr;
  int ord_end;
  StackRoot _root0(&part);
  StackRoot _root1(&nums);
  StackRoot _root2(&chars);

  if (part->kind == Id::Range_Int) {
    nums = Alloc<List<BigStr*>>();
    z1 = _LeadingZeros(part->start);
    z2 = _LeadingZeros(part->end);
    if ((z1 == 0 and z2 == 0)) {
      width = 0;
    }
    else {
      if (z1 < z2) {
        width = len(part->end);
      }
      else {
        width = len(part->start);
      }
    }
    n = to_int(part->start);
    end = to_int(part->end);
    step = part->step;
    if (step > 0) {
      while (true) {
        nums->append(_IntToString(n, width));
        n += step;
        if (n > end) {
          break;
        }
      }
    }
    else {
      while (true) {
        nums->append(_IntToString(n, width));
        n += step;
        if (n < end) {
          break;
        }
      }
    }
    return nums;
  }
  else {
    chars = Alloc<List<BigStr*>>();
    n = ord(part->start);
    ord_end = ord(part->end);
    step = part->step;
    if (step > 0) {
      while (true) {
        chars->append(chr(n));
        n += step;
        if (n > ord_end) {
          break;
        }
      }
    }
    else {
      while (true) {
        chars->append(chr(n));
        n += step;
        if (n < ord_end) {
          break;
        }
      }
    }
    return chars;
  }
}

List<List<syntax_asdl::word_part_t*>*>* _ExpandPart(List<syntax_asdl::word_part_t*>* parts, int first_alt_index, List<List<syntax_asdl::word_part_t*>*>* suffixes) {
  List<List<syntax_asdl::word_part_t*>*>* out = nullptr;
  List<syntax_asdl::word_part_t*>* prefix = nullptr;
  syntax_asdl::word_part_t* expand_part = nullptr;
  syntax_asdl::word_part_t* UP_part = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* expanded_alts = nullptr;
  List<syntax_asdl::word_part_t*>* out_parts = nullptr;
  List<BigStr*>* strs = nullptr;
  List<syntax_asdl::word_part_t*>* out_parts_ = nullptr;
  word_part::BracedRangeDigit* t = nullptr;
  StackRoot _root0(&parts);
  StackRoot _root1(&suffixes);
  StackRoot _root2(&out);
  StackRoot _root3(&prefix);
  StackRoot _root4(&expand_part);
  StackRoot _root5(&UP_part);
  StackRoot _root6(&expanded_alts);
  StackRoot _root7(&out_parts);
  StackRoot _root8(&strs);
  StackRoot _root9(&out_parts_);
  StackRoot _root10(&t);

  out = Alloc<List<List<syntax_asdl::word_part_t*>*>>();
  prefix = parts->slice(0, first_alt_index);
  expand_part = parts->at(first_alt_index);
  UP_part = expand_part;
  switch (expand_part->tag()) {
    case word_part_e::BracedTuple: {
      word_part::BracedTuple* expand_part = static_cast<word_part::BracedTuple*>(UP_part);
      expanded_alts = Alloc<List<List<syntax_asdl::word_part_t*>*>>();
      for (ListIter<syntax_asdl::CompoundWord*> it(expand_part->words); !it.Done(); it.Next()) {
        syntax_asdl::CompoundWord* w = it.Value();
        StackRoot _for(&w      );
        expanded_alts->extend(_BraceExpand(w->parts));
      }
      for (ListIter<List<syntax_asdl::word_part_t*>*> it(expanded_alts); !it.Done(); it.Next()) {
        List<syntax_asdl::word_part_t*>* alt_parts = it.Value();
        StackRoot _for(&alt_parts      );
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(suffixes); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* suffix = it.Value();
          StackRoot _for(&suffix        );
          out_parts = Alloc<List<syntax_asdl::word_part_t*>>();
          out_parts->extend(prefix);
          out_parts->extend(alt_parts);
          out_parts->extend(suffix);
          out->append(out_parts);
        }
      }
    }
      break;
    case word_part_e::BracedRange: {
      word_part::BracedRange* expand_part = static_cast<word_part::BracedRange*>(UP_part);
      strs = _RangeStrings(expand_part);
      for (ListIter<BigStr*> it(strs); !it.Done(); it.Next()) {
        BigStr* s = it.Value();
        StackRoot _for(&s      );
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(suffixes); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* suffix = it.Value();
          StackRoot _for(&suffix        );
          out_parts_ = Alloc<List<syntax_asdl::word_part_t*>>();
          out_parts_->extend(prefix);
          t = Alloc<word_part::BracedRangeDigit>(s, expand_part->blame_tok);
          out_parts_->append(t);
          out_parts_->extend(suffix);
          out->append(out_parts_);
        }
      }
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
  return out;
}

List<List<syntax_asdl::word_part_t*>*>* _BraceExpand(List<syntax_asdl::word_part_t*>* parts) {
  int num_alts;
  int first_alt_index;
  int i;
  int tag;
  List<syntax_asdl::word_part_t*>* suffix = nullptr;
  List<syntax_asdl::word_part_t*>* tail_parts = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* suffixes = nullptr;
  StackRoot _root0(&parts);
  StackRoot _root1(&suffix);
  StackRoot _root2(&tail_parts);
  StackRoot _root3(&suffixes);

  mylib::MaybeCollect();
  num_alts = 0;
  first_alt_index = -1;
  i = 0;
  for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next(), ++i) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    tag = part->tag();
    if ((tag == word_part_e::BracedTuple || tag == word_part_e::BracedRange)) {
      num_alts += 1;
      if (num_alts == 1) {
        first_alt_index = i;
      }
      else {
        if (num_alts == 2) {
          break;
        }
      }
    }
  }
  if (num_alts == 0) {
    return NewList<List<syntax_asdl::word_part_t*>*>(std::initializer_list<List<syntax_asdl::word_part_t*>*>{parts});
  }
  else {
    if (num_alts == 1) {
      suffix = parts->slice((first_alt_index + 1));
      return _ExpandPart(parts, first_alt_index, NewList<List<syntax_asdl::word_part_t*>*>(std::initializer_list<List<syntax_asdl::word_part_t*>*>{suffix}));
    }
    else {
      tail_parts = parts->slice((first_alt_index + 1));
      suffixes = _BraceExpand(tail_parts);
      return _ExpandPart(parts, first_alt_index, suffixes);
    }
  }
}

List<syntax_asdl::CompoundWord*>* BraceExpandWords(List<syntax_asdl::word_t*>* words) {
  List<syntax_asdl::CompoundWord*>* out = nullptr;
  syntax_asdl::word_t* UP_w = nullptr;
  List<List<syntax_asdl::word_part_t*>*>* parts_list = nullptr;
  syntax_asdl::CompoundWord* expanded = nullptr;
  syntax_asdl::CompoundWord* ti = nullptr;
  StackRoot _root0(&words);
  StackRoot _root1(&out);
  StackRoot _root2(&UP_w);
  StackRoot _root3(&parts_list);
  StackRoot _root4(&expanded);
  StackRoot _root5(&ti);

  out = Alloc<List<syntax_asdl::CompoundWord*>>();
  for (ListIter<syntax_asdl::word_t*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::word_t* w = it.Value();
    StackRoot _for(&w  );
    UP_w = w;
    switch (w->tag()) {
      case word_e::BracedTree: {
        word::BracedTree* w = static_cast<word::BracedTree*>(UP_w);
        parts_list = _BraceExpand(w->parts);
        for (ListIter<List<syntax_asdl::word_part_t*>*> it(parts_list); !it.Done(); it.Next()) {
          List<syntax_asdl::word_part_t*>* parts = it.Value();
          StackRoot _for(&parts        );
          expanded = Alloc<CompoundWord>(parts);
          ti = word_::TildeDetect2(expanded);
          if (ti) {
            out->append(ti);
          }
          else {
            out->append(expanded);
          }
        }
      }
        break;
      case word_e::Compound: {
        CompoundWord* w = static_cast<CompoundWord*>(UP_w);
        out->append(w);
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  return out;
}

}  // define namespace braces

namespace cmd_parse {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using id_kind_asdl::Kind;
using id_kind_asdl::Kind_str;
using types_asdl::lex_mode_e;
using types_asdl::cmd_mode_e;
using types_asdl::cmd_mode_t;
using syntax_asdl::loc;
using syntax_asdl::SourceLine;
using syntax_asdl::source;
using syntax_asdl::parse_result;
using syntax_asdl::parse_result_t;
using syntax_asdl::command;
using syntax_asdl::command_t;
using syntax_asdl::condition;
using syntax_asdl::condition_t;
using syntax_asdl::for_iter;
using syntax_asdl::ArgList;
using syntax_asdl::BraceGroup;
using syntax_asdl::CaseArm;
using syntax_asdl::case_arg;
using syntax_asdl::IfArm;
using syntax_asdl::pat;
using syntax_asdl::pat_t;
using syntax_asdl::Redir;
using syntax_asdl::redir_param;
using syntax_asdl::redir_loc;
using syntax_asdl::redir_loc_t;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::CompoundWord;
using syntax_asdl::Token;
using syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using syntax_asdl::rhs_word;
using syntax_asdl::rhs_word_t;
using syntax_asdl::sh_lhs;
using syntax_asdl::sh_lhs_t;
using syntax_asdl::AssignPair;
using syntax_asdl::EnvPair;
using syntax_asdl::ParsedAssignment;
using syntax_asdl::assign_op_e;
using syntax_asdl::NameType;
using syntax_asdl::proc_sig;
using syntax_asdl::proc_sig_e;
using syntax_asdl::Proc;
using syntax_asdl::Func;
using syntax_asdl::SingleQuoted;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::List_of_command;
using syntax_asdl::VarDecl;
using syntax_asdl::ExprCommand;
using value_asdl::LiteralBlock;
using error::p_die;
int TAB_CH = 9;
int SPACE_CH = 32;

Tuple2<List<Tuple2<syntax_asdl::SourceLine*, int>*>*, Tuple2<syntax_asdl::SourceLine*, int>*> _ReadHereLines(reader::_Reader* line_reader, syntax_asdl::Redir* h, BigStr* delimiter) {
  List<Tuple2<syntax_asdl::SourceLine*, int>*>* here_lines = nullptr;
  Tuple2<syntax_asdl::SourceLine*, int>* last_line = nullptr;
  bool strip_leading_tabs;
  syntax_asdl::SourceLine* src_line = nullptr;
  BigStr* line = nullptr;
  int start_offset;
  int n;
  int i;
  StackRoot _root0(&line_reader);
  StackRoot _root1(&h);
  StackRoot _root2(&delimiter);
  StackRoot _root3(&here_lines);
  StackRoot _root4(&last_line);
  StackRoot _root5(&src_line);
  StackRoot _root6(&line);

  here_lines = Alloc<List<Tuple2<syntax_asdl::SourceLine*, int>*>>();
  last_line = nullptr;
  strip_leading_tabs = h->op->id == Id::Redir_DLessDash;
  while (true) {
    Tuple2<syntax_asdl::SourceLine*, int> tup0 = line_reader->GetLine();
    src_line = tup0.at0();
    if (src_line == nullptr) {
      p_die(S_pss, h->op);
    }
    line = src_line->content;
    start_offset = 0;
    if (strip_leading_tabs) {
      n = len(line);
      i = 0;
      while (i < n) {
        if (!(str_equals(line->at(i), S_mve))) {
          break;
        }
        i += 1;
      }
      start_offset = i;
    }
    if (str_equals(line->slice(start_offset)->rstrip(), delimiter)) {
      last_line = (Alloc<Tuple2<syntax_asdl::SourceLine*, int>>(src_line, start_offset));
      break;
    }
    here_lines->append((Alloc<Tuple2<syntax_asdl::SourceLine*, int>>(src_line, start_offset)));
  }
  return Tuple2<List<Tuple2<syntax_asdl::SourceLine*, int>*>*, Tuple2<syntax_asdl::SourceLine*, int>*>(here_lines, last_line);
}

List<syntax_asdl::word_part_t*>* _MakeLiteralHereLines(List<Tuple2<syntax_asdl::SourceLine*, int>*>* here_lines, alloc::Arena* arena, bool do_lossless) {
  List<syntax_asdl::word_part_t*>* tokens = nullptr;
  syntax_asdl::Token* t = nullptr;
  StackRoot _root0(&here_lines);
  StackRoot _root1(&arena);
  StackRoot _root2(&tokens);
  StackRoot _root3(&t);

  tokens = Alloc<List<syntax_asdl::word_part_t*>>();
  for (ListIter<Tuple2<syntax_asdl::SourceLine*, int>*> it(here_lines); !it.Done(); it.Next()) {
    Tuple2<syntax_asdl::SourceLine*, int>* tup1 = it.Value();
    syntax_asdl::SourceLine* src_line = tup1->at0();
    StackRoot _unpack_0(&src_line);
    int start_offset = tup1->at1();
    if (do_lossless) {
      arena->NewToken(Id::Lit_CharsWithoutPrefix, start_offset, 0, src_line);
    }
    t = arena->NewToken(Id::Lit_Chars, start_offset, len(src_line->content), src_line);
    tokens->append(t);
  }
  return tokens;
}

void _ParseHereDocBody(parse_lib::ParseContext* parse_ctx, syntax_asdl::Redir* r, reader::_Reader* line_reader, alloc::Arena* arena) {
  redir_param::HereDoc* h = nullptr;
  bool ok;
  BigStr* delimiter = nullptr;
  bool delim_quoted;
  List<Tuple2<syntax_asdl::SourceLine*, int>*>* here_lines = nullptr;
  Tuple2<syntax_asdl::SourceLine*, int>* last_line = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  syntax_asdl::SourceLine* end_line = nullptr;
  int start_offset;
  StackRoot _root0(&parse_ctx);
  StackRoot _root1(&r);
  StackRoot _root2(&line_reader);
  StackRoot _root3(&arena);
  StackRoot _root4(&h);
  StackRoot _root5(&delimiter);
  StackRoot _root6(&here_lines);
  StackRoot _root7(&last_line);
  StackRoot _root8(&w_parser);
  StackRoot _root9(&end_line);

  h = static_cast<redir_param::HereDoc*>(r->arg);
  Tuple3<bool, BigStr*, bool> tup2 = word_::StaticEval(h->here_begin);
  ok = tup2.at0();
  delimiter = tup2.at1();
  delim_quoted = tup2.at2();
  if (!ok) {
    p_die(S_xco, Alloc<loc::Word>(h->here_begin));
  }
  Tuple2<List<Tuple2<syntax_asdl::SourceLine*, int>*>*, Tuple2<syntax_asdl::SourceLine*, int>*> tup3 = _ReadHereLines(line_reader, r, delimiter);
  here_lines = tup3.at0();
  last_line = tup3.at1();
  if (delim_quoted) {
    h->stdin_parts = _MakeLiteralHereLines(here_lines, arena, parse_ctx->do_lossless);
  }
  else {
    line_reader = Alloc<reader::VirtualLineReader>(arena, here_lines, parse_ctx->do_lossless);
    w_parser = parse_ctx->MakeWordParserForHereDoc(line_reader);
    w_parser->ReadHereDocBody(h->stdin_parts);
  }
  Tuple2<syntax_asdl::SourceLine*, int>* tup4 = last_line;
  end_line = tup4->at0();
  start_offset = tup4->at1();
  if (parse_ctx->do_lossless) {
    arena->NewToken(Id::Lit_CharsWithoutPrefix, start_offset, 0, end_line);
  }
  h->here_end_tok = arena->NewToken(Id::Undefined_Tok, start_offset, len(end_line->content), end_line);
}

syntax_asdl::AssignPair* _MakeAssignPair(parse_lib::ParseContext* parse_ctx, syntax_asdl::ParsedAssignment* preparsed, alloc::Arena* arena) {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* close_token = nullptr;
  syntax_asdl::sh_lhs_t* lhs = nullptr;
  BigStr* var_name = nullptr;
  syntax_asdl::assign_op_t op;
  int left_pos;
  BigStr* index_str = nullptr;
  int s;
  BigStr* code_str = nullptr;
  tdop::TdopParser* a_parser = nullptr;
  source::Reparsed* src = nullptr;
  syntax_asdl::arith_expr_t* index_node = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int offset;
  int n;
  syntax_asdl::rhs_word_t* rhs = nullptr;
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&parse_ctx);
  StackRoot _root1(&preparsed);
  StackRoot _root2(&arena);
  StackRoot _root3(&left_token);
  StackRoot _root4(&close_token);
  StackRoot _root5(&lhs);
  StackRoot _root6(&var_name);
  StackRoot _root7(&index_str);
  StackRoot _root8(&code_str);
  StackRoot _root9(&a_parser);
  StackRoot _root10(&src);
  StackRoot _root11(&index_node);
  StackRoot _root12(&parts);
  StackRoot _root13(&rhs);
  StackRoot _root14(&w);

  left_token = preparsed->left;
  close_token = preparsed->close;
  lhs = nullptr;
  if (left_token->id == Id::Lit_VarLike) {
    if (lexer::IsPlusEquals(left_token)) {
      var_name = lexer::TokenSliceRight(left_token, -2);
      op = assign_op_e::PlusEqual;
    }
    else {
      var_name = lexer::TokenSliceRight(left_token, -1);
      op = assign_op_e::Equal;
    }
    lhs = Alloc<sh_lhs::Name>(left_token, var_name);
  }
  else {
    if ((left_token->id == Id::Lit_ArrayLhsOpen and parse_ctx->do_lossless)) {
      var_name = lexer::TokenSliceRight(left_token, -1);
      if (lexer::IsPlusEquals(close_token)) {
        op = assign_op_e::PlusEqual;
      }
      else {
        op = assign_op_e::Equal;
      }
      left_pos = (left_token->col + left_token->length);
      index_str = left_token->line->content->slice(left_pos, close_token->col);
      lhs = Alloc<sh_lhs::UnparsedIndex>(left_token, var_name, index_str);
    }
    else {
      if (left_token->id == Id::Lit_ArrayLhsOpen) {
        var_name = lexer::TokenSliceRight(left_token, -1);
        if (lexer::IsPlusEquals(close_token)) {
          op = assign_op_e::PlusEqual;
        }
        else {
          op = assign_op_e::Equal;
        }
        if (left_token->line == close_token->line) {
          s = (left_token->col + left_token->length);
          code_str = left_token->line->content->slice(s, close_token->col);
        }
        else {
          FAIL(kNotImplemented);  // Python NotImplementedError
        }
        a_parser = parse_ctx->MakeArithParser(code_str);
        src = Alloc<source::Reparsed>(S_mqm, left_token, close_token);
        {  // with
          alloc::ctx_SourceCode ctx{arena, src};

          index_node = a_parser->Parse();
        }
        lhs = Alloc<sh_lhs::IndexedName>(left_token, var_name, index_node);
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  parts = preparsed->w->parts;
  offset = preparsed->part_offset;
  n = len(parts);
  if (offset == n) {
    rhs = rhs_word::Empty;
  }
  else {
    w = Alloc<CompoundWord>(parts->slice(offset));
    word_::TildeDetectAssign(w);
    rhs = w;
  }
  return Alloc<AssignPair>(left_token, lhs, op, rhs);
}

void _AppendMoreEnv(List<syntax_asdl::ParsedAssignment*>* preparsed_list, List<syntax_asdl::EnvPair*>* more_env) {
  syntax_asdl::Token* left_token = nullptr;
  BigStr* var_name = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int n;
  int offset;
  syntax_asdl::rhs_word_t* rhs = nullptr;
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&preparsed_list);
  StackRoot _root1(&more_env);
  StackRoot _root2(&left_token);
  StackRoot _root3(&var_name);
  StackRoot _root4(&parts);
  StackRoot _root5(&rhs);
  StackRoot _root6(&w);

  for (ListIter<syntax_asdl::ParsedAssignment*> it(preparsed_list); !it.Done(); it.Next()) {
    syntax_asdl::ParsedAssignment* preparsed = it.Value();
    StackRoot _for(&preparsed  );
    left_token = preparsed->left;
    if (left_token->id != Id::Lit_VarLike) {
      p_die(S_pqq, left_token);
    }
    if (lexer::IsPlusEquals(left_token)) {
      p_die(S_amq, left_token);
    }
    var_name = lexer::TokenSliceRight(left_token, -1);
    parts = preparsed->w->parts;
    n = len(parts);
    offset = preparsed->part_offset;
    if (offset == n) {
      rhs = rhs_word::Empty;
    }
    else {
      w = Alloc<CompoundWord>(parts->slice(offset));
      word_::TildeDetectAssign(w);
      rhs = w;
    }
    more_env->append(Alloc<EnvPair>(left_token, var_name, rhs));
  }
}

Tuple2<List<syntax_asdl::ParsedAssignment*>*, List<syntax_asdl::CompoundWord*>*> _SplitSimpleCommandPrefix(List<syntax_asdl::CompoundWord*>* words) {
  List<syntax_asdl::ParsedAssignment*>* preparsed_list = nullptr;
  List<syntax_asdl::CompoundWord*>* suffix_words = nullptr;
  bool done_prefix;
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* close_token = nullptr;
  int part_offset;
  StackRoot _root0(&words);
  StackRoot _root1(&preparsed_list);
  StackRoot _root2(&suffix_words);
  StackRoot _root3(&left_token);
  StackRoot _root4(&close_token);

  preparsed_list = Alloc<List<syntax_asdl::ParsedAssignment*>>();
  suffix_words = Alloc<List<syntax_asdl::CompoundWord*>>();
  done_prefix = false;
  for (ListIter<syntax_asdl::CompoundWord*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::CompoundWord* w = it.Value();
    StackRoot _for(&w  );
    if (done_prefix) {
      suffix_words->append(w);
      continue;
    }
    Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> tup5 = word_::DetectShAssignment(w);
    left_token = tup5.at0();
    close_token = tup5.at1();
    part_offset = tup5.at2();
    if (left_token) {
      preparsed_list->append(Alloc<ParsedAssignment>(left_token, close_token, part_offset, w));
    }
    else {
      done_prefix = true;
      suffix_words->append(w);
    }
  }
  return Tuple2<List<syntax_asdl::ParsedAssignment*>*, List<syntax_asdl::CompoundWord*>*>(preparsed_list, suffix_words);
}

command::Simple* _MakeSimpleCommand(List<syntax_asdl::ParsedAssignment*>* preparsed_list, List<syntax_asdl::CompoundWord*>* suffix_words, syntax_asdl::ArgList* typed_args, value_asdl::LiteralBlock* block) {
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::Token* blame_tok = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  List<syntax_asdl::EnvPair*>* more_env = nullptr;
  StackRoot _root0(&preparsed_list);
  StackRoot _root1(&suffix_words);
  StackRoot _root2(&typed_args);
  StackRoot _root3(&block);
  StackRoot _root4(&part0);
  StackRoot _root5(&blame_tok);
  StackRoot _root6(&words2);
  StackRoot _root7(&words3);
  StackRoot _root8(&more_env);

  for (ListIter<syntax_asdl::ParsedAssignment*> it(preparsed_list); !it.Done(); it.Next()) {
    syntax_asdl::ParsedAssignment* preparsed = it.Value();
    StackRoot _for(&preparsed  );
    if (word_::HasArrayPart(preparsed->w)) {
      p_die(S_fts, Alloc<loc::Word>(preparsed->w));
    }
  }
  part0 = suffix_words->at(0)->parts->at(0);
  blame_tok = location::LeftTokenForWordPart(part0);
  words2 = braces::BraceDetectAll(suffix_words);
  words3 = word_::TildeDetectAll(words2);
  more_env = Alloc<List<syntax_asdl::EnvPair*>>();
  _AppendMoreEnv(preparsed_list, more_env);
  return Alloc<command::Simple>(blame_tok, more_env, words3, typed_args, block, false);
}

VarChecker::VarChecker() {
  this->tokens = Alloc<List<syntax_asdl::Token*>>();
  this->names = Alloc<List<Dict<BigStr*, int>*>>();
}

void VarChecker::Push(syntax_asdl::Token* blame_tok) {
  Dict<BigStr*, int>* entry = nullptr;
  StackRoot _root0(&blame_tok);
  StackRoot _root1(&entry);

  if (len(this->tokens) != 0) {
    if ((this->tokens->at(0)->id != Id::KW_Proc && this->tokens->at(0)->id != Id::KW_Func)) {
      if (blame_tok->id == Id::KW_Proc) {
        p_die(S_fot, blame_tok);
      }
      if (blame_tok->id == Id::KW_Func) {
        p_die(S_pih, blame_tok);
      }
    }
    else {
      if ((blame_tok->id != Id::KW_Proc && blame_tok->id != Id::KW_Func)) {
        p_die(S_jlb, blame_tok);
      }
    }
  }
  this->tokens->append(blame_tok);
  entry = Alloc<Dict<BigStr*, int>>();
  this->names->append(entry);
}

void VarChecker::Pop() {
  this->names->pop();
  this->tokens->pop();
}

void VarChecker::Check(int keyword_id, BigStr* var_name, syntax_asdl::Token* blame_tok) {
  Dict<BigStr*, int>* top = nullptr;
  StackRoot _root0(&var_name);
  StackRoot _root1(&blame_tok);
  StackRoot _root2(&top);

  if (len(this->names) == 0) {
    return ;
  }
  top = this->names->at(-1);
  if (keyword_id == Id::KW_Var) {
    if (dict_contains(top, var_name)) {
      p_die(StrFormat("%r was already declared", var_name), blame_tok);
    }
    else {
      top->set(var_name, keyword_id);
    }
  }
  if (keyword_id == Id::KW_SetVar) {
    if (!dict_contains(top, var_name)) {
      p_die(StrFormat("setvar couldn't find matching 'var %s' (OILS-ERR-10)", var_name), blame_tok);
    }
  }
}

ctx_VarChecker::ctx_VarChecker(cmd_parse::VarChecker* var_checker, syntax_asdl::Token* blame_tok) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->var_checker)));
  var_checker->Push(blame_tok);
  this->var_checker = var_checker;
}

ctx_VarChecker::~ctx_VarChecker() {
  this->var_checker->Pop();
  gHeap.PopRoot();
}

ctx_CmdMode::ctx_CmdMode(cmd_parse::CommandParser* cmd_parse, types_asdl::cmd_mode_t new_cmd_mode) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->cmd_parse)));
  this->cmd_parse = cmd_parse;
  this->prev_cmd_mode = cmd_parse->cmd_mode;
  cmd_parse->cmd_mode = new_cmd_mode;
}

ctx_CmdMode::~ctx_CmdMode() {
  this->cmd_parse->cmd_mode = this->prev_cmd_mode;
  gHeap.PopRoot();
}
GLOBAL_LIST(SECONDARY_KEYWORDS, int, 7, {Id::KW_Do COMMA Id::KW_Done COMMA Id::KW_Then COMMA Id::KW_Fi COMMA Id::KW_Elif COMMA Id::KW_Else COMMA Id::KW_Esac});

CommandParser::CommandParser(parse_lib::ParseContext* parse_ctx, optview::Parse* parse_opts, word_parse::WordParser* w_parser, lexer::Lexer* lexer, reader::_Reader* line_reader, int eof_id) {
  this->parse_ctx = parse_ctx;
  this->aliases = parse_ctx->aliases;
  this->parse_opts = parse_opts;
  this->w_parser = w_parser;
  this->lexer = lexer;
  this->line_reader = line_reader;
  this->eof_id = eof_id;
  this->arena = line_reader->arena;
  this->aliases_in_flight = Alloc<List<Tuple2<BigStr*, int>*>>();
  this->allow_block = true;
  this->hay_attrs_stack = Alloc<List<bool>>();
  this->var_checker = Alloc<VarChecker>();
  this->cmd_mode = cmd_mode_e::Shell;
  this->Reset();
}

void CommandParser::Init_AliasesInFlight(List<Tuple2<BigStr*, int>*>* aliases_in_flight) {
  StackRoot _root0(&aliases_in_flight);

  this->aliases_in_flight = aliases_in_flight;
}

void CommandParser::Reset() {
  this->next_lex_mode = lex_mode_e::ShCommand;
  this->cur_word = nullptr;
  this->c_kind = Kind::Undefined;
  this->c_id = Id::Undefined_Tok;
  this->pending_here_docs = Alloc<List<syntax_asdl::Redir*>>();
}

void CommandParser::ResetInputObjects() {
  this->w_parser->Reset();
  this->lexer->ResetInputObjects();
  this->line_reader->Reset();
}

void CommandParser::_SetNext() {
  this->next_lex_mode = lex_mode_e::ShCommand;
}

void CommandParser::_SetNextBrack() {
  this->next_lex_mode = lex_mode_e::ShCommandFakeBrack;
}

void CommandParser::_GetWord() {
  syntax_asdl::word_t* w = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&tok);

  if (this->next_lex_mode != lex_mode_e::Undefined) {
    w = this->w_parser->ReadWord(this->next_lex_mode);
    if (w->tag() == word_e::Operator) {
      tok = static_cast<Token*>(w);
      if (tok->id == Id::Op_Newline) {
        for (ListIter<syntax_asdl::Redir*> it(this->pending_here_docs); !it.Done(); it.Next()) {
          syntax_asdl::Redir* h = it.Value();
          StackRoot _for(&h        );
          _ParseHereDocBody(this->parse_ctx, h, this->line_reader, this->arena);
        }
        this->pending_here_docs->clear();
      }
    }
    this->cur_word = w;
    this->c_kind = word_::CommandKind(this->cur_word);
    this->c_id = word_::CommandId(this->cur_word);
    this->next_lex_mode = lex_mode_e::Undefined;
  }
}

syntax_asdl::word_t* CommandParser::_Eat(int c_id, BigStr* msg) {
  syntax_asdl::word_t* skipped = nullptr;
  StackRoot _root0(&msg);
  StackRoot _root1(&skipped);

  this->_GetWord();
  if (this->c_id != c_id) {
    if (msg == nullptr) {
      msg = StrFormat("Expected word type %s, got %s", ui::PrettyId(c_id), ui::PrettyId(this->c_id));
    }
    p_die(msg, Alloc<loc::Word>(this->cur_word));
  }
  skipped = this->cur_word;
  this->_SetNext();
  return skipped;
}

void CommandParser::_NewlineOk() {
  this->_GetWord();
  if (this->c_id == Id::Op_Newline) {
    this->_SetNext();
  }
}

bool CommandParser::_AtSecondaryKeyword() {
  this->_GetWord();
  if (list_contains(SECONDARY_KEYWORDS, this->c_id)) {
    return true;
  }
  return false;
}

syntax_asdl::Redir* CommandParser::ParseRedirect() {
  syntax_asdl::Token* op_tok = nullptr;
  BigStr* op_val = nullptr;
  int pos;
  syntax_asdl::redir_loc_t* where = nullptr;
  redir_param::HereDoc* arg = nullptr;
  syntax_asdl::Redir* r = nullptr;
  syntax_asdl::CompoundWord* arg_word = nullptr;
  syntax_asdl::CompoundWord* tilde = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  bool is_multiline;
  syntax_asdl::SingleQuoted* sq = nullptr;
  syntax_asdl::DoubleQuoted* dq = nullptr;
  redir_param::HereWord* param = nullptr;
  StackRoot _root0(&op_tok);
  StackRoot _root1(&op_val);
  StackRoot _root2(&where);
  StackRoot _root3(&arg);
  StackRoot _root4(&r);
  StackRoot _root5(&arg_word);
  StackRoot _root6(&tilde);
  StackRoot _root7(&part0);
  StackRoot _root8(&sq);
  StackRoot _root9(&dq);
  StackRoot _root10(&param);

  this->_GetWord();
  op_tok = static_cast<Token*>(this->cur_word);
  op_val = lexer::TokenVal(op_tok);
  if (str_equals(op_val->at(0), S_ato)) {
    pos = op_val->find(S_cEn);
    where = Alloc<redir_loc::VarName>(op_val->slice(1, pos));
  }
  else {
    if (op_val->at(0)->isdigit()) {
      pos = 1;
      if (op_val->at(1)->isdigit()) {
        pos = 2;
      }
      where = Alloc<redir_loc::Fd>(to_int(op_val->slice(0, pos)));
    }
    else {
      where = Alloc<redir_loc::Fd>(consts::RedirDefaultFd(op_tok->id));
    }
  }
  this->_SetNext();
  this->_GetWord();
  if (this->c_kind != Kind::Word) {
    p_die(S_apz, Alloc<loc::Word>(this->cur_word));
  }
  if ((op_tok->id == Id::Redir_DLess || op_tok->id == Id::Redir_DLessDash)) {
    arg = redir_param::HereDoc::CreateNull();
    arg->here_begin = this->cur_word;
    arg->stdin_parts = Alloc<List<syntax_asdl::word_part_t*>>();
    r = Alloc<Redir>(op_tok, where, arg);
    this->pending_here_docs->append(r);
    this->_SetNext();
    return r;
  }
  arg_word = static_cast<CompoundWord*>(this->cur_word);
  tilde = word_::TildeDetect(arg_word);
  if (tilde) {
    arg_word = tilde;
  }
  this->_SetNext();
  if (op_tok->id == Id::Redir_TLess) {
    part0 = arg_word->parts->at(0);
    is_multiline = false;
    switch (part0->tag()) {
      case word_part_e::SingleQuoted: {
        sq = static_cast<SingleQuoted*>(part0);
        if ((sq->left->id == Id::Left_TSingleQuote || sq->left->id == Id::Left_RTSingleQuote || sq->left->id == Id::Left_UTSingleQuote || sq->left->id == Id::Left_BTSingleQuote)) {
          is_multiline = true;
        }
      }
        break;
      case word_part_e::DoubleQuoted: {
        dq = static_cast<DoubleQuoted*>(part0);
        if ((dq->left->id == Id::Left_TDoubleQuote || dq->left->id == Id::Left_DollarTDoubleQuote)) {
          is_multiline = true;
        }
      }
        break;
    }
    param = Alloc<redir_param::HereWord>(arg_word, is_multiline);
    return Alloc<Redir>(op_tok, where, param);
  }
  return Alloc<Redir>(op_tok, where, arg_word);
}

List<syntax_asdl::Redir*>* CommandParser::_ParseRedirectList() {
  List<syntax_asdl::Redir*>* redirects = nullptr;
  syntax_asdl::Redir* node = nullptr;
  StackRoot _root0(&redirects);
  StackRoot _root1(&node);

  redirects = Alloc<List<syntax_asdl::Redir*>>();
  while (true) {
    this->_GetWord();
    if (this->c_kind != Kind::Redir) {
      break;
    }
    node = this->ParseRedirect();
    redirects->append(node);
    this->_SetNext();
  }
  return redirects;
}

syntax_asdl::command_t* CommandParser::_MaybeParseRedirectList(syntax_asdl::command_t* node) {
  List<syntax_asdl::Redir*>* redirects = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&redirects);

  this->_GetWord();
  if (this->c_kind != Kind::Redir) {
    return node;
  }
  redirects = NewList<syntax_asdl::Redir*>(std::initializer_list<syntax_asdl::Redir*>{this->ParseRedirect()});
  while (true) {
    this->_GetWord();
    if (this->c_kind != Kind::Redir) {
      break;
    }
    redirects->append(this->ParseRedirect());
    this->_SetNext();
  }
  return Alloc<command::Redirect>(node, redirects);
}

Tuple4<List<syntax_asdl::Redir*>*, List<syntax_asdl::CompoundWord*>*, syntax_asdl::ArgList*, value_asdl::LiteralBlock*> CommandParser::_ScanSimpleCommand() {
  List<syntax_asdl::Redir*>* redirects = nullptr;
  List<syntax_asdl::CompoundWord*>* words = nullptr;
  syntax_asdl::ArgList* typed_args = nullptr;
  value_asdl::LiteralBlock* block = nullptr;
  bool first_word_caps;
  int i;
  id_kind_asdl::Kind_t kind2;
  syntax_asdl::Redir* node = nullptr;
  syntax_asdl::CompoundWord* w = nullptr;
  syntax_asdl::Token* bad_tok = nullptr;
  bool ok;
  BigStr* word_str = nullptr;
  bool quoted;
  int prev_byte;
  int next_id;
  syntax_asdl::BraceGroup* brace_group = nullptr;
  List<syntax_asdl::SourceLine*>* lines = nullptr;
  StackRoot _root0(&redirects);
  StackRoot _root1(&words);
  StackRoot _root2(&typed_args);
  StackRoot _root3(&block);
  StackRoot _root4(&node);
  StackRoot _root5(&w);
  StackRoot _root6(&bad_tok);
  StackRoot _root7(&word_str);
  StackRoot _root8(&brace_group);
  StackRoot _root9(&lines);

  redirects = Alloc<List<syntax_asdl::Redir*>>();
  words = Alloc<List<syntax_asdl::CompoundWord*>>();
  typed_args = nullptr;
  block = nullptr;
  first_word_caps = false;
  i = 0;
  while (true) {
    this->_GetWord();
    kind2 = this->c_kind;
    if ((kind2 == Kind::Word and (this->parse_opts->parse_brace() and (this->c_id == Id::Lit_LBrace || this->c_id == Id::Lit_RBrace)))) {
      kind2 = Kind::Op;
    }
    if (kind2 == Kind::Redir) {
      node = this->ParseRedirect();
      redirects->append(node);
    }
    else {
      if (kind2 == Kind::Word) {
        w = static_cast<CompoundWord*>(this->cur_word);
        if (i == 0) {
          if (this->parse_opts->strict_parse_equals()) {
            bad_tok = word_::CheckLeadingEquals(w);
            if (bad_tok) {
              p_die(S_Fos, bad_tok);
            }
          }
          Tuple3<bool, BigStr*, bool> tup6 = word_::StaticEval(w);
          ok = tup6.at0();
          word_str = tup6.at1();
          quoted = tup6.at2();
          if ((ok and (len(word_str) and (word_str->at(0)->isupper() and !word_str->isupper())))) {
            first_word_caps = true;
          }
        }
        words->append(w);
      }
      else {
        break;
      }
    }
    this->_SetNextBrack();
    i += 1;
  }
  this->_GetWord();
  if (this->c_id == Id::Op_LParen) {
    prev_byte = this->lexer->ByteLookBack();
    if ((prev_byte != SPACE_CH && prev_byte != TAB_CH)) {
      if (this->parse_opts->parse_at()) {
        p_die(S_ezD, Alloc<loc::Word>(this->cur_word));
      }
      else {
        p_die(S_bjp, Alloc<loc::Word>(this->cur_word));
      }
    }
    next_id = this->lexer->LookPastSpace(lex_mode_e::ShCommand);
    if (next_id == Id::Op_RParen) {
      p_die(S_ACD, Alloc<loc::Word>(this->cur_word));
    }
    typed_args = this->w_parser->ParseProcCallArgs(grammar_nt::ysh_eager_arglist);
    this->_SetNext();
  }
  else {
    if (this->c_id == Id::Op_LBracket) {
      typed_args = this->w_parser->ParseProcCallArgs(grammar_nt::ysh_lazy_arglist);
      this->_SetNext();
    }
  }
  this->_GetWord();
  if (this->c_kind == Kind::Redir) {
    redirects->extend(this->_ParseRedirectList());
  }
  if ((this->parse_opts->parse_brace() and (this->c_id == Id::Lit_LBrace and this->allow_block))) {
    this->hay_attrs_stack->append(first_word_caps);
    brace_group = this->ParseBraceGroup();
    lines = this->arena->SaveLinesAndDiscard(brace_group->left, brace_group->right);
    block = Alloc<LiteralBlock>(brace_group, lines);
    this->hay_attrs_stack->pop();
  }
  this->_GetWord();
  if (this->c_kind == Kind::Redir) {
    redirects->extend(this->_ParseRedirectList());
  }
  return Tuple4<List<syntax_asdl::Redir*>*, List<syntax_asdl::CompoundWord*>*, syntax_asdl::ArgList*, value_asdl::LiteralBlock*>(redirects, words, typed_args, block);
}

syntax_asdl::command_t* CommandParser::_MaybeExpandAliases(List<syntax_asdl::CompoundWord*>* words) {
  List<Tuple2<BigStr*, int>*>* aliases_in_flight = nullptr;
  BigStr* first_word_str = nullptr;
  loc::Word* argv0_loc = nullptr;
  List<BigStr*>* expanded = nullptr;
  int i;
  int n;
  syntax_asdl::CompoundWord* w = nullptr;
  bool ok;
  BigStr* word_str = nullptr;
  bool quoted;
  BigStr* alias_exp = nullptr;
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::Token* right_tok = nullptr;
  BigStr* words_str = nullptr;
  BigStr* code_str = nullptr;
  alloc::Arena* arena = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  cmd_parse::CommandParser* cp = nullptr;
  source::Alias* src = nullptr;
  command::CommandList* node = nullptr;
  StackRoot _root0(&words);
  StackRoot _root1(&aliases_in_flight);
  StackRoot _root2(&first_word_str);
  StackRoot _root3(&argv0_loc);
  StackRoot _root4(&expanded);
  StackRoot _root5(&w);
  StackRoot _root6(&word_str);
  StackRoot _root7(&alias_exp);
  StackRoot _root8(&left_tok);
  StackRoot _root9(&right_tok);
  StackRoot _root10(&words_str);
  StackRoot _root11(&code_str);
  StackRoot _root12(&arena);
  StackRoot _root13(&line_reader);
  StackRoot _root14(&cp);
  StackRoot _root15(&src);
  StackRoot _root16(&node);

  aliases_in_flight = len(this->aliases_in_flight) ? this->aliases_in_flight : Alloc<List<Tuple2<BigStr*, int>*>>();
  first_word_str = nullptr;
  argv0_loc = Alloc<loc::Word>(words->at(0));
  expanded = Alloc<List<BigStr*>>();
  i = 0;
  n = len(words);
  while (i < n) {
    w = words->at(i);
    Tuple3<bool, BigStr*, bool> tup7 = word_::StaticEval(w);
    ok = tup7.at0();
    word_str = tup7.at1();
    quoted = tup7.at2();
    if ((!ok or quoted)) {
      break;
    }
    alias_exp = this->aliases->get(word_str);
    if (alias_exp == nullptr) {
      break;
    }
    if (list_contains(aliases_in_flight, (Alloc<Tuple2<BigStr*, int>>(word_str, i)))) {
      break;
    }
    if (i == 0) {
      first_word_str = word_str;
    }
    aliases_in_flight->append((Alloc<Tuple2<BigStr*, int>>(word_str, i)));
    expanded->append(alias_exp);
    i += 1;
    if (!alias_exp->endswith(S_yfw)) {
      expanded->append(S_yfw);
      break;
    }
  }
  if (len(expanded) == 0) {
    return nullptr;
  }
  if (i < n) {
    left_tok = location::LeftTokenForWord(words->at(i));
    right_tok = location::RightTokenForWord(words->at(-1));
    words_str = this->arena->SnipCodeString(left_tok, right_tok);
    expanded->append(words_str);
  }
  code_str = S_Aoo->join(expanded);
  arena = this->arena;
  line_reader = reader::StringLineReader(code_str, arena);
  cp = this->parse_ctx->MakeOshParser(line_reader);
  cp->Init_AliasesInFlight(aliases_in_flight);
  src = Alloc<source::Alias>(first_word_str, argv0_loc);
  {  // with
    alloc::ctx_SourceCode ctx{arena, src};

    {  // with
      parse_lib::ctx_Alias ctx{this->parse_ctx->trail};

      try {
        node = cp->_ParseCommandTerm();
      }
      catch (error::Parse* e) {
        throw;
      }
    }
  }
  return node;
}

syntax_asdl::command_t* CommandParser::ParseSimpleCommand() {
  List<syntax_asdl::Redir*>* redirects = nullptr;
  List<syntax_asdl::CompoundWord*>* words = nullptr;
  syntax_asdl::ArgList* typed_args = nullptr;
  value_asdl::LiteralBlock* block = nullptr;
  syntax_asdl::Token* typed_loc = nullptr;
  List<syntax_asdl::ParsedAssignment*>* preparsed_list = nullptr;
  List<syntax_asdl::CompoundWord*>* suffix_words = nullptr;
  List<syntax_asdl::AssignPair*>* pairs = nullptr;
  syntax_asdl::Token* left_tok = nullptr;
  command::ShAssignment* assign_node = nullptr;
  id_kind_asdl::Kind_t kind;
  syntax_asdl::Token* kw_token = nullptr;
  syntax_asdl::CompoundWord* arg_word = nullptr;
  syntax_asdl::command_t* expanded_node = nullptr;
  List<syntax_asdl::EnvPair*>* more_env = nullptr;
  command::ExpandedAlias* exp = nullptr;
  command::Simple* node = nullptr;
  StackRoot _root0(&redirects);
  StackRoot _root1(&words);
  StackRoot _root2(&typed_args);
  StackRoot _root3(&block);
  StackRoot _root4(&typed_loc);
  StackRoot _root5(&preparsed_list);
  StackRoot _root6(&suffix_words);
  StackRoot _root7(&pairs);
  StackRoot _root8(&left_tok);
  StackRoot _root9(&assign_node);
  StackRoot _root10(&kw_token);
  StackRoot _root11(&arg_word);
  StackRoot _root12(&expanded_node);
  StackRoot _root13(&more_env);
  StackRoot _root14(&exp);
  StackRoot _root15(&node);

  Tuple4<List<syntax_asdl::Redir*>*, List<syntax_asdl::CompoundWord*>*, syntax_asdl::ArgList*, value_asdl::LiteralBlock*> tup8 = this->_ScanSimpleCommand();
  redirects = tup8.at0();
  words = tup8.at1();
  typed_args = tup8.at2();
  block = tup8.at3();
  typed_loc = nullptr;
  if (block) {
    typed_loc = block->brace_group->left;
  }
  if (typed_args) {
    typed_loc = typed_args->left;
  }
  if (len(words) == 0) {
    if (typed_loc != nullptr) {
      p_die(S_meF, typed_loc);
    }
    return Alloc<command::Redirect>(command::NoOp, redirects);
  }
  Tuple2<List<syntax_asdl::ParsedAssignment*>*, List<syntax_asdl::CompoundWord*>*> tup9 = _SplitSimpleCommandPrefix(words);
  preparsed_list = tup9.at0();
  suffix_words = tup9.at1();
  if (len(preparsed_list)) {
    if (len(suffix_words) == 0) {
      if ((this->cmd_mode != cmd_mode_e::Shell or (len(this->hay_attrs_stack) and this->hay_attrs_stack->at(-1)))) {
        p_die(S_xih, preparsed_list->at(0)->left);
      }
    }
  }
  this->parse_ctx->trail->SetLatestWords(suffix_words, redirects);
  if (len(suffix_words) == 0) {
    if (typed_loc != nullptr) {
      p_die(S_meF, typed_loc);
    }
    pairs = Alloc<List<syntax_asdl::AssignPair*>>();
    for (ListIter<syntax_asdl::ParsedAssignment*> it(preparsed_list); !it.Done(); it.Next()) {
      syntax_asdl::ParsedAssignment* preparsed = it.Value();
      StackRoot _for(&preparsed    );
      pairs->append(_MakeAssignPair(this->parse_ctx, preparsed, this->arena));
    }
    left_tok = location::LeftTokenForCompoundWord(words->at(0));
    assign_node = Alloc<command::ShAssignment>(left_tok, pairs);
    if (len(redirects)) {
      return Alloc<command::Redirect>(assign_node, redirects);
    }
    else {
      return assign_node;
    }
  }
  Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> tup10 = word_::IsControlFlow(suffix_words->at(0));
  kind = tup10.at0();
  kw_token = tup10.at1();
  if (kind == Kind::ControlFlow) {
    if ((!this->parse_opts->parse_ignored() and len(redirects))) {
      p_die(S_Biw, kw_token);
    }
    if (len(preparsed_list)) {
      p_die(S_qlz, preparsed_list->at(0)->left);
    }
    if (kw_token->id == Id::ControlFlow_Return) {
      if (typed_args == nullptr) {
        if ((this->cmd_mode != cmd_mode_e::Shell && this->cmd_mode != cmd_mode_e::Proc)) {
          p_die(S_hur, kw_token);
        }
      }
      else {
        if (this->cmd_mode != cmd_mode_e::Func) {
          p_die(S_Bpo, typed_loc);
        }
        if (len(typed_args->pos_args) != 1) {
          p_die(S_jkf, typed_loc);
        }
        if (len(typed_args->named_args) != 0) {
          p_die(S_vuh, typed_loc);
        }
        if (typed_args->left->id != Id::Op_LParen) {
          p_die(S_kCu, typed_args->left);
        }
        return Alloc<command::Retval>(kw_token, typed_args->pos_args->at(0));
      }
    }
    if (typed_loc != nullptr) {
      p_die(S_meF, typed_loc);
    }
    if (len(suffix_words) == 1) {
      arg_word = nullptr;
    }
    else {
      if (len(suffix_words) == 2) {
        arg_word = suffix_words->at(1);
      }
      else {
        p_die(StrFormat("Unexpected argument to %r", lexer::TokenVal(kw_token)), Alloc<loc::Word>(suffix_words->at(2)));
      }
    }
    return Alloc<command::ControlFlow>(kw_token, arg_word);
  }
  if ((!typed_args and (!block and this->parse_opts->expand_aliases()))) {
    expanded_node = this->_MaybeExpandAliases(suffix_words);
    if (expanded_node) {
      more_env = Alloc<List<syntax_asdl::EnvPair*>>();
      _AppendMoreEnv(preparsed_list, more_env);
      exp = Alloc<command::ExpandedAlias>(expanded_node, more_env);
      if (len(redirects)) {
        return Alloc<command::Redirect>(exp, redirects);
      }
      else {
        return exp;
      }
    }
  }
  node = _MakeSimpleCommand(preparsed_list, suffix_words, typed_args, block);
  if (len(redirects)) {
    return Alloc<command::Redirect>(node, redirects);
  }
  else {
    return node;
  }
}

syntax_asdl::BraceGroup* CommandParser::ParseBraceGroup() {
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* left = nullptr;
  syntax_asdl::word_t* doc_word = nullptr;
  syntax_asdl::Token* doc_token = nullptr;
  command::CommandList* c_list = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&ate);
  StackRoot _root1(&left);
  StackRoot _root2(&doc_word);
  StackRoot _root3(&doc_token);
  StackRoot _root4(&c_list);
  StackRoot _root5(&right);

  ate = this->_Eat(Id::Lit_LBrace);
  left = word_::BraceToken(ate);
  doc_word = nullptr;
  this->_GetWord();
  if (this->c_id == Id::Op_Newline) {
    this->_SetNext();
    {  // with
      word_::ctx_EmitDocToken ctx{this->w_parser};

      this->_GetWord();
    }
  }
  if (this->c_id == Id::Ignored_Comment) {
    doc_word = this->cur_word;
    this->_SetNext();
  }
  doc_token = static_cast<Token*>(doc_word);
  c_list = this->_ParseCommandList();
  ate = this->_Eat(Id::Lit_RBrace);
  right = word_::BraceToken(ate);
  return Alloc<BraceGroup>(left, doc_token, c_list->children, right);
}

command::DoGroup* CommandParser::ParseDoGroup() {
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* do_kw = nullptr;
  command::CommandList* c_list = nullptr;
  syntax_asdl::Token* done_kw = nullptr;
  StackRoot _root0(&ate);
  StackRoot _root1(&do_kw);
  StackRoot _root2(&c_list);
  StackRoot _root3(&done_kw);

  ate = this->_Eat(Id::KW_Do);
  do_kw = word_::AsKeywordToken(ate);
  c_list = this->_ParseCommandList();
  ate = this->_Eat(Id::KW_Done);
  done_kw = word_::AsKeywordToken(ate);
  return Alloc<command::DoGroup>(do_kw, c_list->children, done_kw);
}

Tuple2<List<syntax_asdl::CompoundWord*>*, syntax_asdl::Token*> CommandParser::ParseForWords() {
  List<syntax_asdl::CompoundWord*>* words = nullptr;
  syntax_asdl::Token* semi_tok = nullptr;
  syntax_asdl::Token* tok = nullptr;
  syntax_asdl::CompoundWord* w2 = nullptr;
  StackRoot _root0(&words);
  StackRoot _root1(&semi_tok);
  StackRoot _root2(&tok);
  StackRoot _root3(&w2);

  words = Alloc<List<syntax_asdl::CompoundWord*>>();
  semi_tok = nullptr;
  while (true) {
    this->_GetWord();
    if (this->c_id == Id::Op_Semi) {
      tok = static_cast<Token*>(this->cur_word);
      semi_tok = tok;
      this->_SetNext();
      this->_NewlineOk();
      break;
    }
    else {
      if (this->c_id == Id::Op_Newline) {
        this->_SetNext();
        break;
      }
      else {
        if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
          break;
        }
      }
    }
    if (this->cur_word->tag() != word_e::Compound) {
      p_die(S_pnr, Alloc<loc::Word>(this->cur_word));
    }
    w2 = static_cast<CompoundWord*>(this->cur_word);
    words->append(w2);
    this->_SetNext();
  }
  return Tuple2<List<syntax_asdl::CompoundWord*>*, syntax_asdl::Token*>(words, semi_tok);
}

command::ForExpr* CommandParser::_ParseForExprLoop(syntax_asdl::Token* for_kw) {
  command::ForExpr* node = nullptr;
  StackRoot _root0(&for_kw);
  StackRoot _root1(&node);

  node = this->w_parser->ReadForExpression();
  node->keyword = for_kw;
  this->_SetNext();
  this->_GetWord();
  if (this->c_id == Id::Op_Semi) {
    this->_SetNext();
    this->_NewlineOk();
  }
  else {
    if (this->c_id == Id::Op_Newline) {
      this->_SetNext();
    }
    else {
      if (this->c_id == Id::KW_Do) {
        ;  // pass
      }
      else {
        if (this->c_id == Id::Lit_LBrace) {
          ;  // pass
        }
        else {
          p_die(S_kmo, Alloc<loc::Word>(this->cur_word));
        }
      }
    }
  }
  if (this->c_id == Id::Lit_LBrace) {
    node->body = this->ParseBraceGroup();
  }
  else {
    node->body = this->ParseDoGroup();
  }
  return node;
}

command::ForEach* CommandParser::_ParseForEachLoop(syntax_asdl::Token* for_kw) {
  command::ForEach* node = nullptr;
  int num_iter_names;
  syntax_asdl::word_t* w = nullptr;
  syntax_asdl::word_t* UP_w = nullptr;
  bool ok;
  BigStr* iter_name = nullptr;
  bool quoted;
  syntax_asdl::Token* expr_blame = nullptr;
  int next_id;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* semi_tok = nullptr;
  List<syntax_asdl::CompoundWord*>* iter_words = nullptr;
  BigStr* s = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  StackRoot _root0(&for_kw);
  StackRoot _root1(&node);
  StackRoot _root2(&w);
  StackRoot _root3(&UP_w);
  StackRoot _root4(&iter_name);
  StackRoot _root5(&expr_blame);
  StackRoot _root6(&enode);
  StackRoot _root7(&semi_tok);
  StackRoot _root8(&iter_words);
  StackRoot _root9(&s);
  StackRoot _root10(&words2);
  StackRoot _root11(&words3);

  node = command::ForEach::CreateNull(true);
  node->keyword = for_kw;
  num_iter_names = 0;
  while (true) {
    w = this->cur_word;
    UP_w = w;
    if (w->tag() == word_e::Compound) {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      if (word_::LiteralId(w->parts->at(-1)) == Id::Lit_Comma) {
        w->parts->pop();
      }
    }
    Tuple3<bool, BigStr*, bool> tup11 = word_::StaticEval(w);
    ok = tup11.at0();
    iter_name = tup11.at1();
    quoted = tup11.at2();
    if ((!ok or quoted)) {
      p_die(S_nnd, Alloc<loc::Word>(w));
    }
    if (!match::IsValidVarName(iter_name)) {
      if (str_contains(iter_name, S_Cce)) {
        p_die(S_dwa, Alloc<loc::Word>(w));
      }
      p_die(StrFormat("Invalid loop variable name %r", iter_name), Alloc<loc::Word>(w));
    }
    node->iter_names->append(iter_name);
    num_iter_names += 1;
    this->_SetNext();
    this->_GetWord();
    if (((this->c_id == Id::KW_In || this->c_id == Id::KW_Do) or this->c_kind == Kind::Op)) {
      break;
    }
    if (num_iter_names == 3) {
      p_die(S_zfb, Alloc<loc::Word>(this->cur_word));
    }
  }
  this->_NewlineOk();
  this->_GetWord();
  if (this->c_id == Id::KW_In) {
    expr_blame = word_::AsKeywordToken(this->cur_word);
    this->_SetNext();
    next_id = this->w_parser->LookPastSpace();
    if (next_id == Id::Op_LParen) {
      enode = this->w_parser->ParseYshExprForCommand();
      node->iterable = Alloc<for_iter::YshExpr>(enode, expr_blame);
      this->_GetWord();
      if (this->c_id != Id::Lit_LBrace) {
        p_die(S_Fhm, Alloc<loc::Word>(this->cur_word));
      }
    }
    else {
      if (next_id == Id::Redir_LessGreat) {
        w = this->_Eat(Id::Redir_LessGreat);
        p_die(S_cEx, Alloc<loc::Word>(this->cur_word));
      }
      else {
        if (next_id == Id::Redir_Less) {
          w = this->_Eat(Id::Redir_Less);
          p_die(S_cEx, Alloc<loc::Word>(this->cur_word));
        }
        else {
          semi_tok = nullptr;
          Tuple2<List<syntax_asdl::CompoundWord*>*, syntax_asdl::Token*> tup12 = this->ParseForWords();
          iter_words = tup12.at0();
          semi_tok = tup12.at1();
          node->semi_tok = semi_tok;
          if ((!this->parse_opts->parse_bare_word() and len(iter_words) == 1)) {
            Tuple3<bool, BigStr*, bool> tup13 = word_::StaticEval(iter_words->at(0));
            ok = tup13.at0();
            s = tup13.at1();
            quoted = tup13.at2();
            if ((ok and (match::IsValidVarName(s) and !quoted))) {
              p_die(S_BpF, Alloc<loc::Word>(iter_words->at(0)));
            }
          }
          words2 = braces::BraceDetectAll(iter_words);
          words3 = word_::TildeDetectAll(words2);
          node->iterable = Alloc<for_iter::Words>(words3);
          if (num_iter_names > 2) {
            p_die(S_yDB, for_kw);
          }
        }
      }
    }
  }
  else {
    if (this->c_id == Id::KW_Do) {
      node->iterable = for_iter::Args;
    }
    else {
      if (this->c_id == Id::Op_Semi) {
        node->iterable = for_iter::Args;
        this->_SetNext();
      }
      else {
        p_die(S_cAo, Alloc<loc::Word>(this->cur_word));
      }
    }
  }
  this->_GetWord();
  if (this->c_id == Id::Lit_LBrace) {
    node->body = this->ParseBraceGroup();
  }
  else {
    node->body = this->ParseDoGroup();
  }
  return node;
}

syntax_asdl::command_t* CommandParser::ParseFor() {
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* for_kw = nullptr;
  command::ForExpr* n1 = nullptr;
  command::ForEach* n2 = nullptr;
  StackRoot _root0(&ate);
  StackRoot _root1(&for_kw);
  StackRoot _root2(&n1);
  StackRoot _root3(&n2);

  ate = this->_Eat(Id::KW_For);
  for_kw = word_::AsKeywordToken(ate);
  this->_GetWord();
  if (this->c_id == Id::Op_DLeftParen) {
    if (!this->parse_opts->parse_dparen()) {
      p_die(S_laa, Alloc<loc::Word>(this->cur_word));
    }
    n1 = this->_ParseForExprLoop(for_kw);
    return this->_MaybeParseRedirectList(n1);
  }
  else {
    n2 = this->_ParseForEachLoop(for_kw);
    return this->_MaybeParseRedirectList(n2);
  }
}

syntax_asdl::condition_t* CommandParser::_ParseConditionList() {
  command::CommandList* commands = nullptr;
  StackRoot _root0(&commands);

  this->allow_block = false;
  commands = this->_ParseCommandList();
  this->allow_block = true;
  if (len(commands->children) == 0) {
    p_die(S_xDn, Alloc<loc::Word>(this->cur_word));
  }
  return List_of_command::Take(commands->children);
}

command::WhileUntil* CommandParser::ParseWhileUntil(syntax_asdl::Token* keyword) {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::command_t* body_node = nullptr;
  StackRoot _root0(&keyword);
  StackRoot _root1(&enode);
  StackRoot _root2(&cond);
  StackRoot _root3(&body_node);

  this->_SetNext();
  if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
    enode = this->w_parser->ParseYshExprForCommand();
    cond = Alloc<condition::YshExpr>(enode);
  }
  else {
    cond = this->_ParseConditionList();
  }
  this->_GetWord();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
    body_node = this->ParseBraceGroup();
  }
  else {
    body_node = this->ParseDoGroup();
  }
  return Alloc<command::WhileUntil>(keyword, cond, body_node);
}

syntax_asdl::CaseArm* CommandParser::ParseCaseArm() {
  syntax_asdl::Token* left_tok = nullptr;
  List<syntax_asdl::word_t*>* pat_words = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* middle_tok = nullptr;
  command::CommandList* c_list = nullptr;
  List<syntax_asdl::command_t*>* action_children = nullptr;
  syntax_asdl::Token* dsemi_tok = nullptr;
  StackRoot _root0(&left_tok);
  StackRoot _root1(&pat_words);
  StackRoot _root2(&ate);
  StackRoot _root3(&middle_tok);
  StackRoot _root4(&c_list);
  StackRoot _root5(&action_children);
  StackRoot _root6(&dsemi_tok);

  this->lexer->PushHint(Id::Op_RParen, Id::Right_CasePat);
  left_tok = location::LeftTokenForWord(this->cur_word);
  if (this->c_id == Id::Op_LParen) {
    this->_SetNext();
  }
  pat_words = Alloc<List<syntax_asdl::word_t*>>();
  while (true) {
    this->_GetWord();
    if (this->c_kind != Kind::Word) {
      p_die(S_vky, Alloc<loc::Word>(this->cur_word));
    }
    pat_words->append(this->cur_word);
    this->_SetNext();
    this->_GetWord();
    if (this->c_id == Id::Op_Pipe) {
      this->_SetNext();
    }
    else {
      break;
    }
  }
  ate = this->_Eat(Id::Right_CasePat);
  middle_tok = word_::AsOperatorToken(ate);
  this->_NewlineOk();
  this->_GetWord();
  if ((this->c_id != Id::Op_DSemi && this->c_id != Id::Op_SemiAmp && this->c_id != Id::Op_DSemiAmp && this->c_id != Id::KW_Esac)) {
    c_list = this->_ParseCommandTerm();
    action_children = c_list->children;
  }
  else {
    action_children = Alloc<List<syntax_asdl::command_t*>>();
  }
  dsemi_tok = nullptr;
  this->_GetWord();
  if (this->c_id == Id::KW_Esac) {
    ;  // pass
  }
  else {
    if ((this->c_id == Id::Op_DSemi || this->c_id == Id::Op_SemiAmp || this->c_id == Id::Op_DSemiAmp)) {
      dsemi_tok = word_::AsOperatorToken(this->cur_word);
      this->_SetNext();
    }
    else {
      p_die(S_qsa, Alloc<loc::Word>(this->cur_word));
    }
  }
  this->_NewlineOk();
  return Alloc<CaseArm>(left_tok, Alloc<pat::Words>(pat_words), middle_tok, action_children, dsemi_tok);
}

syntax_asdl::CaseArm* CommandParser::ParseYshCaseArm(int discriminant) {
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::pat_t* pattern = nullptr;
  List<syntax_asdl::word_t*>* pat_words = nullptr;
  syntax_asdl::BraceGroup* action = nullptr;
  StackRoot _root0(&left_tok);
  StackRoot _root1(&pattern);
  StackRoot _root2(&pat_words);
  StackRoot _root3(&action);

  left_tok = nullptr;
  pattern = nullptr;
  if ((discriminant == Id::Op_LParen || discriminant == Id::Arith_Slash)) {
    Tuple2<syntax_asdl::pat_t*, syntax_asdl::Token*> tup14 = this->w_parser->ParseYshCasePattern();
    pattern = tup14.at0();
    left_tok = tup14.at1();
  }
  else {
    pat_words = Alloc<List<syntax_asdl::word_t*>>();
    while (true) {
      this->_GetWord();
      if (this->c_kind != Kind::Word) {
        p_die(S_vky, Alloc<loc::Word>(this->cur_word));
      }
      pat_words->append(this->cur_word);
      this->_SetNext();
      if (!left_tok) {
        left_tok = location::LeftTokenForWord(this->cur_word);
      }
      this->_NewlineOk();
      this->_GetWord();
      if (this->c_id == Id::Op_Pipe) {
        this->_SetNext();
        this->_NewlineOk();
      }
      else {
        break;
      }
    }
    pattern = Alloc<pat::Words>(pat_words);
  }
  this->_NewlineOk();
  action = this->ParseBraceGroup();
  return Alloc<CaseArm>(left_tok, pattern, action->left, action->children, action->right);
}

command::Case* CommandParser::ParseYshCase(syntax_asdl::Token* case_kw) {
  syntax_asdl::expr_t* enode = nullptr;
  case_arg::YshExpr* to_match = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* arms_start = nullptr;
  int discriminant;
  List<syntax_asdl::CaseArm*>* arms = nullptr;
  syntax_asdl::CaseArm* arm = nullptr;
  syntax_asdl::Token* arms_end = nullptr;
  StackRoot _root0(&case_kw);
  StackRoot _root1(&enode);
  StackRoot _root2(&to_match);
  StackRoot _root3(&ate);
  StackRoot _root4(&arms_start);
  StackRoot _root5(&arms);
  StackRoot _root6(&arm);
  StackRoot _root7(&arms_end);

  enode = this->w_parser->ParseYshExprForCommand();
  to_match = Alloc<case_arg::YshExpr>(enode);
  ate = this->_Eat(Id::Lit_LBrace);
  arms_start = word_::BraceToken(ate);
  discriminant = this->w_parser->NewlineOkForYshCase();
  arms = Alloc<List<syntax_asdl::CaseArm*>>();
  while (discriminant != Id::Op_RBrace) {
    arm = this->ParseYshCaseArm(discriminant);
    arms->append(arm);
    discriminant = this->w_parser->NewlineOkForYshCase();
  }
  ate = this->_Eat(Id::Op_RBrace);
  arms_end = word_::AsOperatorToken(ate);
  arms_end->id = Id::Lit_RBrace;
  return Alloc<command::Case>(case_kw, to_match, arms_start, arms, arms_end);
}

command::Case* CommandParser::ParseOldCase(syntax_asdl::Token* case_kw) {
  syntax_asdl::word_t* w = nullptr;
  bool ok;
  BigStr* s = nullptr;
  bool quoted;
  case_arg::Word* to_match = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* arms_start = nullptr;
  List<syntax_asdl::CaseArm*>* arms = nullptr;
  syntax_asdl::CaseArm* arm = nullptr;
  syntax_asdl::Token* arms_end = nullptr;
  StackRoot _root0(&case_kw);
  StackRoot _root1(&w);
  StackRoot _root2(&s);
  StackRoot _root3(&to_match);
  StackRoot _root4(&ate);
  StackRoot _root5(&arms_start);
  StackRoot _root6(&arms);
  StackRoot _root7(&arm);
  StackRoot _root8(&arms_end);

  this->_GetWord();
  w = this->cur_word;
  if (!this->parse_opts->parse_bare_word()) {
    Tuple3<bool, BigStr*, bool> tup15 = word_::StaticEval(w);
    ok = tup15.at0();
    s = tup15.at1();
    quoted = tup15.at2();
    if ((ok and !quoted)) {
      p_die(S_tjF, Alloc<loc::Word>(w));
    }
  }
  if (w->tag() != word_e::Compound) {
    p_die(S_brv, Alloc<loc::Word>(w));
  }
  to_match = Alloc<case_arg::Word>(w);
  this->_SetNext();
  this->_NewlineOk();
  ate = this->_Eat(Id::KW_In);
  arms_start = word_::AsKeywordToken(ate);
  this->_NewlineOk();
  arms = Alloc<List<syntax_asdl::CaseArm*>>();
  while (true) {
    this->_GetWord();
    if (this->c_id == Id::KW_Esac) {
      break;
    }
    if ((this->c_kind != Kind::Word and this->c_id != Id::Op_LParen)) {
      break;
    }
    arm = this->ParseCaseArm();
    arms->append(arm);
  }
  ate = this->_Eat(Id::KW_Esac);
  arms_end = word_::AsKeywordToken(ate);
  return Alloc<command::Case>(case_kw, to_match, arms_start, arms, arms_end);
}

command::Case* CommandParser::ParseCase() {
  syntax_asdl::Token* case_kw = nullptr;
  StackRoot _root0(&case_kw);

  case_kw = word_::AsKeywordToken(this->cur_word);
  this->_SetNext();
  if (this->w_parser->LookPastSpace() == Id::Op_LParen) {
    return this->ParseYshCase(case_kw);
  }
  else {
    return this->ParseOldCase(case_kw);
  }
}

void CommandParser::_ParseYshElifElse(command::If* if_node) {
  List<syntax_asdl::IfArm*>* arms = nullptr;
  syntax_asdl::Token* elif_kw = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  command::CommandList* commands = nullptr;
  syntax_asdl::BraceGroup* body = nullptr;
  syntax_asdl::IfArm* arm = nullptr;
  StackRoot _root0(&if_node);
  StackRoot _root1(&arms);
  StackRoot _root2(&elif_kw);
  StackRoot _root3(&enode);
  StackRoot _root4(&cond);
  StackRoot _root5(&commands);
  StackRoot _root6(&body);
  StackRoot _root7(&arm);

  arms = if_node->arms;
  while (this->c_id == Id::KW_Elif) {
    elif_kw = word_::AsKeywordToken(this->cur_word);
    this->_SetNext();
    if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
      enode = this->w_parser->ParseYshExprForCommand();
      cond = Alloc<condition::YshExpr>(enode);
    }
    else {
      this->allow_block = false;
      commands = this->_ParseCommandList();
      this->allow_block = true;
      cond = List_of_command::Take(commands->children);
    }
    body = this->ParseBraceGroup();
    this->_GetWord();
    arm = Alloc<IfArm>(elif_kw, cond, nullptr, body->children, nullptr);
    arms->append(arm);
  }
  this->_GetWord();
  if (this->c_id == Id::KW_Else) {
    this->_SetNext();
    body = this->ParseBraceGroup();
    if_node->else_action = body->children;
  }
}

command::If* CommandParser::_ParseYshIf(syntax_asdl::Token* if_kw, syntax_asdl::condition_t* cond) {
  command::If* if_node = nullptr;
  syntax_asdl::BraceGroup* body1 = nullptr;
  syntax_asdl::IfArm* arm = nullptr;
  StackRoot _root0(&if_kw);
  StackRoot _root1(&cond);
  StackRoot _root2(&if_node);
  StackRoot _root3(&body1);
  StackRoot _root4(&arm);

  if_node = command::If::CreateNull(true);
  if_node->if_kw = if_kw;
  body1 = this->ParseBraceGroup();
  arm = Alloc<IfArm>(if_kw, cond, nullptr, body1->children, nullptr);
  if_node->arms->append(arm);
  this->_GetWord();
  if ((this->c_id == Id::KW_Elif || this->c_id == Id::KW_Else)) {
    this->_ParseYshElifElse(if_node);
  }
  return if_node;
}

void CommandParser::_ParseElifElse(command::If* if_node) {
  List<syntax_asdl::IfArm*>* arms = nullptr;
  syntax_asdl::Token* elif_kw = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* then_kw = nullptr;
  command::CommandList* body = nullptr;
  syntax_asdl::IfArm* arm = nullptr;
  syntax_asdl::Token* else_kw = nullptr;
  StackRoot _root0(&if_node);
  StackRoot _root1(&arms);
  StackRoot _root2(&elif_kw);
  StackRoot _root3(&cond);
  StackRoot _root4(&ate);
  StackRoot _root5(&then_kw);
  StackRoot _root6(&body);
  StackRoot _root7(&arm);
  StackRoot _root8(&else_kw);

  arms = if_node->arms;
  this->_GetWord();
  while (this->c_id == Id::KW_Elif) {
    elif_kw = word_::AsKeywordToken(this->cur_word);
    this->_SetNext();
    cond = this->_ParseConditionList();
    ate = this->_Eat(Id::KW_Then);
    then_kw = word_::AsKeywordToken(ate);
    body = this->_ParseCommandList();
    arm = Alloc<IfArm>(elif_kw, cond, then_kw, body->children, then_kw);
    arms->append(arm);
  }
  this->_GetWord();
  if (this->c_id == Id::KW_Else) {
    else_kw = word_::AsKeywordToken(this->cur_word);
    this->_SetNext();
    body = this->_ParseCommandList();
    if_node->else_action = body->children;
  }
  else {
    else_kw = nullptr;
  }
  if_node->else_kw = else_kw;
}

command::If* CommandParser::ParseIf() {
  command::If* if_node = nullptr;
  syntax_asdl::Token* if_kw = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::condition_t* cond = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* then_kw = nullptr;
  command::CommandList* body = nullptr;
  syntax_asdl::IfArm* arm = nullptr;
  StackRoot _root0(&if_node);
  StackRoot _root1(&if_kw);
  StackRoot _root2(&enode);
  StackRoot _root3(&cond);
  StackRoot _root4(&ate);
  StackRoot _root5(&then_kw);
  StackRoot _root6(&body);
  StackRoot _root7(&arm);

  if_node = command::If::CreateNull(true);
  if_kw = word_::AsKeywordToken(this->cur_word);
  if_node->if_kw = if_kw;
  this->_SetNext();
  if ((this->parse_opts->parse_paren() and this->w_parser->LookPastSpace() == Id::Op_LParen)) {
    enode = this->w_parser->ParseYshExprForCommand();
    cond = Alloc<condition::YshExpr>(enode);
  }
  else {
    cond = this->_ParseConditionList();
  }
  this->_GetWord();
  if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
    return this->_ParseYshIf(if_kw, cond);
  }
  ate = this->_Eat(Id::KW_Then);
  then_kw = word_::AsKeywordToken(ate);
  body = this->_ParseCommandList();
  arm = Alloc<IfArm>(if_kw, cond, then_kw, body->children, then_kw);
  if_node->arms->append(arm);
  if ((this->c_id == Id::KW_Elif || this->c_id == Id::KW_Else)) {
    this->_ParseElifElse(if_node);
  }
  ate = this->_Eat(Id::KW_Fi);
  if_node->fi_kw = word_::AsKeywordToken(ate);
  return if_node;
}

syntax_asdl::command_t* CommandParser::ParseTime() {
  syntax_asdl::Token* time_kw = nullptr;
  syntax_asdl::command_t* pipeline = nullptr;
  StackRoot _root0(&time_kw);
  StackRoot _root1(&pipeline);

  time_kw = word_::AsKeywordToken(this->cur_word);
  this->_SetNext();
  pipeline = this->ParsePipeline();
  return Alloc<command::TimeBlock>(time_kw, pipeline);
}

syntax_asdl::command_t* CommandParser::ParseCompoundCommand() {
  syntax_asdl::BraceGroup* n1 = nullptr;
  command::Subshell* n2 = nullptr;
  syntax_asdl::Token* keyword = nullptr;
  command::WhileUntil* n3 = nullptr;
  command::If* n4 = nullptr;
  command::Case* n5 = nullptr;
  command::DBracket* n6 = nullptr;
  command::DParen* n7 = nullptr;
  StackRoot _root0(&n1);
  StackRoot _root1(&n2);
  StackRoot _root2(&keyword);
  StackRoot _root3(&n3);
  StackRoot _root4(&n4);
  StackRoot _root5(&n5);
  StackRoot _root6(&n6);
  StackRoot _root7(&n7);

  this->_GetWord();
  if (this->c_id == Id::Lit_LBrace) {
    n1 = this->ParseBraceGroup();
    return this->_MaybeParseRedirectList(n1);
  }
  if (this->c_id == Id::Op_LParen) {
    n2 = this->ParseSubshell();
    return this->_MaybeParseRedirectList(n2);
  }
  if (this->c_id == Id::KW_For) {
    return this->ParseFor();
  }
  if ((this->c_id == Id::KW_While || this->c_id == Id::KW_Until)) {
    keyword = word_::AsKeywordToken(this->cur_word);
    n3 = this->ParseWhileUntil(keyword);
    return this->_MaybeParseRedirectList(n3);
  }
  if (this->c_id == Id::KW_If) {
    n4 = this->ParseIf();
    return this->_MaybeParseRedirectList(n4);
  }
  if (this->c_id == Id::KW_Case) {
    n5 = this->ParseCase();
    return this->_MaybeParseRedirectList(n5);
  }
  if (this->c_id == Id::KW_DLeftBracket) {
    if (!this->parse_opts->parse_dbracket()) {
      p_die(S_mEk, Alloc<loc::Word>(this->cur_word));
    }
    n6 = this->ParseDBracket();
    return this->_MaybeParseRedirectList(n6);
  }
  if (this->c_id == Id::Op_DLeftParen) {
    if (!this->parse_opts->parse_dparen()) {
      p_die(S_ulC, Alloc<loc::Word>(this->cur_word));
    }
    n7 = this->ParseDParen();
    return this->_MaybeParseRedirectList(n7);
  }
  if (this->c_id == Id::KW_Time) {
    return this->ParseTime();
  }
  p_die(StrFormat("Unexpected word while parsing compound command (%s)", Id_str(this->c_id)), Alloc<loc::Word>(this->cur_word));
}

command::ShFunction* CommandParser::ParseFunctionDef() {
  syntax_asdl::CompoundWord* word0 = nullptr;
  BigStr* name = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::Token* blame_tok = nullptr;
  command::ShFunction* func = nullptr;
  StackRoot _root0(&word0);
  StackRoot _root1(&name);
  StackRoot _root2(&part0);
  StackRoot _root3(&blame_tok);
  StackRoot _root4(&func);

  word0 = static_cast<CompoundWord*>(this->cur_word);
  name = word_::ShFunctionName(word0);
  if (len(name) == 0) {
    p_die(S_rbb, Alloc<loc::Word>(word0));
  }
  part0 = word0->parts->at(0);
  blame_tok = static_cast<Token*>(part0);
  this->_SetNext();
  this->_GetWord();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_ShFunction);
  this->_SetNext();
  this->_GetWord();
  if (this->c_id == Id::Right_ShFunction) {
    this->_SetNext();
    this->_NewlineOk();
    func = command::ShFunction::CreateNull();
    func->name = name;
    {  // with
      ctx_VarChecker ctx{this->var_checker, blame_tok};

      func->body = this->ParseCompoundCommand();
    }
    func->name_tok = location::LeftTokenForCompoundWord(word0);
    return func;
  }
  else {
    p_die(S_rbz, Alloc<loc::Word>(this->cur_word));
    return nullptr;
  }
}

command::ShFunction* CommandParser::ParseKshFunctionDef() {
  syntax_asdl::Token* keyword_tok = nullptr;
  syntax_asdl::CompoundWord* cur_word = nullptr;
  BigStr* name = nullptr;
  syntax_asdl::word_t* name_word = nullptr;
  command::ShFunction* func = nullptr;
  StackRoot _root0(&keyword_tok);
  StackRoot _root1(&cur_word);
  StackRoot _root2(&name);
  StackRoot _root3(&name_word);
  StackRoot _root4(&func);

  keyword_tok = word_::AsKeywordToken(this->cur_word);
  this->_SetNext();
  this->_GetWord();
  cur_word = static_cast<CompoundWord*>(this->cur_word);
  name = word_::ShFunctionName(cur_word);
  if (len(name) == 0) {
    p_die(S_rdm, Alloc<loc::Word>(cur_word));
  }
  name_word = this->cur_word;
  this->_SetNext();
  this->_GetWord();
  if (this->c_id == Id::Op_LParen) {
    this->lexer->PushHint(Id::Op_RParen, Id::Right_ShFunction);
    this->_SetNext();
    this->_Eat(Id::Right_ShFunction);
  }
  this->_NewlineOk();
  func = command::ShFunction::CreateNull();
  func->name = name;
  {  // with
    ctx_VarChecker ctx{this->var_checker, keyword_tok};

    func->body = this->ParseCompoundCommand();
  }
  func->keyword = keyword_tok;
  func->name_tok = location::LeftTokenForWord(name_word);
  return func;
}

syntax_asdl::Proc* CommandParser::ParseYshProc() {
  syntax_asdl::Proc* node = nullptr;
  syntax_asdl::Token* keyword_tok = nullptr;
  proc_sig::Closed* sig = nullptr;
  syntax_asdl::ParamGroup* wp = nullptr;
  syntax_asdl::RestParam* r = nullptr;
  syntax_asdl::ParamGroup* posit = nullptr;
  syntax_asdl::ParamGroup* named = nullptr;
  syntax_asdl::Param* b = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&keyword_tok);
  StackRoot _root2(&sig);
  StackRoot _root3(&wp);
  StackRoot _root4(&r);
  StackRoot _root5(&posit);
  StackRoot _root6(&named);
  StackRoot _root7(&b);

  node = Proc::CreateNull(true);
  keyword_tok = word_::AsKeywordToken(this->cur_word);
  node->keyword = keyword_tok;
  {  // with
    ctx_VarChecker ctx{this->var_checker, keyword_tok};

    {  // with
      ctx_CmdMode ctx{this, cmd_mode_e::Proc};

      this->w_parser->ParseProc(node);
      if (node->sig->tag() == proc_sig_e::Closed) {
        sig = static_cast<proc_sig::Closed*>(node->sig);
        wp = sig->word;
        if (wp) {
          for (ListIter<syntax_asdl::Param*> it(wp->params); !it.Done(); it.Next()) {
            syntax_asdl::Param* param = it.Value();
            StackRoot _for(&param          );
            this->var_checker->Check(Id::KW_Var, param->name, param->blame_tok);
          }
          if (wp->rest_of) {
            r = wp->rest_of;
            this->var_checker->Check(Id::KW_Var, r->name, r->blame_tok);
          }
        }
        posit = sig->positional;
        if (posit) {
          for (ListIter<syntax_asdl::Param*> it(posit->params); !it.Done(); it.Next()) {
            syntax_asdl::Param* param = it.Value();
            StackRoot _for(&param          );
            this->var_checker->Check(Id::KW_Var, param->name, param->blame_tok);
          }
          if (posit->rest_of) {
            r = posit->rest_of;
            this->var_checker->Check(Id::KW_Var, r->name, r->blame_tok);
          }
        }
        named = sig->named;
        if (named) {
          for (ListIter<syntax_asdl::Param*> it(named->params); !it.Done(); it.Next()) {
            syntax_asdl::Param* param = it.Value();
            StackRoot _for(&param          );
            this->var_checker->Check(Id::KW_Var, param->name, param->blame_tok);
          }
          if (named->rest_of) {
            r = named->rest_of;
            this->var_checker->Check(Id::KW_Var, r->name, r->blame_tok);
          }
        }
        if (sig->block_param) {
          b = sig->block_param;
          this->var_checker->Check(Id::KW_Var, b->name, b->blame_tok);
        }
      }
      this->_SetNext();
      node->body = this->ParseBraceGroup();
    }
  }
  return node;
}

syntax_asdl::Func* CommandParser::ParseYshFunc() {
  syntax_asdl::Func* node = nullptr;
  syntax_asdl::Token* keyword_tok = nullptr;
  syntax_asdl::ParamGroup* posit = nullptr;
  syntax_asdl::RestParam* r = nullptr;
  syntax_asdl::ParamGroup* named = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&keyword_tok);
  StackRoot _root2(&posit);
  StackRoot _root3(&r);
  StackRoot _root4(&named);

  node = Func::CreateNull(true);
  keyword_tok = word_::AsKeywordToken(this->cur_word);
  node->keyword = keyword_tok;
  {  // with
    ctx_VarChecker ctx{this->var_checker, keyword_tok};

    this->w_parser->ParseFunc(node);
    posit = node->positional;
    if (posit) {
      for (ListIter<syntax_asdl::Param*> it(posit->params); !it.Done(); it.Next()) {
        syntax_asdl::Param* param = it.Value();
        StackRoot _for(&param      );
        this->var_checker->Check(Id::KW_Var, param->name, param->blame_tok);
      }
      if (posit->rest_of) {
        r = posit->rest_of;
        this->var_checker->Check(Id::KW_Var, r->name, r->blame_tok);
      }
    }
    named = node->named;
    if (named) {
      for (ListIter<syntax_asdl::Param*> it(named->params); !it.Done(); it.Next()) {
        syntax_asdl::Param* param = it.Value();
        StackRoot _for(&param      );
        this->var_checker->Check(Id::KW_Var, param->name, param->blame_tok);
      }
      if (named->rest_of) {
        r = named->rest_of;
        this->var_checker->Check(Id::KW_Var, r->name, r->blame_tok);
      }
    }
    this->_SetNext();
    {  // with
      ctx_CmdMode ctx{this, cmd_mode_e::Func};

      node->body = this->ParseBraceGroup();
    }
  }
  return node;
}

syntax_asdl::command_t* CommandParser::ParseCoproc() {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

command::Subshell* CommandParser::ParseSubshell() {
  syntax_asdl::Token* left = nullptr;
  command::CommandList* c_list = nullptr;
  syntax_asdl::command_t* child = nullptr;
  syntax_asdl::word_t* ate = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&c_list);
  StackRoot _root2(&child);
  StackRoot _root3(&ate);
  StackRoot _root4(&right);

  left = word_::AsOperatorToken(this->cur_word);
  this->_SetNext();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_Subshell);
  c_list = this->_ParseCommandList();
  if (len(c_list->children) == 1) {
    child = c_list->children->at(0);
  }
  else {
    child = c_list;
  }
  ate = this->_Eat(Id::Right_Subshell);
  right = word_::AsOperatorToken(ate);
  return Alloc<command::Subshell>(left, child, right, false);
}

command::DBracket* CommandParser::ParseDBracket() {
  syntax_asdl::Token* left = nullptr;
  bool_parse::BoolParser* b_parser = nullptr;
  syntax_asdl::bool_expr_t* bnode = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&b_parser);
  StackRoot _root2(&bnode);
  StackRoot _root3(&right);

  left = word_::AsKeywordToken(this->cur_word);
  this->_SetNext();
  b_parser = Alloc<bool_parse::BoolParser>(this->w_parser);
  Tuple2<syntax_asdl::bool_expr_t*, syntax_asdl::Token*> tup16 = b_parser->Parse();
  bnode = tup16.at0();
  right = tup16.at1();
  return Alloc<command::DBracket>(left, bnode, right);
}

command::DParen* CommandParser::ParseDParen() {
  syntax_asdl::Token* left = nullptr;
  syntax_asdl::arith_expr_t* anode = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&anode);
  StackRoot _root2(&right);

  left = word_::AsOperatorToken(this->cur_word);
  this->_SetNext();
  Tuple2<syntax_asdl::arith_expr_t*, syntax_asdl::Token*> tup17 = this->w_parser->ReadDParen();
  anode = tup17.at0();
  right = tup17.at1();
  return Alloc<command::DParen>(left, anode, right);
}

syntax_asdl::command_t* CommandParser::ParseCommand() {
  int keyword_id;
  syntax_asdl::Token* kw_token = nullptr;
  syntax_asdl::VarDecl* n8 = nullptr;
  syntax_asdl::Mutation* n9 = nullptr;
  syntax_asdl::Token* keyword = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::CompoundWord* cur_word = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&kw_token);
  StackRoot _root1(&n8);
  StackRoot _root2(&n9);
  StackRoot _root3(&keyword);
  StackRoot _root4(&enode);
  StackRoot _root5(&cur_word);
  StackRoot _root6(&parts);
  StackRoot _root7(&part0);
  StackRoot _root8(&tok);

  if (this->_AtSecondaryKeyword()) {
    p_die(S_lrE, Alloc<loc::Word>(this->cur_word));
  }
  if (this->c_id == Id::KW_Proc) {
    if (this->parse_opts->parse_proc()) {
      return this->ParseYshProc();
    }
    else {
      p_die(S_dsk, Alloc<loc::Word>(this->cur_word));
    }
  }
  if (this->c_id == Id::KW_Typed) {
    this->_SetNext();
    this->_GetWord();
    if (this->c_id != Id::KW_Proc) {
      p_die(S_sai, Alloc<loc::Word>(this->cur_word));
    }
    if (this->parse_opts->parse_proc()) {
      return this->ParseYshProc();
    }
    else {
      p_die(S_hzm, Alloc<loc::Word>(this->cur_word));
    }
  }
  if (this->c_id == Id::KW_Func) {
    if (this->parse_opts->parse_func()) {
      return this->ParseYshFunc();
    }
    else {
      p_die(S_ggl, Alloc<loc::Word>(this->cur_word));
    }
  }
  if ((this->c_id == Id::KW_Const and this->cmd_mode != cmd_mode_e::Shell)) {
    p_die(S_pxA, Alloc<loc::Word>(this->cur_word));
  }
  if ((this->c_id == Id::KW_Var || this->c_id == Id::KW_Const)) {
    keyword_id = this->c_id;
    kw_token = word_::LiteralToken(this->cur_word);
    this->_SetNext();
    n8 = this->w_parser->ParseVarDecl(kw_token);
    for (ListIter<syntax_asdl::NameType*> it(n8->lhs); !it.Done(); it.Next()) {
      syntax_asdl::NameType* lhs = it.Value();
      StackRoot _for(&lhs    );
      this->var_checker->Check(keyword_id, lhs->name, lhs->left);
    }
    return n8;
  }
  if ((this->c_id == Id::KW_SetVar || this->c_id == Id::KW_SetGlobal)) {
    kw_token = word_::LiteralToken(this->cur_word);
    this->_SetNext();
    n9 = this->w_parser->ParseMutation(kw_token, this->var_checker);
    return n9;
  }
  if ((this->c_id == Id::KW_Call || this->c_id == Id::Lit_Equals)) {
    keyword = word_::LiteralToken(this->cur_word);
    this->_SetNext();
    enode = this->w_parser->ParseCommandExpr();
    return Alloc<ExprCommand>(keyword, enode);
  }
  if (this->c_id == Id::KW_Function) {
    return this->ParseKshFunctionDef();
  }
  if ((this->c_id == Id::KW_DLeftBracket || this->c_id == Id::Op_DLeftParen || this->c_id == Id::Op_LParen || this->c_id == Id::Lit_LBrace || this->c_id == Id::KW_For || this->c_id == Id::KW_While || this->c_id == Id::KW_Until || this->c_id == Id::KW_If || this->c_id == Id::KW_Case || this->c_id == Id::KW_Time)) {
    return this->ParseCompoundCommand();
  }
  if (this->c_id == Id::Lit_RBrace) {
    p_die(S_avi, Alloc<loc::Word>(this->cur_word));
  }
  if (this->c_kind == Kind::Redir) {
    return this->ParseSimpleCommand();
  }
  if (this->c_kind == Kind::Word) {
    cur_word = static_cast<CompoundWord*>(this->cur_word);
    if ((this->w_parser->LookAheadFuncParens() and !word_::IsVarLike(cur_word))) {
      return this->ParseFunctionDef();
    }
    parts = cur_word->parts;
    if ((this->parse_opts->parse_equals() and len(parts) == 1)) {
      part0 = parts->at(0);
      if (part0->tag() == word_part_e::Literal) {
        tok = static_cast<Token*>(part0);
        if ((tok->id == Id::Lit_Chars and (this->w_parser->LookPastSpace() == Id::Lit_Equals and match::IsValidVarName(lexer::LazyStr(tok))))) {
          if ((len(this->hay_attrs_stack) and this->hay_attrs_stack->at(-1))) {
            enode = this->w_parser->ParseBareDecl();
            this->_SetNext();
            return Alloc<VarDecl>(nullptr, NewList<syntax_asdl::NameType*>(std::initializer_list<syntax_asdl::NameType*>{Alloc<NameType>(tok, lexer::TokenVal(tok), nullptr)}), enode);
          }
          else {
            this->_SetNext();
            this->_GetWord();
            p_die(S_hlc, Alloc<loc::Word>(this->cur_word));
          }
        }
      }
    }
    return this->ParseSimpleCommand();
  }
  if (this->c_kind == Kind::Eof) {
    p_die(S_agx, Alloc<loc::Word>(this->cur_word));
  }
  p_die(S_fgr, Alloc<loc::Word>(this->cur_word));
}

syntax_asdl::command_t* CommandParser::ParsePipeline() {
  syntax_asdl::Token* negated = nullptr;
  syntax_asdl::command_t* child = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  command::Pipeline* node = nullptr;
  List<syntax_asdl::Token*>* ops = nullptr;
  syntax_asdl::Token* op = nullptr;
  StackRoot _root0(&negated);
  StackRoot _root1(&child);
  StackRoot _root2(&children);
  StackRoot _root3(&node);
  StackRoot _root4(&ops);
  StackRoot _root5(&op);

  negated = nullptr;
  this->_GetWord();
  if (this->c_id == Id::KW_Bang) {
    negated = word_::AsKeywordToken(this->cur_word);
    this->_SetNext();
  }
  child = this->ParseCommand();
  children = NewList<syntax_asdl::command_t*>(std::initializer_list<syntax_asdl::command_t*>{child});
  this->_GetWord();
  if ((this->c_id != Id::Op_Pipe && this->c_id != Id::Op_PipeAmp)) {
    if (negated != nullptr) {
      node = Alloc<command::Pipeline>(negated, children, Alloc<List<syntax_asdl::Token*>>());
      return node;
    }
    else {
      return child;
    }
  }
  ops = Alloc<List<syntax_asdl::Token*>>();
  while (true) {
    op = word_::AsOperatorToken(this->cur_word);
    ops->append(op);
    this->_SetNext();
    this->_NewlineOk();
    child = this->ParseCommand();
    children->append(child);
    this->_GetWord();
    if ((this->c_id != Id::Op_Pipe && this->c_id != Id::Op_PipeAmp)) {
      break;
    }
  }
  return Alloc<command::Pipeline>(negated, children, ops);
}

syntax_asdl::command_t* CommandParser::ParseAndOr() {
  this->_GetWord();
  if (this->c_id == Id::Lit_TDot) {
    this->_SetNext();
    {  // with
      word_::ctx_Multiline ctx{this->w_parser};

      return this->_ParseAndOr();
    }
  }
  return this->_ParseAndOr();
}

syntax_asdl::command_t* CommandParser::_ParseAndOr() {
  syntax_asdl::command_t* child = nullptr;
  List<syntax_asdl::Token*>* ops = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  StackRoot _root0(&child);
  StackRoot _root1(&ops);
  StackRoot _root2(&children);

  child = this->ParsePipeline();
  this->_GetWord();
  if ((this->c_id != Id::Op_DPipe && this->c_id != Id::Op_DAmp)) {
    return child;
  }
  ops = Alloc<List<syntax_asdl::Token*>>();
  children = NewList<syntax_asdl::command_t*>(std::initializer_list<syntax_asdl::command_t*>{child});
  while (true) {
    ops->append(word_::AsOperatorToken(this->cur_word));
    this->_SetNext();
    this->_NewlineOk();
    child = this->ParsePipeline();
    children->append(child);
    this->_GetWord();
    if ((this->c_id != Id::Op_DPipe && this->c_id != Id::Op_DAmp)) {
      break;
    }
  }
  return Alloc<command::AndOr>(children, ops);
}

syntax_asdl::command_t* CommandParser::_ParseCommandLine() {
  List<int>* END_LIST = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  bool done;
  syntax_asdl::command_t* child = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&END_LIST);
  StackRoot _root1(&children);
  StackRoot _root2(&child);
  StackRoot _root3(&tok);

  END_LIST = NewList<int>(std::initializer_list<int>{Id::Op_Newline, Id::Eof_Real});
  children = Alloc<List<syntax_asdl::command_t*>>();
  done = false;
  while (!done) {
    child = this->ParseAndOr();
    this->_GetWord();
    if ((this->c_id == Id::Op_Semi || this->c_id == Id::Op_Amp)) {
      tok = static_cast<Token*>(this->cur_word);
      child = Alloc<command::Sentence>(child, tok);
      this->_SetNext();
      this->_GetWord();
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
    }
    else {
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
      else {
        p_die(StrFormat("Invalid word while parsing command line (%s)", Id_str(this->c_id)), Alloc<loc::Word>(this->cur_word));
      }
    }
    children->append(child);
  }
  if (len(children) > 1) {
    return Alloc<command::CommandList>(children);
  }
  else {
    return children->at(0);
  }
}

command::CommandList* CommandParser::_ParseCommandTerm() {
  List<int>* END_LIST = nullptr;
  List<syntax_asdl::command_t*>* children = nullptr;
  bool done;
  syntax_asdl::command_t* child = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&END_LIST);
  StackRoot _root1(&children);
  StackRoot _root2(&child);
  StackRoot _root3(&tok);

  END_LIST = NewList<int>(std::initializer_list<int>{this->eof_id, Id::Right_Subshell, Id::Lit_RBrace, Id::Op_DSemi, Id::Op_SemiAmp, Id::Op_DSemiAmp});
  children = Alloc<List<syntax_asdl::command_t*>>();
  done = false;
  while (!done) {
    if (this->_AtSecondaryKeyword()) {
      break;
    }
    child = this->ParseAndOr();
    this->_GetWord();
    if (this->c_id == Id::Op_Newline) {
      this->_SetNext();
      this->_GetWord();
      if (list_contains(END_LIST, this->c_id)) {
        done = true;
      }
    }
    else {
      if ((this->c_id == Id::Op_Semi || this->c_id == Id::Op_Amp)) {
        tok = static_cast<Token*>(this->cur_word);
        child = Alloc<command::Sentence>(child, tok);
        this->_SetNext();
        this->_GetWord();
        if (this->c_id == Id::Op_Newline) {
          this->_SetNext();
          this->_GetWord();
          if (list_contains(END_LIST, this->c_id)) {
            done = true;
          }
        }
        else {
          if (list_contains(END_LIST, this->c_id)) {
            done = true;
          }
        }
      }
      else {
        if (list_contains(END_LIST, this->c_id)) {
          done = true;
        }
        else {
          if ((this->parse_opts->parse_brace() and this->c_id == Id::Lit_LBrace)) {
            done = true;
          }
          else {
            if (this->c_kind != Kind::Word) {
              p_die(S_wpb, Alloc<loc::Word>(this->cur_word));
            }
          }
        }
      }
    }
    children->append(child);
  }
  return Alloc<command::CommandList>(children);
}

command::CommandList* CommandParser::_ParseCommandList() {
  this->_NewlineOk();
  return this->_ParseCommandTerm();
}

syntax_asdl::command_t* CommandParser::ParseLogicalLine() {
  syntax_asdl::command_t* node = nullptr;
  StackRoot _root0(&node);

  this->_NewlineOk();
  this->_GetWord();
  if (this->c_id == Id::Eof_Real) {
    return nullptr;
  }
  node = this->_ParseCommandLine();
  return node;
}

syntax_asdl::parse_result_t* CommandParser::ParseInteractiveLine() {
  syntax_asdl::command_t* node = nullptr;
  StackRoot _root0(&node);

  this->_GetWord();
  if (this->c_id == Id::Op_Newline) {
    return parse_result::EmptyLine;
  }
  if (this->c_id == Id::Eof_Real) {
    return parse_result::Eof;
  }
  node = this->_ParseCommandLine();
  return Alloc<parse_result::Node>(node);
}

syntax_asdl::command_t* CommandParser::ParseCommandSub() {
  command::CommandList* c_list = nullptr;
  StackRoot _root0(&c_list);

  this->_NewlineOk();
  this->_GetWord();
  if (this->c_kind == Kind::Eof) {
    return command::NoOp;
  }
  c_list = this->_ParseCommandTerm();
  if (len(c_list->children) == 1) {
    return c_list->children->at(0);
  }
  else {
    return c_list;
  }
}

void CommandParser::CheckForPendingHereDocs() {
  syntax_asdl::Redir* node = nullptr;
  redir_param::HereDoc* h = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&h);

  if (len(this->pending_here_docs)) {
    node = this->pending_here_docs->at(0);
    h = static_cast<redir_param::HereDoc*>(node->arg);
    p_die(S_tce, Alloc<loc::Word>(h->here_begin));
  }
}

}  // define namespace cmd_parse

namespace glob_ {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using syntax_asdl::CompoundWord;
using syntax_asdl::Token;
using syntax_asdl::word_part_e;
using syntax_asdl::glob_part;
using syntax_asdl::glob_part_e;
using syntax_asdl::glob_part_t;
using mylib::print_stderr;

bool LooksLikeGlob(BigStr* s) {
  bool left_bracket;
  int i;
  int n;
  int c;
  StackRoot _root0(&s);

  left_bracket = false;
  i = 0;
  n = len(s);
  while (i < n) {
    c = mylib::ByteAt(s, i);
    if (mylib::ByteEquals(c, S_iyu)) {
      i += 1;
    }
    else {
      if ((mylib::ByteEquals(c, S_Fgw) or mylib::ByteEquals(c, S_BAk))) {
        return true;
      }
      else {
        if (mylib::ByteEquals(c, S_Eax)) {
          left_bracket = true;
        }
        else {
          if ((mylib::ByteEquals(c, S_pcD) and left_bracket)) {
            return true;
          }
        }
      }
    }
    i += 1;
  }
  return false;
}

bool LooksLikeStaticGlob(syntax_asdl::CompoundWord* w) {
  bool left_bracket;
  int id_;
  StackRoot _root0(&w);

  left_bracket = false;
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    if (part->tag() == word_part_e::Literal) {
      id_ = static_cast<Token*>(part)->id;
      if ((id_ == Id::Lit_Star || id_ == Id::Lit_QMark)) {
        return true;
      }
      else {
        if (id_ == Id::Lit_LBracket) {
          left_bracket = true;
        }
        else {
          if ((id_ == Id::Lit_RBracket and left_bracket)) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
BigStr* GLOB_META_CHARS = S_hpd;

BigStr* GlobEscape(BigStr* s) {
  StackRoot _root0(&s);

  return pyutil::BackslashEscape(s, GLOB_META_CHARS);
}
BigStr* ERE_META_CHARS = S_ivk;

BigStr* ExtendedRegexEscape(BigStr* s) {
  StackRoot _root0(&s);

  return pyutil::BackslashEscape(s, ERE_META_CHARS);
}

BigStr* GlobUnescape(BigStr* s) {
  List<int>* unescaped = nullptr;
  int i;
  int n;
  int c;
  int c2;
  StackRoot _root0(&s);
  StackRoot _root1(&unescaped);

  unescaped = Alloc<List<int>>();
  i = 0;
  n = len(s);
  while (i < n) {
    c = mylib::ByteAt(s, i);
    if ((mylib::ByteEquals(c, S_iyu) and i != (n - 1))) {
      i += 1;
      c2 = mylib::ByteAt(s, i);
      if (mylib::ByteInSet(c2, GLOB_META_CHARS)) {
        unescaped->append(c2);
      }
      else {
        assert(0);  // AssertionError
      }
    }
    else {
      unescaped->append(c);
    }
    i += 1;
  }
  return mylib::JoinBytes(unescaped);
}

_GlobParser::_GlobParser(match::SimpleLexer* lexer) {
  this->lexer = lexer;
  this->token_type = Id::Undefined_Tok;
  this->token_val = S_Aoo;
  this->warnings = Alloc<List<BigStr*>>();
}

void _GlobParser::_Next() {
  Tuple2<int, BigStr*> tup0 = this->lexer->Next();
  this->token_type = tup0.at0();
  this->token_val = tup0.at1();
}

List<syntax_asdl::glob_part_t*>* _GlobParser::_ParseCharClass() {
  glob_part::Literal* first_token = nullptr;
  int balance;
  List<Tuple2<int, BigStr*>*>* tokens = nullptr;
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  bool negated;
  int id1;
  List<BigStr*>* strs = nullptr;
  StackRoot _root0(&first_token);
  StackRoot _root1(&tokens);
  StackRoot _root2(&parts);
  StackRoot _root3(&strs);

  first_token = Alloc<glob_part::Literal>(this->token_type, this->token_val);
  balance = 1;
  tokens = Alloc<List<Tuple2<int, BigStr*>*>>();
  while (true) {
    this->_Next();
    if (this->token_type == Id::Eol_Tok) {
      this->warnings->append(S_idh);
      parts = NewList<syntax_asdl::glob_part_t*>(std::initializer_list<syntax_asdl::glob_part_t*>{first_token});
      for (ListIter<Tuple2<int, BigStr*>*> it(tokens); !it.Done(); it.Next()) {
        Tuple2<int, BigStr*>* tup1 = it.Value();
        int id_ = tup1->at0();
        BigStr* s = tup1->at1();
        StackRoot _unpack_1(&s);
        parts->append(Alloc<glob_part::Literal>(id_, s));
      }
      return parts;
    }
    if (this->token_type == Id::Glob_LBracket) {
      balance += 1;
    }
    else {
      if (this->token_type == Id::Glob_RBracket) {
        balance -= 1;
      }
    }
    if (balance == 0) {
      break;
    }
    tokens->append((Alloc<Tuple2<int, BigStr*>>(this->token_type, this->token_val)));
  }
  negated = false;
  if (len(tokens)) {
    Tuple2<int, BigStr*>* tup2 = tokens->at(0);
    id1 = tup2->at0();
    if ((id1 == Id::Glob_Bang || id1 == Id::Glob_Caret)) {
      negated = true;
      tokens = tokens->slice(1);
    }
  }
  strs = Alloc<List<BigStr*>>();
  for (ListIter<Tuple2<int, BigStr*>*> it(tokens); !it.Done(); it.Next()) {
    Tuple2<int, BigStr*>* tup3 = it.Value();
    BigStr* s = tup3->at1();
    StackRoot _unpack_1(&s);
    strs->append(s);
  }
  return NewList<syntax_asdl::glob_part_t*>(std::initializer_list<syntax_asdl::glob_part_t*>{Alloc<glob_part::CharClass>(negated, strs)});
}

Tuple2<List<syntax_asdl::glob_part_t*>*, List<BigStr*>*> _GlobParser::Parse() {
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  int id_;
  BigStr* s = nullptr;
  StackRoot _root0(&parts);
  StackRoot _root1(&s);

  parts = Alloc<List<syntax_asdl::glob_part_t*>>();
  while (true) {
    this->_Next();
    id_ = this->token_type;
    s = this->token_val;
    if (id_ == Id::Eol_Tok) {
      break;
    }
    if ((id_ == Id::Glob_Star || id_ == Id::Glob_QMark)) {
      parts->append(Alloc<glob_part::Operator>(id_));
    }
    else {
      if (id_ == Id::Glob_LBracket) {
        parts->extend(this->_ParseCharClass());
      }
      else {
        parts->append(Alloc<glob_part::Literal>(id_, s));
      }
    }
    if (id_ == Id::Glob_RBracket) {
      this->warnings->append(S_hoz);
    }
    if (id_ == Id::Glob_BadBackslash) {
      this->warnings->append(S_btq);
    }
  }
  return Tuple2<List<syntax_asdl::glob_part_t*>*, List<BigStr*>*>(parts, this->warnings);
}
BigStr* _REGEX_CHARS_TO_ESCAPE = S_Bge;

BigStr* _GenerateERE(List<syntax_asdl::glob_part_t*>* parts) {
  List<BigStr*>* out = nullptr;
  int tag;
  syntax_asdl::glob_part_t* UP_part = nullptr;
  BigStr* c = nullptr;
  List<BigStr*>* good = nullptr;
  bool literal_hyphen;
  bool literal_rbracket;
  StackRoot _root0(&parts);
  StackRoot _root1(&out);
  StackRoot _root2(&UP_part);
  StackRoot _root3(&c);
  StackRoot _root4(&good);

  out = Alloc<List<BigStr*>>();
  for (ListIter<syntax_asdl::glob_part_t*> it(parts); !it.Done(); it.Next()) {
    syntax_asdl::glob_part_t* part = it.Value();
    StackRoot _for(&part  );
    tag = part->tag();
    UP_part = part;
    if (tag == glob_part_e::Literal) {
      glob_part::Literal* part = static_cast<glob_part::Literal*>(UP_part);
      if (part->id == Id::Glob_EscapedChar) {
        c = part->s->at(1);
        if (str_contains(_REGEX_CHARS_TO_ESCAPE, c)) {
          out->append(S_iyu);
        }
        out->append(c);
      }
      else {
        if ((part->id == Id::Glob_CleanLiterals || part->id == Id::Glob_Bang)) {
          out->append(part->s);
        }
        else {
          if ((part->id == Id::Glob_OtherLiteral || part->id == Id::Glob_Caret)) {
            c = part->s;
            if (str_contains(_REGEX_CHARS_TO_ESCAPE, c)) {
              out->append(S_iyu);
            }
            out->append(c);
          }
          else {
            if (part->id == Id::Glob_LBracket) {
              out->append(S_uDk);
            }
            else {
              if (part->id == Id::Glob_RBracket) {
                out->append(S_dkw);
              }
              else {
                if (part->id == Id::Glob_BadBackslash) {
                  out->append(S_Eef);
                }
                else {
                  if (part->id == Id::Glob_Caret) {
                    out->append(S_EAB);
                  }
                  else {
                    assert(0);  // AssertionError
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      if (tag == glob_part_e::Operator) {
        glob_part::Operator* part = static_cast<glob_part::Operator*>(UP_part);
        if (part->op_id == Id::Glob_QMark) {
          out->append(S_Aru);
        }
        else {
          if (part->op_id == Id::Glob_Star) {
            out->append(S_mgF);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
      else {
        if (tag == glob_part_e::CharClass) {
          glob_part::CharClass* part = static_cast<glob_part::CharClass*>(UP_part);
          out->append(S_Eax);
          if (part->negated) {
            out->append(S_EAB);
          }
          good = Alloc<List<BigStr*>>();
          literal_hyphen = false;
          literal_rbracket = false;
          for (ListIter<BigStr*> it(part->strs); !it.Done(); it.Next()) {
            BigStr* s = it.Value();
            StackRoot _for(&s          );
            if (str_equals(s, S_iCa)) {
              literal_hyphen = true;
              continue;
            }
            if (str_equals(s, S_dkw)) {
              literal_rbracket = true;
              continue;
            }
            good->append(s);
          }
          if (literal_rbracket) {
            out->append(S_pcD);
          }
          out->extend(good);
          if (literal_hyphen) {
            out->append(S_Bjq);
          }
          out->append(S_pcD);
        }
      }
    }
  }
  return S_Aoo->join(out);
}

Tuple2<BigStr*, List<BigStr*>*> GlobToERE(BigStr* pat) {
  match::SimpleLexer* lexer = nullptr;
  glob_::_GlobParser* p = nullptr;
  List<syntax_asdl::glob_part_t*>* parts = nullptr;
  List<BigStr*>* warnings = nullptr;
  BigStr* regex = nullptr;
  StackRoot _root0(&pat);
  StackRoot _root1(&lexer);
  StackRoot _root2(&p);
  StackRoot _root3(&parts);
  StackRoot _root4(&warnings);
  StackRoot _root5(&regex);

  lexer = match::GlobLexer(pat);
  p = Alloc<_GlobParser>(lexer);
  Tuple2<List<syntax_asdl::glob_part_t*>*, List<BigStr*>*> tup4 = p->Parse();
  parts = tup4.at0();
  warnings = tup4.at1();
  regex = _GenerateERE(parts);
  return Tuple2<BigStr*, List<BigStr*>*>(regex, warnings);
}

Globber::Globber(optview::Exec* exec_opts) {
  this->exec_opts = exec_opts;
}

int Globber::_Glob(BigStr* arg, List<BigStr*>* out) {
  int flags;
  List<BigStr*>* results = nullptr;
  BigStr* msg = nullptr;
  int n;
  List<BigStr*>* tmp = nullptr;
  StackRoot _root0(&arg);
  StackRoot _root1(&out);
  StackRoot _root2(&results);
  StackRoot _root3(&msg);
  StackRoot _root4(&tmp);

  try {
    flags = 0;
    if (this->exec_opts->dotglob()) {
      flags |= GLOB_PERIOD;
    }
    results = libc::glob(arg, flags);
  }
  catch (RuntimeError* e) {
    msg = e->message;
    print_stderr(StrFormat("Error expanding glob %r: %s", arg, msg));
    throw;
  }
  n = len(results);
  if (n) {
    if (!this->exec_opts->dashglob()) {
      tmp = Alloc<List<BigStr*>>();
      for (ListIter<BigStr*> it(results); !it.Done(); it.Next()) {
        BigStr* s = it.Value();
        if (!s->startswith(S_Bjq)) {
          tmp->append(s);
        }
      }
      results = tmp;
      n = len(results);
    }
    n = 0;
    for (ListIter<BigStr*> it(results); !it.Done(); it.Next()) {
      BigStr* s = it.Value();
      StackRoot _for(&s    );
      if ((!str_equals(s, S_Aru) && !str_equals(s, S_Dmc))) {
        out->append(s);
        n += 1;
      }
    }
    return n;
  }
  return 0;
}

int Globber::Expand(BigStr* arg, List<BigStr*>* out) {
  int n;
  StackRoot _root0(&arg);
  StackRoot _root1(&out);

  if (this->exec_opts->noglob()) {
    out->append(arg);
    return 1;
  }
  n = this->_Glob(arg, out);
  if (n) {
    return n;
  }
  if (this->exec_opts->failglob()) {
    return -1;
  }
  if (this->exec_opts->nullglob()) {
    return 0;
  }
  else {
    out->append(GlobUnescape(arg));
    return 1;
  }
}

int Globber::ExpandExtended(BigStr* glob_pat, BigStr* fnmatch_pat, List<BigStr*>* out) {
  List<BigStr*>* tmp = nullptr;
  List<BigStr*>* filtered = nullptr;
  int n;
  StackRoot _root0(&glob_pat);
  StackRoot _root1(&fnmatch_pat);
  StackRoot _root2(&out);
  StackRoot _root3(&tmp);
  StackRoot _root4(&filtered);

  if (this->exec_opts->noglob()) {
    out->append(fnmatch_pat);
    return 1;
  }
  tmp = Alloc<List<BigStr*>>();
  this->_Glob(glob_pat, tmp);
  filtered = Alloc<List<BigStr*>>();
  for (ListIter<BigStr*> it(tmp); !it.Done(); it.Next()) {
    BigStr* s = it.Value();
    if (libc::fnmatch(fnmatch_pat, s)) {
      filtered->append(s);
    }
  }
  n = len(filtered);
  if (n) {
    out->extend(filtered);
    return n;
  }
  if (this->exec_opts->failglob()) {
    return -1;
  }
  if (this->exec_opts->nullglob()) {
    return 0;
  }
  else {
    out->append(GlobUnescape(fnmatch_pat));
    return 1;
  }
}

}  // define namespace glob_

namespace tdop {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using syntax_asdl::loc;
using syntax_asdl::arith_expr;
using syntax_asdl::arith_expr_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::CompoundWord;
using syntax_asdl::Token;
using error::p_die;

bool IsIndexable(syntax_asdl::arith_expr_t* node) {
  StackRoot _root0(&node);

  switch (node->tag()) {
    case arith_expr_e::VarSub: 
    case arith_expr_e::Word: {
      return true;
    }
      break;
  }
  return false;
}

void CheckLhsExpr(syntax_asdl::arith_expr_t* node, syntax_asdl::word_t* blame_word) {
  syntax_asdl::arith_expr_t* UP_node = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&blame_word);
  StackRoot _root2(&UP_node);

  UP_node = node;
  if (node->tag() == arith_expr_e::Binary) {
    arith_expr::Binary* node = static_cast<arith_expr::Binary*>(UP_node);
    if ((node->op->id == Id::Arith_LBracket and IsIndexable(node->left))) {
      return ;
    }
  }
  if (IsIndexable(node)) {
    return ;
  }
  p_die(S_kkj, Alloc<loc::Word>(blame_word));
}

syntax_asdl::arith_expr_t* NullError(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  StackRoot _root0(&p);
  StackRoot _root1(&t);

  p_die(S_Dmb, Alloc<loc::Word>(t));
  return nullptr;
}

syntax_asdl::arith_expr_t* NullConstant(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::Token* name_tok = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&name_tok);

  name_tok = word_::LooksLikeArithVar(w);
  if (name_tok) {
    return name_tok;
  }
  return static_cast<CompoundWord*>(w);
}

syntax_asdl::arith_expr_t* NullParen(tdop::TdopParser* p, syntax_asdl::word_t* t, int bp) {
  syntax_asdl::arith_expr_t* r = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&t);
  StackRoot _root2(&r);

  r = p->ParseUntil(bp);
  p->Eat(Id::Arith_RParen);
  return r;
}

syntax_asdl::arith_expr_t* NullPrefixOp(tdop::TdopParser* p, syntax_asdl::word_t* w, int bp) {
  syntax_asdl::arith_expr_t* right = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&right);

  right = p->ParseUntil(bp);
  return Alloc<arith_expr::Unary>(word_::ArithId(w), right);
}

syntax_asdl::arith_expr_t* LeftError(tdop::TdopParser* p, syntax_asdl::word_t* t, syntax_asdl::arith_expr_t* left, int rbp) {
  StackRoot _root0(&p);
  StackRoot _root1(&t);
  StackRoot _root2(&left);

  p_die(S_vvB, Alloc<loc::Word>(t));
  return nullptr;
}

syntax_asdl::arith_expr_t* LeftBinaryOp(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&left);
  StackRoot _root3(&tok);

  tok = static_cast<Token*>(w);
  return Alloc<arith_expr::Binary>(tok, left, p->ParseUntil(rbp));
}

syntax_asdl::arith_expr_t* LeftAssign(tdop::TdopParser* p, syntax_asdl::word_t* w, syntax_asdl::arith_expr_t* left, int rbp) {
  StackRoot _root0(&p);
  StackRoot _root1(&w);
  StackRoot _root2(&left);

  CheckLhsExpr(left, w);
  return Alloc<arith_expr::BinaryAssign>(word_::ArithId(w), left, p->ParseUntil(rbp));
}

TdopParser::TdopParser(tdop::ParserSpec* spec, word_parse::WordParser* w_parser, optview::Parse* parse_opts) {
  this->spec = spec;
  this->w_parser = w_parser;
  this->parse_opts = parse_opts;
  this->cur_word = nullptr;
  this->op_id = Id::Undefined_Tok;
}

int TdopParser::CurrentId() {
  return word_::ArithId(this->cur_word);
}

bool TdopParser::AtToken(int token_type) {
  return this->op_id == token_type;
}

void TdopParser::Eat(int token_type) {
  if (!this->AtToken(token_type)) {
    p_die(StrFormat("Parser expected %s, got %s", ui::PrettyId(token_type), ui::PrettyId(this->op_id)), Alloc<loc::Word>(this->cur_word));
  }
  this->Next();
}

bool TdopParser::Next() {
  this->cur_word = this->w_parser->ReadArithWord();
  this->op_id = word_::ArithId(this->cur_word);
  return true;
}

syntax_asdl::arith_expr_t* TdopParser::ParseUntil(int rbp) {
  syntax_asdl::word_t* t = nullptr;
  tdop::NullInfo* null_info = nullptr;
  syntax_asdl::arith_expr_t* node = nullptr;
  tdop::LeftInfo* left_info = nullptr;
  StackRoot _root0(&t);
  StackRoot _root1(&null_info);
  StackRoot _root2(&node);
  StackRoot _root3(&left_info);

  if ((this->op_id == Id::Eof_Real || this->op_id == Id::Eof_RParen || this->op_id == Id::Eof_Backtick)) {
    p_die(S_dtB, Alloc<loc::Word>(this->cur_word));
  }
  t = this->cur_word;
  null_info = this->spec->LookupNud(this->op_id);
  this->Next();
  node = null_info->nud(this, t, null_info->bp);
  while (true) {
    t = this->cur_word;
    left_info = this->spec->LookupLed(this->op_id);
    if (rbp >= left_info->lbp) {
      break;
    }
    this->Next();
    node = left_info->led(this, t, node, left_info->rbp);
  }
  return node;
}

syntax_asdl::arith_expr_t* TdopParser::Parse() {
  this->Next();
  if (!this->parse_opts->parse_sh_arith()) {
    p_die(S_tFx, Alloc<loc::Word>(this->cur_word));
  }
  return this->ParseUntil(0);
}

}  // define namespace tdop

namespace word_ {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Id_t;
using id_kind_asdl::Kind_t;
using syntax_asdl::Token;
using syntax_asdl::CompoundWord;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::SingleQuoted;
using syntax_asdl::word;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::word_str;
using syntax_asdl::word_part;
using syntax_asdl::word_part_t;
using syntax_asdl::word_part_e;
using syntax_asdl::AssocPair;

int LiteralId(syntax_asdl::word_part_t* part) {
  StackRoot _root0(&part);

  if (part->tag() != word_part_e::Literal) {
    return Id::Undefined_Tok;
  }
  return static_cast<Token*>(part)->id;
}

syntax_asdl::Token* CheckLiteralId(syntax_asdl::word_part_t* part, int tok_id) {
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&part);
  StackRoot _root1(&tok);

  if (part->tag() != word_part_e::Literal) {
    return nullptr;
  }
  tok = static_cast<Token*>(part);
  if (tok->id == tok_id) {
    return tok;
  }
  return nullptr;
}

syntax_asdl::Token* LiteralToken(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part0 = nullptr;
  StackRoot _root0(&UP_w);
  StackRoot _root1(&part0);

  CompoundWord* w = static_cast<CompoundWord*>(UP_w);
  if (len(w->parts) != 1) {
    return nullptr;
  }
  part0 = w->parts->at(0);
  if (part0->tag() != word_part_e::Literal) {
    return nullptr;
  }
  return static_cast<Token*>(part0);
}

Tuple3<bool, BigStr*, bool> _EvalWordPart(syntax_asdl::word_part_t* part) {
  syntax_asdl::word_part_t* UP_part = nullptr;
  BigStr* s = nullptr;
  List<BigStr*>* strs = nullptr;
  bool ok;
  StackRoot _root0(&part);
  StackRoot _root1(&UP_part);
  StackRoot _root2(&s);
  StackRoot _root3(&strs);

  UP_part = part;
  switch (part->tag()) {
    case word_part_e::Literal: {
      Token* tok = static_cast<Token*>(UP_part);
      return Tuple3<bool, BigStr*, bool>(true, lexer::TokenVal(tok), false);
    }
      break;
    case word_part_e::EscapedLiteral: {
      word_part::EscapedLiteral* part = static_cast<word_part::EscapedLiteral*>(UP_part);
      s = lexer::TokenSliceLeft(part->token, 1);
      return Tuple3<bool, BigStr*, bool>(true, s, true);
    }
      break;
    case word_part_e::SingleQuoted: {
      SingleQuoted* part = static_cast<SingleQuoted*>(UP_part);
      return Tuple3<bool, BigStr*, bool>(true, part->sval, true);
    }
      break;
    case word_part_e::DoubleQuoted: {
      DoubleQuoted* part = static_cast<DoubleQuoted*>(UP_part);
      strs = Alloc<List<BigStr*>>();
      for (ListIter<syntax_asdl::word_part_t*> it(part->parts); !it.Done(); it.Next()) {
        syntax_asdl::word_part_t* p = it.Value();
        StackRoot _for(&p      );
        Tuple3<bool, BigStr*, bool> tup0 = _EvalWordPart(p);
        ok = tup0.at0();
        s = tup0.at1();
        if (!ok) {
          return Tuple3<bool, BigStr*, bool>(false, S_Aoo, true);
        }
        strs->append(s);
      }
      return Tuple3<bool, BigStr*, bool>(true, S_Aoo->join(strs), true);
    }
      break;
    case word_part_e::YshArrayLiteral: 
    case word_part_e::InitializerLiteral: 
    case word_part_e::ZshVarSub: 
    case word_part_e::CommandSub: 
    case word_part_e::SimpleVarSub: 
    case word_part_e::BracedVarSub: 
    case word_part_e::TildeSub: 
    case word_part_e::ArithSub: 
    case word_part_e::ExtGlob: 
    case word_part_e::Splice: 
    case word_part_e::ExprSub: {
      return Tuple3<bool, BigStr*, bool>(false, S_Aoo, false);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

BigStr* FastStrEval(syntax_asdl::CompoundWord* w) {
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&part0);
  StackRoot _root2(&UP_part0);

  if (len(w->parts) != 1) {
    return nullptr;
  }
  part0 = w->parts->at(0);
  UP_part0 = part0;
  switch (part0->tag()) {
    case word_part_e::Literal: {
      Token* part0 = static_cast<Token*>(UP_part0);
      if ((part0->id == Id::Lit_Chars || part0->id == Id::Lit_LBracket || part0->id == Id::Lit_RBracket)) {
        return lexer::LazyStr(part0);
      }
      else {
        return nullptr;
      }
    }
      break;
    case word_part_e::SingleQuoted: {
      SingleQuoted* part0 = static_cast<SingleQuoted*>(UP_part0);
      return part0->sval;
    }
      break;
    default: {
      return nullptr;
    }
  }
}

Tuple3<bool, BigStr*, bool> StaticEval(syntax_asdl::word_t* UP_w) {
  bool quoted;
  List<BigStr*>* strs = nullptr;
  bool ok;
  BigStr* s = nullptr;
  bool q;
  StackRoot _root0(&UP_w);
  StackRoot _root1(&strs);
  StackRoot _root2(&s);

  quoted = false;
  if (UP_w->tag() != word_e::Compound) {
    return Tuple3<bool, BigStr*, bool>(false, S_Aoo, quoted);
  }
  CompoundWord* w = static_cast<CompoundWord*>(UP_w);
  strs = Alloc<List<BigStr*>>();
  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    Tuple3<bool, BigStr*, bool> tup1 = _EvalWordPart(part);
    ok = tup1.at0();
    s = tup1.at1();
    q = tup1.at2();
    if (!ok) {
      return Tuple3<bool, BigStr*, bool>(false, S_Aoo, quoted);
    }
    if (q) {
      quoted = true;
    }
    strs->append(s);
  }
  return Tuple3<bool, BigStr*, bool>(true, S_Aoo->join(strs), quoted);
}

syntax_asdl::CompoundWord* TildeDetect(syntax_asdl::word_t* UP_w) {
  StackRoot _root0(&UP_w);

  if (UP_w->tag() != word_e::Compound) {
    return nullptr;
  }
  CompoundWord* w = static_cast<CompoundWord*>(UP_w);
  return TildeDetect2(w);
}

syntax_asdl::CompoundWord* TildeDetect2(syntax_asdl::CompoundWord* w) {
  syntax_asdl::Token* tok0 = nullptr;
  List<syntax_asdl::word_part_t*>* new_parts = nullptr;
  int id1;
  syntax_asdl::Token* tok1 = nullptr;
  int id2;
  StackRoot _root0(&w);
  StackRoot _root1(&tok0);
  StackRoot _root2(&new_parts);
  StackRoot _root3(&tok1);

  if (len(w->parts) == 0) {
    return nullptr;
  }
  tok0 = CheckLiteralId(w->parts->at(0), Id::Lit_Tilde);
  if (tok0 == nullptr) {
    return nullptr;
  }
  new_parts = Alloc<List<syntax_asdl::word_part_t*>>();
  if (len(w->parts) == 1) {
    new_parts->append(Alloc<word_part::TildeSub>(tok0, nullptr, nullptr));
    return Alloc<CompoundWord>(new_parts);
  }
  id1 = LiteralId(w->parts->at(1));
  if (id1 == Id::Lit_Slash) {
    new_parts->append(Alloc<word_part::TildeSub>(tok0, nullptr, nullptr));
    new_parts->extend(w->parts->slice(1));
    return Alloc<CompoundWord>(new_parts);
  }
  if (id1 != Id::Lit_Chars) {
    return nullptr;
  }
  tok1 = static_cast<Token*>(w->parts->at(1));
  if (len(w->parts) == 2) {
    new_parts->append(Alloc<word_part::TildeSub>(tok0, tok1, lexer::TokenVal(tok1)));
    return Alloc<CompoundWord>(new_parts);
  }
  id2 = LiteralId(w->parts->at(2));
  if (id2 != Id::Lit_Slash) {
    return nullptr;
  }
  new_parts->append(Alloc<word_part::TildeSub>(tok0, tok1, lexer::TokenVal(tok1)));
  new_parts->extend(w->parts->slice(2));
  return Alloc<CompoundWord>(new_parts);
}

void TildeDetectAssign(syntax_asdl::CompoundWord* w) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  bool has_tilde;
  List<syntax_asdl::word_part_t*>* new_parts = nullptr;
  bool tilde_could_be_next;
  int i;
  int n;
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::word_part_t* part1 = nullptr;
  syntax_asdl::word_part_t* part2 = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  int id1;
  syntax_asdl::Token* tok1 = nullptr;
  int id2;
  StackRoot _root0(&w);
  StackRoot _root1(&parts);
  StackRoot _root2(&new_parts);
  StackRoot _root3(&part0);
  StackRoot _root4(&part1);
  StackRoot _root5(&part2);
  StackRoot _root6(&tok0);
  StackRoot _root7(&tok1);

  parts = w->parts;
  has_tilde = false;
  for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    if (LiteralId(part) == Id::Lit_Tilde) {
      has_tilde = true;
      break;
    }
  }
  if (!has_tilde) {
    return ;
  }
  parts->append(nullptr);
  parts->append(nullptr);
  new_parts = Alloc<List<syntax_asdl::word_part_t*>>();
  tilde_could_be_next = true;
  i = 0;
  n = len(parts);
  while (i < n) {
    part0 = parts->at(i);
    if (part0 == nullptr) {
      break;
    }
    if ((tilde_could_be_next and LiteralId(part0) == Id::Lit_Tilde)) {
      part1 = parts->at((i + 1));
      part2 = parts->at((i + 2));
      tok0 = static_cast<Token*>(part0);
      if (part1 == nullptr) {
        new_parts->append(Alloc<word_part::TildeSub>(tok0, nullptr, nullptr));
        break;
      }
      id1 = LiteralId(part1);
      if ((id1 == Id::Lit_Slash || id1 == Id::Lit_Colon)) {
        new_parts->append(Alloc<word_part::TildeSub>(tok0, nullptr, nullptr));
        new_parts->append(part1);
        i += 2;
        continue;
      }
      if (id1 != Id::Lit_Chars) {
        new_parts->append(part0);
        new_parts->append(part1);
        i += 2;
        continue;
      }
      tok1 = static_cast<Token*>(part1);
      if (part2 == nullptr) {
        new_parts->append(Alloc<word_part::TildeSub>(tok0, tok1, lexer::TokenVal(tok1)));
        break;
      }
      id2 = LiteralId(part2);
      if ((id2 != Id::Lit_Slash && id2 != Id::Lit_Colon)) {
        new_parts->append(part0);
        new_parts->append(part1);
        new_parts->append(part2);
        i += 3;
        continue;
      }
      new_parts->append(Alloc<word_part::TildeSub>(tok0, tok1, lexer::TokenVal(tok1)));
      new_parts->append(part2);
      i += 3;
      tilde_could_be_next = id2 == Id::Lit_Colon;
    }
    else {
      new_parts->append(part0);
      i += 1;
      tilde_could_be_next = LiteralId(part0) == Id::Lit_Colon;
    }
  }
  parts->pop();
  parts->pop();
  w->parts = new_parts;
}

List<syntax_asdl::word_t*>* TildeDetectAll(List<syntax_asdl::word_t*>* words) {
  List<syntax_asdl::word_t*>* out = nullptr;
  syntax_asdl::CompoundWord* t = nullptr;
  StackRoot _root0(&words);
  StackRoot _root1(&out);
  StackRoot _root2(&t);

  out = Alloc<List<syntax_asdl::word_t*>>();
  for (ListIter<syntax_asdl::word_t*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::word_t* w = it.Value();
    StackRoot _for(&w  );
    t = TildeDetect(w);
    if (t) {
      out->append(t);
    }
    else {
      out->append(w);
    }
  }
  return out;
}

bool HasArrayPart(syntax_asdl::CompoundWord* w) {
  StackRoot _root0(&w);

  for (ListIter<syntax_asdl::word_part_t*> it(w->parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    if (part->tag() == word_part_e::InitializerLiteral) {
      return true;
    }
  }
  return false;
}

BigStr* ShFunctionName(syntax_asdl::CompoundWord* w) {
  bool ok;
  BigStr* s = nullptr;
  bool quoted;
  StackRoot _root0(&w);
  StackRoot _root1(&s);

  Tuple3<bool, BigStr*, bool> tup2 = StaticEval(w);
  ok = tup2.at0();
  s = tup2.at1();
  quoted = tup2.at2();
  if ((!ok or quoted)) {
    return S_Aoo;
  }
  return s;
}

bool IsVarLike(syntax_asdl::CompoundWord* w) {
  StackRoot _root0(&w);

  if (len(w->parts) == 0) {
    return false;
  }
  return LiteralId(w->parts->at(0)) == Id::Lit_VarLike;
}

syntax_asdl::Token* LooksLikeArithVar(syntax_asdl::word_t* UP_w) {
  StackRoot _root0(&UP_w);

  if (UP_w->tag() != word_e::Compound) {
    return nullptr;
  }
  CompoundWord* w = static_cast<CompoundWord*>(UP_w);
  if (len(w->parts) != 1) {
    return nullptr;
  }
  return CheckLiteralId(w->parts->at(0), Id::Lit_ArithVarLike);
}

syntax_asdl::Token* CheckLeadingEquals(syntax_asdl::CompoundWord* w) {
  StackRoot _root0(&w);

  if (len(w->parts) == 0) {
    return nullptr;
  }
  return CheckLiteralId(w->parts->at(0), Id::Lit_Equals);
}

Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int> DetectShAssignment(syntax_asdl::CompoundWord* w) {
  syntax_asdl::Token* no_token = nullptr;
  int n;
  syntax_asdl::word_part_t* part0 = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  syntax_asdl::Token* tok_close = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&no_token);
  StackRoot _root2(&part0);
  StackRoot _root3(&tok0);
  StackRoot _root4(&part);
  StackRoot _root5(&tok_close);

  no_token = nullptr;
  n = len(w->parts);
  if (n == 0) {
    return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0);
  }
  part0 = w->parts->at(0);
  if (part0->tag() != word_part_e::Literal) {
    return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0);
  }
  tok0 = static_cast<Token*>(part0);
  if (tok0->id == Id::Lit_VarLike) {
    return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(tok0, no_token, 1);
  }
  if (tok0->id == Id::Lit_ArrayLhsOpen) {
    if (n < 2) {
      return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0);
    }
    for (int i = 1; i < n; ++i) {
      part = w->parts->at(i);
      tok_close = CheckLiteralId(part, Id::Lit_ArrayLhsClose);
      if (tok_close) {
        return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(tok0, tok_close, (i + 1));
      }
    }
  }
  return Tuple3<syntax_asdl::Token*, syntax_asdl::Token*, int>(no_token, no_token, 0);
}

syntax_asdl::AssocPair* DetectAssocPair(syntax_asdl::CompoundWord* w) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int n;
  int id_;
  syntax_asdl::CompoundWord* key = nullptr;
  syntax_asdl::CompoundWord* value = nullptr;
  bool has_plus;
  StackRoot _root0(&w);
  StackRoot _root1(&parts);
  StackRoot _root2(&key);
  StackRoot _root3(&value);

  parts = w->parts;
  if (LiteralId(parts->at(0)) != Id::Lit_LBracket) {
    return nullptr;
  }
  n = len(parts);
  for (int i = 0; i < n; ++i) {
    id_ = LiteralId(parts->at(i));
    if (id_ == Id::Lit_ArrayLhsClose) {
      key = Alloc<CompoundWord>(parts->slice(1, i));
      value = Alloc<CompoundWord>(parts->slice((i + 1)));
      has_plus = lexer::IsPlusEquals(static_cast<Token*>(parts->at(i)));
      return Alloc<AssocPair>(key, value, has_plus);
    }
  }
  return nullptr;
}

Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*> IsControlFlow(syntax_asdl::CompoundWord* w) {
  syntax_asdl::Token* no_token = nullptr;
  syntax_asdl::word_part_t* UP_part0 = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoot _root0(&w);
  StackRoot _root1(&no_token);
  StackRoot _root2(&UP_part0);

  no_token = nullptr;
  if (len(w->parts) != 1) {
    return Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token);
  }
  UP_part0 = w->parts->at(0);
  token_type = LiteralId(UP_part0);
  if (token_type == Id::Undefined_Tok) {
    return Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token);
  }
  token_kind = consts::GetKind(token_type);
  if (token_kind == Kind::ControlFlow) {
    return Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(token_kind, static_cast<Token*>(UP_part0));
  }
  return Tuple2<id_kind_asdl::Kind_t, syntax_asdl::Token*>(Kind::Undefined, no_token);
}

syntax_asdl::Token* BraceToken(syntax_asdl::word_t* UP_w) {
  StackRoot _root0(&UP_w);

  switch (UP_w->tag()) {
    case word_e::Operator: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok;
    }
      break;
    case word_e::Compound: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      return LiteralToken(w);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

syntax_asdl::Token* AsKeywordToken(syntax_asdl::word_t* UP_w) {
  syntax_asdl::word_part_t* part = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&UP_w);
  StackRoot _root1(&part);
  StackRoot _root2(&tok);

  CompoundWord* w = static_cast<CompoundWord*>(UP_w);
  part = w->parts->at(0);
  tok = static_cast<Token*>(part);
  return tok;
}

syntax_asdl::Token* AsOperatorToken(syntax_asdl::word_t* word) {
  StackRoot _root0(&word);

  return static_cast<Token*>(word);
}

int ArithId(syntax_asdl::word_t* w) {
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&tok);

  if (w->tag() == word_e::Operator) {
    tok = static_cast<Token*>(w);
    return tok->id;
  }
  return Id::Word_Compound;
}

int BoolId(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoot _root0(&w);
  StackRoot _root1(&UP_w);

  UP_w = w;
  switch (w->tag()) {
    case word_e::String: {
      word::String* w = static_cast<word::String*>(UP_w);
      return w->id;
    }
      break;
    case word_e::Operator: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->id;
    }
      break;
    case word_e::Compound: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      if (len(w->parts) != 1) {
        return Id::Word_Compound;
      }
      token_type = LiteralId(w->parts->at(0));
      if (token_type == Id::Undefined_Tok) {
        return Id::Word_Compound;
      }
      if ((token_type == Id::KW_Bang || token_type == Id::Lit_DRightBracket)) {
        return token_type;
      }
      token_kind = consts::GetKind(token_type);
      if ((token_kind == Kind::BoolUnary || token_kind == Kind::BoolBinary)) {
        return token_type;
      }
      return Id::Word_Compound;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

int CommandId(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  int token_type;
  id_kind_asdl::Kind_t token_kind;
  StackRoot _root0(&w);
  StackRoot _root1(&UP_w);

  UP_w = w;
  switch (w->tag()) {
    case word_e::Operator: {
      Token* tok = static_cast<Token*>(UP_w);
      return tok->id;
    }
      break;
    case word_e::Compound: {
      CompoundWord* w = static_cast<CompoundWord*>(UP_w);
      if (len(w->parts) != 1) {
        return Id::Word_Compound;
      }
      token_type = LiteralId(w->parts->at(0));
      if (token_type == Id::Undefined_Tok) {
        return Id::Word_Compound;
      }
      if ((token_type == Id::Lit_LBrace || token_type == Id::Lit_RBrace || token_type == Id::Lit_Equals || token_type == Id::Lit_TDot)) {
        return token_type;
      }
      token_kind = consts::GetKind(token_type);
      if (token_kind == Kind::KW) {
        return token_type;
      }
      return Id::Word_Compound;
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

id_kind_asdl::Kind_t CommandKind(syntax_asdl::word_t* w) {
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&tok);

  if (w->tag() == word_e::Operator) {
    tok = static_cast<Token*>(w);
    return consts::GetKind(tok->id);
  }
  return Kind::Word;
}

bool IsVarSub(syntax_asdl::word_t* w) {
  StackRoot _root0(&w);

  return false;
}

syntax_asdl::CompoundWord* ErrorWord(BigStr* error_str) {
  syntax_asdl::Token* t = nullptr;
  StackRoot _root0(&error_str);
  StackRoot _root1(&t);

  t = lexer::DummyToken(Id::Lit_Chars, error_str);
  return Alloc<CompoundWord>(NewList<syntax_asdl::word_part_t*>(std::initializer_list<syntax_asdl::word_part_t*>{t}));
}

BigStr* Pretty(syntax_asdl::word_t* w) {
  syntax_asdl::word_t* UP_w = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&UP_w);

  UP_w = w;
  if (w->tag() == word_e::String) {
    word::String* w = static_cast<word::String*>(UP_w);
    if (w->id == Id::Eof_Real) {
      return S_ngj;
    }
    else {
      return repr(w->s);
    }
  }
  else {
    return word_str(w->tag());
  }
}

ctx_EmitDocToken::ctx_EmitDocToken(word_parse::WordParser* w_parser) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->w_parser)));
  w_parser->EmitDocToken(true);
  this->w_parser = w_parser;
}

ctx_EmitDocToken::~ctx_EmitDocToken() {
  this->w_parser->EmitDocToken(false);
  gHeap.PopRoot();
}

ctx_Multiline::ctx_Multiline(word_parse::WordParser* w_parser) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->w_parser)));
  w_parser->Multiline(true);
  this->w_parser = w_parser;
}

ctx_Multiline::~ctx_Multiline() {
  this->w_parser->Multiline(false);
  gHeap.PopRoot();
}

}  // define namespace word_

namespace word_compile {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using syntax_asdl::Token;
using syntax_asdl::CharCode;
using syntax_asdl::word_part_e;
using syntax_asdl::word_part_t;
using error::p_die;

syntax_asdl::CharCode* EvalCharLiteralForRegex(syntax_asdl::Token* tok) {
  int id_;
  BigStr* value = nullptr;
  BigStr* s = nullptr;
  int i;
  BigStr* one_char_str = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&value);
  StackRoot _root2(&s);
  StackRoot _root3(&one_char_str);

  id_ = tok->id;
  value = lexer::TokenVal(tok);
  switch (id_) {
    case Id::Char_UBraced: {
      s = lexer::TokenSlice(tok, 3, -1);
      i = to_int(s, 16);
      return Alloc<CharCode>(tok, i, true);
    }
      break;
    case Id::Char_OneChar: {
      one_char_str = consts::LookupCharC(value->at(1));
      return Alloc<CharCode>(tok, ord(one_char_str), false);
    }
      break;
    case Id::Char_Hex: {
      s = lexer::TokenSliceLeft(tok, 2);
      i = to_int(s, 16);
      return Alloc<CharCode>(tok, i, false);
    }
      break;
    case Id::Lit_Chars: 
    case Id::Expr_Name: 
    case Id::Expr_DecInt: {
      return Alloc<CharCode>(tok, ord(value->at(0)), false);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

BigStr* EvalCStringToken(int id_, BigStr* value) {
  int code_point;
  BigStr* c = nullptr;
  BigStr* s = nullptr;
  int i;
  StackRoot _root0(&value);
  StackRoot _root1(&c);
  StackRoot _root2(&s);

  code_point = -1;
  if ((id_ == Id::Lit_Chars || id_ == Id::Lit_CharsWithoutPrefix || id_ == Id::Unknown_Backslash)) {
    return value;
  }
  else {
    if (id_ == Id::Right_SingleQuote) {
      return value;
    }
    else {
      if (id_ == Id::Char_OneChar) {
        c = value->at(1);
        return consts::LookupCharC(c);
      }
      else {
        if (id_ == Id::Char_Stop) {
          return nullptr;
        }
        else {
          if ((id_ == Id::Char_Octal3 || id_ == Id::Char_Octal4)) {
            if (id_ == Id::Char_Octal3) {
              s = value->slice(1);
            }
            else {
              s = value->slice(2);
            }
            i = to_int(s, 8);
            if (i >= 256) {
              i = (i % 256);
            }
            return chr(i);
          }
          else {
            if ((id_ == Id::Char_Hex || id_ == Id::Char_YHex)) {
              s = value->slice(2);
              i = to_int(s, 16);
              return chr(i);
            }
            else {
              if ((id_ == Id::Char_Unicode4 || id_ == Id::Char_Unicode8)) {
                s = value->slice(2);
                code_point = to_int(s, 16);
                return j8::Utf8Encode(code_point);
              }
              else {
                if (id_ == Id::Char_UBraced) {
                  s = value->slice(3, -1);
                  code_point = to_int(s, 16);
                  return j8::Utf8Encode(code_point);
                }
                else {
                  assert(0);  // AssertionError
                }
              }
            }
          }
        }
      }
    }
  }
}

BigStr* EvalSingleQuoted(int id_, List<syntax_asdl::Token*>* tokens) {
  List<BigStr*>* strs = nullptr;
  BigStr* s = nullptr;
  int code_point;
  StackRoot _root0(&tokens);
  StackRoot _root1(&strs);
  StackRoot _root2(&s);

  if ((id_ == Id::Left_SingleQuote || id_ == Id::Left_RSingleQuote || id_ == Id::Left_TSingleQuote || id_ == Id::Left_RTSingleQuote)) {
    strs = Alloc<List<BigStr*>>();
    for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
      syntax_asdl::Token* t = it.Value();
      strs->append(lexer::TokenVal(t));
    }
  }
  else {
    if ((id_ == Id::Left_DollarSingleQuote || id_ == Id::Left_USingleQuote || id_ == Id::Left_BSingleQuote || id_ == Id::Left_UTSingleQuote || id_ == Id::Left_BTSingleQuote)) {
      strs = Alloc<List<BigStr*>>();
      for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
        syntax_asdl::Token* t = it.Value();
        StackRoot _for(&t      );
        if (t->id == Id::Char_UBraced) {
          s = lexer::TokenSlice(t, 3, -1);
          code_point = to_int(s, 16);
          if (code_point > 1114111) {
            p_die(S_egA, t);
          }
          if ((55296 <= code_point and code_point < 57344)) {
            p_die(StrFormat("%s escape is illegal because it's in the surrogate range", lexer::TokenVal(t)), t);
          }
        }
        strs->append(EvalCStringToken(t->id, lexer::TokenVal(t)));
      }
    }
    else {
      assert(0);  // AssertionError
    }
  }
  return S_Aoo->join(strs);
}

bool _TokenConsistsOf(syntax_asdl::Token* tok, BigStr* byte_set) {
  int start;
  int end;
  int b;
  StackRoot _root0(&tok);
  StackRoot _root1(&byte_set);

  start = tok->col;
  end = (tok->col + tok->length);
  for (int i = start; i < end; ++i) {
    b = mylib::ByteAt(tok->line->content, i);
    if (!mylib::ByteInSet(b, byte_set)) {
      return false;
    }
  }
  return true;
}

bool _IsLeadingSpace(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  return _TokenConsistsOf(tok, S_jEs);
}

bool _IsTrailingSpace(syntax_asdl::Token* tok) {
  StackRoot _root0(&tok);

  return _TokenConsistsOf(tok, S_Dqk);
}

void RemoveLeadingSpaceDQ(List<syntax_asdl::word_part_t*>* parts) {
  syntax_asdl::word_part_t* UP_first = nullptr;
  syntax_asdl::word_part_t* UP_last = nullptr;
  BigStr* to_strip = nullptr;
  int n;
  syntax_asdl::Token* lit_tok = nullptr;
  StackRoot _root0(&parts);
  StackRoot _root1(&UP_first);
  StackRoot _root2(&UP_last);
  StackRoot _root3(&to_strip);
  StackRoot _root4(&lit_tok);

  if (len(parts) <= 1) {
    return ;
  }
  UP_first = parts->at(0);
  if (UP_first->tag() == word_part_e::Literal) {
    Token* first = static_cast<Token*>(UP_first);
    if (_IsTrailingSpace(first)) {
      parts->pop(0);
    }
  }
  UP_last = parts->at(-1);
  to_strip = nullptr;
  if (UP_last->tag() == word_part_e::Literal) {
    Token* last = static_cast<Token*>(UP_last);
    if (_IsLeadingSpace(last)) {
      to_strip = lexer::TokenVal(last);
      parts->pop();
    }
  }
  if (to_strip == nullptr) {
    return ;
  }
  n = len(to_strip);
  for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next()) {
    syntax_asdl::word_part_t* part = it.Value();
    StackRoot _for(&part  );
    if (part->tag() != word_part_e::Literal) {
      continue;
    }
    lit_tok = static_cast<Token*>(part);
    if ((lit_tok->col == 0 and lexer::TokenStartsWith(lit_tok, to_strip))) {
      lit_tok->col = n;
      lit_tok->length -= n;
      lit_tok->id = Id::Lit_CharsWithoutPrefix;
    }
  }
}

void RemoveLeadingSpaceSQ(List<syntax_asdl::Token*>* tokens) {
  syntax_asdl::Token* first = nullptr;
  syntax_asdl::Token* last = nullptr;
  BigStr* to_strip = nullptr;
  int n;
  StackRoot _root0(&tokens);
  StackRoot _root1(&first);
  StackRoot _root2(&last);
  StackRoot _root3(&to_strip);

  if (len(tokens) <= 1) {
    return ;
  }
  first = tokens->at(0);
  if (first->id == Id::Lit_Chars) {
    if (_IsTrailingSpace(first)) {
      tokens->pop(0);
    }
  }
  last = tokens->at(-1);
  to_strip = nullptr;
  if (last->id == Id::Lit_Chars) {
    if (_IsLeadingSpace(last)) {
      to_strip = lexer::TokenVal(last);
      tokens->pop();
    }
  }
  if (to_strip == nullptr) {
    return ;
  }
  n = len(to_strip);
  for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
    syntax_asdl::Token* tok = it.Value();
    StackRoot _for(&tok  );
    if ((tok->col == 0 and lexer::TokenStartsWith(tok, to_strip))) {
      tok->col = n;
      tok->length -= n;
      tok->id = Id::Lit_CharsWithoutPrefix;
    }
  }
}

}  // define namespace word_compile

namespace word_parse {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using id_kind_asdl::Kind;
using types_asdl::lex_mode_t;
using types_asdl::lex_mode_e;
using syntax_asdl::BoolParamBox;
using syntax_asdl::Token;
using syntax_asdl::SimpleVarSub;
using syntax_asdl::loc;
using syntax_asdl::source;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::SingleQuoted;
using syntax_asdl::BracedVarSub;
using syntax_asdl::CommandSub;
using syntax_asdl::InitializerWord;
using syntax_asdl::InitializerWord_t;
using syntax_asdl::bracket_op;
using syntax_asdl::bracket_op_t;
using syntax_asdl::suffix_op;
using syntax_asdl::suffix_op_t;
using syntax_asdl::rhs_word;
using syntax_asdl::rhs_word_e;
using syntax_asdl::rhs_word_t;
using syntax_asdl::word_e;
using syntax_asdl::word_t;
using syntax_asdl::CompoundWord;
using syntax_asdl::word_part;
using syntax_asdl::word_part_t;
using syntax_asdl::y_lhs_e;
using syntax_asdl::arith_expr_t;
using syntax_asdl::command;
using syntax_asdl::expr;
using syntax_asdl::expr_e;
using syntax_asdl::expr_t;
using syntax_asdl::pat_t;
using syntax_asdl::ArgList;
using syntax_asdl::Proc;
using syntax_asdl::Func;
using syntax_asdl::Subscript;
using syntax_asdl::Attribute;
using syntax_asdl::arith_expr;
using syntax_asdl::VarDecl;
using syntax_asdl::Mutation;
using syntax_asdl::word_part_e;
using error::p_die;
GLOBAL_LIST(KINDS_THAT_END_WORDS, id_kind_asdl::Kind_t, 4, {Kind::Eof COMMA Kind::WS COMMA Kind::Op COMMA Kind::Right});

bool _IsValidYshWord(syntax_asdl::CompoundWord* w) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  int n;
  bool ok;
  StackRoot _root0(&w);
  StackRoot _root1(&parts);

  parts = w->parts;
  n = len(parts);
  if ((n != 0 and word_::LiteralId(parts->at(0)) == Id::Lit_Tilde)) {
    return true;
  }
  ok = true;
  if (n >= 2) {
    for (ListIter<syntax_asdl::word_part_t*> it(parts); !it.Done(); it.Next()) {
      syntax_asdl::word_part_t* part = it.Value();
      StackRoot _for(&part    );
      if ((part->tag() == word_part_e::SingleQuoted || part->tag() == word_part_e::DoubleQuoted)) {
        ok = false;
      }
    }
  }
  if (!ok) {
    if ((n == 2 and word_::LiteralId(parts->at(0)) == Id::Lit_VarLike)) {
      ok = true;
    }
    else {
      if ((n == 3 and (word_::LiteralId(parts->at(0)) == Id::Lit_Chars and word_::LiteralId(parts->at(1)) == Id::Lit_Equals))) {
        ok = true;
      }
    }
  }
  return ok;
}

WordEmitter::WordEmitter() {
  ;  // pass
}

syntax_asdl::word_t* WordEmitter::ReadWord(types_asdl::lex_mode_t lex_mode) {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

WordParser::WordParser(parse_lib::ParseContext* parse_ctx, lexer::Lexer* lexer, reader::_Reader* line_reader) {
  this->parse_ctx = parse_ctx;
  this->lexer = lexer;
  this->line_reader = line_reader;
  this->arena = line_reader->arena;
  this->parse_opts = parse_ctx->parse_opts;
  this->a_parser = Alloc<tdop::TdopParser>(arith_parse::Spec(), this, this->parse_opts);
  this->Reset();
}

void WordParser::Init(types_asdl::lex_mode_t lex_mode) {
  this->next_lex_mode = lex_mode;
}

void WordParser::Reset() {
  this->cur_token = nullptr;
  this->token_kind = Kind::Undefined;
  this->token_type = Id::Undefined_Tok;
  this->next_lex_mode = lex_mode_e::ShCommand;
  this->emit_doc_token = false;
  this->multiline = false;
  this->newline_state = 0;
  this->returned_newline = false;
  this->buffered_word = nullptr;
}

void WordParser::_GetToken() {
  bool is_fake;
  types_asdl::lex_mode_t real_mode;
  if (this->next_lex_mode == lex_mode_e::Undefined) {
    return ;
  }
  is_fake = this->next_lex_mode == lex_mode_e::BashRegexFakeInner;
  real_mode = is_fake ? lex_mode_e::BashRegex : this->next_lex_mode;
  this->cur_token = this->lexer->Read(real_mode);
  if ((is_fake and (this->cur_token->id == Id::WS_Space || this->cur_token->id == Id::BashRegex_AllowedInParens))) {
    this->cur_token->id = Id::Lit_Chars;
  }
  this->token_type = this->cur_token->id;
  this->token_kind = consts::GetKind(this->token_type);
  if (this->token_type == Id::Op_Newline) {
    this->newline_state += 1;
  }
  else {
    if (this->token_kind != Kind::WS) {
      this->newline_state = 0;
    }
  }
  this->parse_ctx->trail->AppendToken(this->cur_token);
  this->next_lex_mode = lex_mode_e::Undefined;
}

void WordParser::_SetNext(types_asdl::lex_mode_t lex_mode) {
  this->next_lex_mode = lex_mode;
}

syntax_asdl::rhs_word_t* WordParser::_ReadVarOpArg(types_asdl::lex_mode_t arg_lex_mode) {
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&w);

  this->_SetNext(arg_lex_mode);
  this->_GetToken();
  w = this->_ReadVarOpArg2(arg_lex_mode, Id::Undefined_Tok, true);
  if ((len(w->parts) == 0 and arg_lex_mode == lex_mode_e::VSub_ArgDQ)) {
    return rhs_word::Empty;
  }
  return w;
}

syntax_asdl::CompoundWord* WordParser::_ReadVarOpArg2(types_asdl::lex_mode_t arg_lex_mode, int eof_type, bool empty_ok) {
  syntax_asdl::CompoundWord* w = nullptr;
  syntax_asdl::CompoundWord* tilde = nullptr;
  StackRoot _root0(&w);
  StackRoot _root1(&tilde);

  w = this->_ReadCompoundWord3(arg_lex_mode, eof_type, empty_ok);
  tilde = word_::TildeDetect(w);
  if (tilde) {
    w = tilde;
  }
  return w;
}

suffix_op::Slice* WordParser::_ReadSliceVarOp() {
  int cur_id;
  syntax_asdl::arith_expr_t* begin = nullptr;
  syntax_asdl::arith_expr_t* no_length = nullptr;
  syntax_asdl::Token* colon_tok = nullptr;
  syntax_asdl::arith_expr_t* length = nullptr;
  StackRoot _root0(&begin);
  StackRoot _root1(&no_length);
  StackRoot _root2(&colon_tok);
  StackRoot _root3(&length);

  this->_NextNonSpace();
  cur_id = this->token_type;
  if ((cur_id == Id::Arith_RBrace || cur_id == Id::Arith_Colon)) {
    begin = arith_expr::EmptyZero;
  }
  else {
    begin = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  if (cur_id == Id::Arith_RBrace) {
    no_length = nullptr;
    return Alloc<suffix_op::Slice>(begin, no_length);
  }
  else {
    if (cur_id == Id::Arith_Colon) {
      colon_tok = this->cur_token;
      this->_NextNonSpace();
      if (this->token_type == Id::Arith_RBrace) {
        if (this->parse_opts->strict_parse_slice()) {
          p_die(S_npc, colon_tok);
        }
        length = arith_expr::EmptyZero;
      }
      else {
        length = this->_ReadArithExpr(Id::Arith_RBrace);
      }
      return Alloc<suffix_op::Slice>(begin, length);
    }
    else {
      p_die(S_jod, this->cur_token);
    }
  }
  assert(0);  // AssertionError
}

suffix_op::PatSub* WordParser::_ReadPatSubVarOp() {
  syntax_asdl::Token* slash_tok = nullptr;
  int replace_mode;
  syntax_asdl::CompoundWord* pat = nullptr;
  bool empty_ok;
  syntax_asdl::rhs_word_t* replace = nullptr;
  StackRoot _root0(&slash_tok);
  StackRoot _root1(&pat);
  StackRoot _root2(&replace);

  slash_tok = this->cur_token;
  replace_mode = Id::Undefined_Tok;
  this->_SetNext(lex_mode_e::VSub_ArgUnquoted);
  this->_GetToken();
  if (this->token_type == Id::Right_DollarBrace) {
    pat = Alloc<CompoundWord>(Alloc<List<syntax_asdl::word_part_t*>>());
    return Alloc<suffix_op::PatSub>(pat, rhs_word::Empty, replace_mode, slash_tok);
  }
  if ((this->token_type == Id::Lit_Slash || this->token_type == Id::Lit_Pound || this->token_type == Id::Lit_Percent)) {
    replace_mode = this->token_type;
    this->_SetNext(lex_mode_e::VSub_ArgUnquoted);
  }
  empty_ok = replace_mode != Id::Lit_Slash;
  pat = this->_ReadVarOpArg2(lex_mode_e::VSub_ArgUnquoted, Id::Lit_Slash, empty_ok);
  if (this->token_type == Id::Lit_Slash) {
    replace = this->_ReadVarOpArg(lex_mode_e::VSub_ArgUnquoted);
  }
  else {
    replace = rhs_word::Empty;
  }
  this->_GetToken();
  if (this->token_type != Id::Right_DollarBrace) {
    p_die(StrFormat("Expected } after replacement string, got %s", ui::PrettyId(this->token_type)), this->cur_token);
  }
  return Alloc<suffix_op::PatSub>(pat, replace, replace_mode, slash_tok);
}

syntax_asdl::bracket_op_t* WordParser::_ReadSubscript() {
  int next_id;
  syntax_asdl::bracket_op_t* op = nullptr;
  syntax_asdl::arith_expr_t* anode = nullptr;
  StackRoot _root0(&op);
  StackRoot _root1(&anode);

  next_id = this->lexer->LookPastSpace(lex_mode_e::Arith);
  if ((next_id == Id::Lit_At || next_id == Id::Arith_Star)) {
    op = Alloc<bracket_op::WholeArray>(next_id);
    this->_SetNext(lex_mode_e::Arith);
    this->_GetToken();
    this->_SetNext(lex_mode_e::Arith);
    this->_GetToken();
  }
  else {
    this->_SetNext(lex_mode_e::Arith);
    anode = this->_ReadArithExpr(Id::Arith_RBracket);
    op = Alloc<bracket_op::ArrayIndex>(anode);
  }
  if (this->token_type != Id::Arith_RBracket) {
    p_die(S_sxv, this->cur_token);
  }
  this->_SetNext(lex_mode_e::VSub_2);
  this->_GetToken();
  return op;
}

syntax_asdl::BracedVarSub* WordParser::_ParseVarOf() {
  syntax_asdl::Token* name_token = nullptr;
  syntax_asdl::bracket_op_t* bracket_op = nullptr;
  syntax_asdl::BracedVarSub* part = nullptr;
  StackRoot _root0(&name_token);
  StackRoot _root1(&bracket_op);
  StackRoot _root2(&part);

  this->_GetToken();
  name_token = this->cur_token;
  this->_SetNext(lex_mode_e::VSub_2);
  this->_GetToken();
  if (this->token_type == Id::VOp2_LBracket) {
    bracket_op = this->_ReadSubscript();
  }
  else {
    bracket_op = nullptr;
  }
  part = BracedVarSub::CreateNull();
  part->name_tok = name_token;
  part->var_name = lexer::TokenVal(name_token);
  part->bracket_op = bracket_op;
  return part;
}

syntax_asdl::BracedVarSub* WordParser::_ParseVarExpr(types_asdl::lex_mode_t arg_lex_mode, bool allow_query) {
  syntax_asdl::BracedVarSub* part = nullptr;
  id_kind_asdl::Kind_t op_kind;
  syntax_asdl::Token* tok = nullptr;
  syntax_asdl::rhs_word_t* arg_word = nullptr;
  syntax_asdl::rhs_word_t* UP_arg_word = nullptr;
  bool ok;
  BigStr* arg = nullptr;
  bool quoted;
  syntax_asdl::suffix_op_t* patsub_op = nullptr;
  StackRoot _root0(&part);
  StackRoot _root1(&tok);
  StackRoot _root2(&arg_word);
  StackRoot _root3(&UP_arg_word);
  StackRoot _root4(&arg);
  StackRoot _root5(&patsub_op);

  part = this->_ParseVarOf();
  this->_GetToken();
  if (this->token_type == Id::Right_DollarBrace) {
    return part;
  }
  op_kind = this->token_kind;
  if (op_kind == Kind::VTest) {
    tok = this->cur_token;
    arg_word = this->_ReadVarOpArg(arg_lex_mode);
    if (this->token_type != Id::Right_DollarBrace) {
      p_die(S_fpg, this->cur_token);
    }
    part->suffix_op = Alloc<suffix_op::Unary>(tok, arg_word);
  }
  else {
    if (op_kind == Kind::VOpYsh) {
      tok = this->cur_token;
      arg_word = this->_ReadVarOpArg(arg_lex_mode);
      if (this->token_type != Id::Right_DollarBrace) {
        p_die(S_fpg, this->cur_token);
      }
      UP_arg_word = arg_word;
      switch (arg_word->tag()) {
        case rhs_word_e::Empty: {
          ;  // pass
        }
          break;
        case rhs_word_e::Compound: {
          CompoundWord* arg_word = static_cast<CompoundWord*>(UP_arg_word);
          Tuple3<bool, BigStr*, bool> tup0 = word_::StaticEval(arg_word);
          ok = tup0.at0();
          arg = tup0.at1();
          quoted = tup0.at2();
          if ((!ok or quoted)) {
            p_die(S_Fwi, Alloc<loc::Word>(arg_word));
          }
        }
          break;
      }
      part->suffix_op = Alloc<suffix_op::Static>(tok, arg);
    }
    else {
      if (op_kind == Kind::VOp0) {
        part->suffix_op = this->cur_token;
        this->_SetNext(lex_mode_e::VSub_2);
        this->_GetToken();
      }
      else {
        if (op_kind == Kind::VOp1) {
          tok = this->cur_token;
          arg_word = this->_ReadVarOpArg(lex_mode_e::VSub_ArgUnquoted);
          if (this->token_type != Id::Right_DollarBrace) {
            p_die(S_fpg, this->cur_token);
          }
          part->suffix_op = Alloc<suffix_op::Unary>(tok, arg_word);
        }
        else {
          if (op_kind == Kind::VOp2) {
            if (this->token_type == Id::VOp2_Slash) {
              patsub_op = this->_ReadPatSubVarOp();
              part->suffix_op = patsub_op;
            }
            else {
              if (this->token_type == Id::VOp2_Colon) {
                part->suffix_op = this->_ReadSliceVarOp();
                if (this->token_type != Id::Arith_RBrace) {
                  p_die(S_fpg, this->cur_token);
                }
              }
              else {
                p_die(StrFormat("Unexpected token in ${} (%s)", S_Duk), this->cur_token);
              }
            }
          }
          else {
            if (op_kind == Kind::VOp3) {
              if (allow_query) {
                part->suffix_op = this->cur_token;
                this->_SetNext(lex_mode_e::VSub_2);
                this->_GetToken();
              }
              else {
                p_die(StrFormat("Unexpected token in ${} (%s)", S_hgF), this->cur_token);
              }
            }
          }
        }
      }
    }
  }
  if ((this->token_type != Id::Right_DollarBrace && this->token_type != Id::Arith_RBrace)) {
    p_die(S_fpg, this->cur_token);
  }
  return part;
}

word_part::ZshVarSub* WordParser::_ReadZshVarSub(syntax_asdl::Token* left_token) {
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&w);

  this->_SetNext(lex_mode_e::VSub_Zsh);
  w = this->_ReadCompoundWord3(lex_mode_e::VSub_Zsh, Id::Right_DollarBrace, true);
  this->_GetToken();
  return Alloc<word_part::ZshVarSub>(left_token, w, this->cur_token);
}

Tuple2<syntax_asdl::BracedVarSub*, syntax_asdl::Token*> WordParser::ReadBracedVarSub(syntax_asdl::Token* left_token) {
  syntax_asdl::BracedVarSub* part = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&part);
  StackRoot _root2(&last_token);

  part = this->_ReadBracedVarSub(left_token, false);
  last_token = this->cur_token;
  return Tuple2<syntax_asdl::BracedVarSub*, syntax_asdl::Token*>(part, last_token);
}

syntax_asdl::BracedVarSub* WordParser::_ReadBracedVarSub(syntax_asdl::Token* left_token, bool d_quoted) {
  types_asdl::lex_mode_t arg_lex_mode;
  int ty;
  syntax_asdl::Token* first_tok = nullptr;
  int next_id;
  syntax_asdl::BracedVarSub* part = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&first_tok);
  StackRoot _root2(&part);

  if (d_quoted) {
    arg_lex_mode = lex_mode_e::VSub_ArgDQ;
  }
  else {
    arg_lex_mode = lex_mode_e::VSub_ArgUnquoted;
  }
  this->_SetNext(lex_mode_e::VSub_1);
  this->_GetToken();
  ty = this->token_type;
  first_tok = this->cur_token;
  if (ty == Id::VSub_Pound) {
    next_id = this->lexer->LookPastSpace(lex_mode_e::VSub_1);
    if ((next_id != Id::Unknown_Tok && next_id != Id::Right_DollarBrace)) {
      this->_SetNext(lex_mode_e::VSub_1);
      part = this->_ParseVarOf();
      this->_GetToken();
      if (this->token_type != Id::Right_DollarBrace) {
        p_die(S_mpl, this->cur_token);
      }
      part->prefix_op = first_tok;
    }
    else {
      part = this->_ParseVarExpr(arg_lex_mode);
    }
  }
  else {
    if (ty == Id::VSub_Bang) {
      next_id = this->lexer->LookPastSpace(lex_mode_e::VSub_1);
      if ((next_id != Id::Unknown_Tok && next_id != Id::Right_DollarBrace)) {
        this->_SetNext(lex_mode_e::VSub_1);
        part = this->_ParseVarExpr(arg_lex_mode, true);
        part->prefix_op = first_tok;
      }
      else {
        part = this->_ParseVarExpr(arg_lex_mode);
      }
    }
    else {
      if (ty == Id::VSub_Dot) {
        p_die(S_hzv, this->cur_token);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          part = this->_ParseVarExpr(arg_lex_mode);
        }
        else {
          p_die(S_tBm, this->cur_token);
        }
      }
    }
  }
  part->left = left_token;
  part->right = this->cur_token;
  return part;
}

syntax_asdl::SingleQuoted* WordParser::_ReadSingleQuoted(syntax_asdl::Token* left_token, types_asdl::lex_mode_t lex_mode) {
  List<syntax_asdl::Token*>* tokens = nullptr;
  syntax_asdl::Token* right_quote = nullptr;
  BigStr* sval = nullptr;
  syntax_asdl::SingleQuoted* node = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&tokens);
  StackRoot _root2(&right_quote);
  StackRoot _root3(&sval);
  StackRoot _root4(&node);

  tokens = Alloc<List<syntax_asdl::Token*>>();
  right_quote = this->ReadSingleQuoted(lex_mode, left_token, tokens, false);
  sval = word_compile::EvalSingleQuoted(left_token->id, tokens);
  node = Alloc<SingleQuoted>(left_token, sval, right_quote);
  return node;
}

syntax_asdl::Token* WordParser::ReadSingleQuoted(types_asdl::lex_mode_t lex_mode, syntax_asdl::Token* left_token, List<syntax_asdl::Token*>* out_tokens, bool is_ysh_expr) {
  List<syntax_asdl::Token*>* tokens = nullptr;
  bool no_backslashes;
  int expected_end_tokens;
  int num_end_tokens;
  syntax_asdl::Token* tok = nullptr;
  bool is_u_string;
  StackRoot _root0(&left_token);
  StackRoot _root1(&out_tokens);
  StackRoot _root2(&tokens);
  StackRoot _root3(&tok);

  tokens = Alloc<List<syntax_asdl::Token*>>();
  no_backslashes = (is_ysh_expr and left_token->id == Id::Left_SingleQuote);
  expected_end_tokens = (left_token->id == Id::Left_TSingleQuote || left_token->id == Id::Left_RTSingleQuote || left_token->id == Id::Left_UTSingleQuote || left_token->id == Id::Left_BTSingleQuote) ? 3 : 1;
  num_end_tokens = 0;
  while (num_end_tokens < expected_end_tokens) {
    this->_SetNext(lex_mode);
    this->_GetToken();
    if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Char)) {
      tok = this->cur_token;
      if ((no_backslashes and lexer::TokenContains(tok, S_iyu))) {
        p_die(S_mrm, tok);
      }
      if (is_ysh_expr) {
        if (this->token_type == Id::Char_Octal3) {
          p_die(S_jmF, tok);
        }
        if ((this->token_type == Id::Char_Hex and this->cur_token->length != 4)) {
          p_die(S_dDj, tok);
        }
      }
      tokens->append(tok);
    }
    else {
      if (this->token_kind == Kind::Unknown) {
        tok = this->cur_token;
        if ((is_ysh_expr or !this->parse_opts->parse_backslash())) {
          p_die(S_vla, tok);
        }
        tokens->append(tok);
      }
      else {
        if (this->token_kind == Kind::Eof) {
          p_die(S_acC, left_token);
        }
        else {
          if (this->token_kind == Kind::Right) {
            num_end_tokens += 1;
            tokens->append(this->cur_token);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
    if (this->token_kind != Kind::Right) {
      num_end_tokens = 0;
    }
  }
  if (expected_end_tokens == 1) {
    tokens->pop();
  }
  else {
    if (expected_end_tokens == 3) {
      tokens->pop();
      tokens->pop();
      tokens->pop();
    }
  }
  if ((left_token->id == Id::Left_TSingleQuote || left_token->id == Id::Left_RTSingleQuote || left_token->id == Id::Left_UTSingleQuote || left_token->id == Id::Left_BTSingleQuote)) {
    word_compile::RemoveLeadingSpaceSQ(tokens);
  }
  is_u_string = (left_token->id == Id::Left_USingleQuote || left_token->id == Id::Left_UTSingleQuote);
  for (ListIter<syntax_asdl::Token*> it(tokens); !it.Done(); it.Next()) {
    syntax_asdl::Token* tok = it.Value();
    StackRoot _for(&tok  );
    if ((is_u_string and tok->id == Id::Char_YHex)) {
      p_die(StrFormat("%s escapes not allowed in u'' strings", lexer::TokenVal(tok)), tok);
    }
  }
  out_tokens->extend(tokens);
  return this->cur_token;
}

syntax_asdl::word_part_t* WordParser::_ReadDoubleQuotedLeftParts() {
  if ((this->token_type == Id::Left_DollarParen || this->token_type == Id::Left_Backtick)) {
    return this->_ReadCommandSub(this->token_type, true);
  }
  if (this->token_type == Id::Left_DollarBrace) {
    return this->_ReadBracedVarSub(this->cur_token, true);
  }
  if (this->token_type == Id::Left_DollarDParen) {
    return this->_ReadArithSub();
  }
  if (this->token_type == Id::Left_DollarBracket) {
    return this->_ReadExprSub(lex_mode_e::DQ);
  }
  if (this->token_type == Id::Left_DollarBraceZsh) {
    return this->_ReadZshVarSub(this->cur_token);
  }
  assert(0);  // AssertionError
}

syntax_asdl::CompoundWord* WordParser::_ReadYshSingleQuoted(int left_id) {
  types_asdl::lex_mode_t lexer_mode;
  int triple_left_id;
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::SingleQuoted* sq_part = nullptr;
  StackRoot _root0(&left_tok);
  StackRoot _root1(&sq_part);

  if (left_id == Id::Left_RSingleQuote) {
    lexer_mode = lex_mode_e::SQ_Raw;
    triple_left_id = Id::Left_RTSingleQuote;
  }
  else {
    if (left_id == Id::Left_USingleQuote) {
      lexer_mode = lex_mode_e::J8_Str;
      triple_left_id = Id::Left_UTSingleQuote;
    }
    else {
      if (left_id == Id::Left_BSingleQuote) {
        lexer_mode = lex_mode_e::J8_Str;
        triple_left_id = Id::Left_BTSingleQuote;
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  left_tok = this->cur_token;
  left_tok->id = left_id;
  sq_part = this->_ReadSingleQuoted(left_tok, lexer_mode);
  if ((len(sq_part->sval) == 0 and str_equals(this->lexer->ByteLookAhead(), S_Bfw))) {
    this->_SetNext(lex_mode_e::ShCommand);
    this->_GetToken();
    left_tok = this->cur_token;
    left_tok->id = triple_left_id;
    sq_part = this->_ReadSingleQuoted(left_tok, lexer_mode);
  }
  this->_SetNext(lex_mode_e::ShCommand);
  this->_GetToken();
  if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
    p_die(S_wxA, this->cur_token);
  }
  return Alloc<CompoundWord>(NewList<syntax_asdl::word_part_t*>(std::initializer_list<syntax_asdl::word_part_t*>{sq_part}));
}

syntax_asdl::word_part_t* WordParser::_ReadUnquotedLeftParts(syntax_asdl::BoolParamBox* triple_out) {
  syntax_asdl::DoubleQuoted* dq_part = nullptr;
  syntax_asdl::Token* left_dq_token = nullptr;
  types_asdl::lex_mode_t lexer_mode;
  int triple_left_id;
  syntax_asdl::SingleQuoted* sq_part = nullptr;
  syntax_asdl::Token* left_sq_token = nullptr;
  StackRoot _root0(&triple_out);
  StackRoot _root1(&dq_part);
  StackRoot _root2(&left_dq_token);
  StackRoot _root3(&sq_part);
  StackRoot _root4(&left_sq_token);

  if ((this->token_type == Id::Left_DoubleQuote || this->token_type == Id::Left_DollarDoubleQuote)) {
    dq_part = this->_ReadDoubleQuoted(this->cur_token);
    if ((triple_out and (len(dq_part->parts) == 0 and str_equals(this->lexer->ByteLookAhead(), S_krt)))) {
      this->_SetNext(lex_mode_e::ShCommand);
      this->_GetToken();
      left_dq_token = this->cur_token;
      left_dq_token->id = Id::Left_TDoubleQuote;
      triple_out->b = true;
      return this->_ReadDoubleQuoted(left_dq_token);
    }
    return dq_part;
  }
  if ((this->token_type == Id::Left_SingleQuote || this->token_type == Id::Left_RSingleQuote || this->token_type == Id::Left_DollarSingleQuote)) {
    if (this->token_type == Id::Left_SingleQuote) {
      lexer_mode = lex_mode_e::SQ_Raw;
      triple_left_id = Id::Left_TSingleQuote;
    }
    else {
      if (this->token_type == Id::Left_RSingleQuote) {
        lexer_mode = lex_mode_e::SQ_Raw;
        triple_left_id = Id::Left_RTSingleQuote;
      }
      else {
        lexer_mode = lex_mode_e::SQ_C;
        triple_left_id = Id::Undefined_Tok;
      }
    }
    sq_part = this->_ReadSingleQuoted(this->cur_token, lexer_mode);
    if ((triple_left_id != Id::Undefined_Tok and (triple_out != nullptr and (len(sq_part->sval) == 0 and str_equals(this->lexer->ByteLookAhead(), S_Bfw))))) {
      this->_SetNext(lex_mode_e::ShCommand);
      this->_GetToken();
      left_sq_token = this->cur_token;
      left_sq_token->id = triple_left_id;
      triple_out->b = true;
      return this->_ReadSingleQuoted(left_sq_token, lexer_mode);
    }
    return sq_part;
  }
  if ((this->token_type == Id::Left_DollarParen || this->token_type == Id::Left_Backtick || this->token_type == Id::Left_ProcSubIn || this->token_type == Id::Left_ProcSubOut)) {
    return this->_ReadCommandSub(this->token_type, false);
  }
  if (this->token_type == Id::Left_DollarBrace) {
    return this->_ReadBracedVarSub(this->cur_token, false);
  }
  if (this->token_type == Id::Left_DollarDParen) {
    return this->_ReadArithSub();
  }
  if (this->token_type == Id::Left_DollarBracket) {
    return this->_ReadExprSub(lex_mode_e::ShCommand);
  }
  if (this->token_type == Id::Left_DollarBraceZsh) {
    return this->_ReadZshVarSub(this->cur_token);
  }
  assert(0);  // AssertionError
}

word_part::ExtGlob* WordParser::_ReadExtGlob() {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* right_token = nullptr;
  List<syntax_asdl::CompoundWord*>* arms = nullptr;
  bool read_word;
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&right_token);
  StackRoot _root2(&arms);
  StackRoot _root3(&w);

  left_token = this->cur_token;
  right_token = nullptr;
  arms = Alloc<List<syntax_asdl::CompoundWord*>>();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_ExtGlob);
  this->_SetNext(lex_mode_e::ExtGlob);
  read_word = false;
  while (true) {
    this->_GetToken();
    if (this->token_type == Id::Right_ExtGlob) {
      if (!read_word) {
        arms->append(Alloc<CompoundWord>(Alloc<List<syntax_asdl::word_part_t*>>()));
      }
      right_token = this->cur_token;
      break;
    }
    else {
      if (this->token_type == Id::Op_Pipe) {
        if (!read_word) {
          arms->append(Alloc<CompoundWord>(Alloc<List<syntax_asdl::word_part_t*>>()));
        }
        read_word = false;
        this->_SetNext(lex_mode_e::ExtGlob);
      }
      else {
        if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Left || this->token_kind == Kind::VSub || this->token_kind == Kind::ExtGlob)) {
          w = this->_ReadCompoundWord(lex_mode_e::ExtGlob);
          arms->append(w);
          read_word = true;
        }
        else {
          if (this->token_kind == Kind::Eof) {
            p_die(S_ilx, left_token);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
  return Alloc<word_part::ExtGlob>(left_token, arms, right_token);
}

word_part::BashRegexGroup* WordParser::_ReadBashRegexGroup() {
  syntax_asdl::Token* left_token = nullptr;
  List<syntax_asdl::CompoundWord*>* arms = nullptr;
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&arms);
  StackRoot _root2(&w);

  left_token = this->cur_token;
  arms = Alloc<List<syntax_asdl::CompoundWord*>>();
  this->lexer->PushHint(Id::Op_RParen, Id::Right_BashRegexGroup);
  this->_SetNext(lex_mode_e::BashRegexFakeInner);
  this->_GetToken();
  if (this->token_type == Id::Right_BashRegexGroup) {
    return Alloc<word_part::BashRegexGroup>(left_token, nullptr, this->cur_token);
  }
  if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Left || this->token_kind == Kind::VSub || this->token_kind == Kind::BashRegex)) {
    w = this->_ReadCompoundWord(lex_mode_e::BashRegexFakeInner);
    arms->append(w);
    this->_GetToken();
    if (this->token_type != Id::Right_BashRegexGroup) {
      p_die(S_paD, this->cur_token);
    }
    return Alloc<word_part::BashRegexGroup>(left_token, w, this->cur_token);
  }
  p_die(S_see, this->cur_token);
}

void WordParser::_ReadLikeDQ(syntax_asdl::Token* left_token, bool is_ysh_expr, List<syntax_asdl::word_part_t*>* out_parts) {
  int expected_end_tokens;
  int num_end_tokens;
  syntax_asdl::Token* tok = nullptr;
  BigStr* ch = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&out_parts);
  StackRoot _root2(&tok);
  StackRoot _root3(&ch);
  StackRoot _root4(&part);

  if (left_token) {
    if ((left_token->id == Id::Left_TDoubleQuote || left_token->id == Id::Left_DollarTDoubleQuote)) {
      expected_end_tokens = 3;
    }
    else {
      expected_end_tokens = 1;
    }
  }
  else {
    expected_end_tokens = 1000;
  }
  num_end_tokens = 0;
  while (num_end_tokens < expected_end_tokens) {
    this->_SetNext(lex_mode_e::DQ);
    this->_GetToken();
    if (this->token_kind == Kind::Lit) {
      if (this->token_type == Id::Lit_EscapedChar) {
        tok = this->cur_token;
        ch = lexer::TokenSliceLeft(tok, 1);
        part = Alloc<word_part::EscapedLiteral>(tok, ch);
      }
      else {
        if (this->token_type == Id::Lit_BadBackslash) {
          if ((is_ysh_expr or !this->parse_opts->parse_backslash())) {
            p_die(S_Bpn, this->cur_token);
          }
        }
        else {
          if (this->token_type == Id::Lit_Dollar) {
            if ((is_ysh_expr or !this->parse_opts->parse_dollar())) {
              p_die(S_oex, this->cur_token);
            }
          }
        }
        part = this->cur_token;
      }
      out_parts->append(part);
    }
    else {
      if (this->token_kind == Kind::Left) {
        if ((this->token_type == Id::Left_Backtick and is_ysh_expr)) {
          p_die(S_bio, this->cur_token);
        }
        part = this->_ReadDoubleQuotedLeftParts();
        out_parts->append(part);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          tok = this->cur_token;
          part = Alloc<SimpleVarSub>(tok);
          out_parts->append(part);
        }
        else {
          if (this->token_kind == Kind::Right) {
            if (left_token) {
              num_end_tokens += 1;
            }
            out_parts->append(this->cur_token);
          }
          else {
            if (this->token_kind == Kind::Eof) {
              if (left_token) {
                p_die(S_fip, left_token);
              }
              else {
                break;
              }
            }
            else {
              assert(0);  // AssertionError
            }
          }
        }
      }
    }
    if (this->token_kind != Kind::Right) {
      num_end_tokens = 0;
    }
  }
  if (expected_end_tokens == 1) {
    out_parts->pop();
  }
  else {
    if (expected_end_tokens == 3) {
      out_parts->pop();
      out_parts->pop();
      out_parts->pop();
    }
  }
  if ((left_token and (left_token->id == Id::Left_TDoubleQuote || left_token->id == Id::Left_DollarTDoubleQuote))) {
    word_compile::RemoveLeadingSpaceDQ(out_parts);
  }
}

syntax_asdl::DoubleQuoted* WordParser::_ReadDoubleQuoted(syntax_asdl::Token* left_token) {
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  syntax_asdl::Token* right_quote = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&parts);
  StackRoot _root2(&right_quote);

  parts = Alloc<List<syntax_asdl::word_part_t*>>();
  this->_ReadLikeDQ(left_token, false, parts);
  right_quote = this->cur_token;
  return Alloc<DoubleQuoted>(left_token, parts, right_quote);
}

syntax_asdl::Token* WordParser::ReadDoubleQuoted(syntax_asdl::Token* left_token, List<syntax_asdl::word_part_t*>* parts) {
  StackRoot _root0(&left_token);
  StackRoot _root1(&parts);

  this->_ReadLikeDQ(left_token, true, parts);
  return this->cur_token;
}

syntax_asdl::CommandSub* WordParser::_ReadCommandSub(int left_id, bool d_quoted) {
  syntax_asdl::Token* left_token = nullptr;
  int right_id;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::command_t* node = nullptr;
  syntax_asdl::Token* right_token = nullptr;
  List<BigStr*>* parts = nullptr;
  BigStr* code_str = nullptr;
  alloc::Arena* arena = nullptr;
  reader::FileLineReader* line_reader = nullptr;
  source::Reparsed* src = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&c_parser);
  StackRoot _root2(&node);
  StackRoot _root3(&right_token);
  StackRoot _root4(&parts);
  StackRoot _root5(&code_str);
  StackRoot _root6(&arena);
  StackRoot _root7(&line_reader);
  StackRoot _root8(&src);

  left_token = this->cur_token;
  if ((left_id == Id::Left_DollarParen || left_id == Id::Left_AtParen || left_id == Id::Left_ProcSubIn || left_id == Id::Left_ProcSubOut)) {
    this->_SetNext(lex_mode_e::ShCommand);
    right_id = Id::Eof_RParen;
    this->lexer->PushHint(Id::Op_RParen, right_id);
    c_parser = this->parse_ctx->MakeParserForCommandSub(this->line_reader, this->lexer, right_id);
    node = c_parser->ParseCommandSub();
    right_token = c_parser->w_parser->cur_token;
  }
  else {
    if ((left_id == Id::Left_Backtick and this->parse_ctx->do_lossless)) {
      right_id = Id::Eof_Backtick;
      this->lexer->PushHint(Id::Left_Backtick, right_id);
      c_parser = this->parse_ctx->MakeParserForCommandSub(this->line_reader, this->lexer, right_id);
      node = c_parser->ParseCommandSub();
      right_token = c_parser->w_parser->cur_token;
    }
    else {
      if (left_id == Id::Left_Backtick) {
        if (!this->parse_opts->parse_backticks()) {
          p_die(S_Aeo, left_token);
        }
        this->_SetNext(lex_mode_e::Backtick);
        parts = Alloc<List<BigStr*>>();
        while (true) {
          this->_GetToken();
          if (this->token_type == Id::Backtick_Quoted) {
            parts->append(lexer::TokenSliceLeft(this->cur_token, 1));
          }
          else {
            if (this->token_type == Id::Backtick_DoubleQuote) {
              if (d_quoted) {
                parts->append(lexer::TokenSliceLeft(this->cur_token, 1));
              }
              else {
                parts->append(lexer::TokenVal(this->cur_token));
              }
            }
            else {
              if (this->token_type == Id::Backtick_Other) {
                parts->append(lexer::TokenVal(this->cur_token));
              }
              else {
                if (this->token_type == Id::Backtick_Right) {
                  break;
                }
                else {
                  if (this->token_type == Id::Eof_Real) {
                    p_die(S_edt, left_token);
                  }
                  else {
                    assert(0);  // AssertionError
                  }
                }
              }
            }
          }
          this->_SetNext(lex_mode_e::Backtick);
        }
        right_token = this->cur_token;
        code_str = S_Aoo->join(parts);
        arena = this->parse_ctx->arena;
        line_reader = reader::StringLineReader(code_str, arena);
        c_parser = this->parse_ctx->MakeOshParser(line_reader);
        src = Alloc<source::Reparsed>(S_vlc, left_token, right_token);
        {  // with
          alloc::ctx_SourceCode ctx{arena, src};

          node = c_parser->ParseCommandSub();
        }
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  return Alloc<CommandSub>(left_token, node, right_token);
}

word_part::ExprSub* WordParser::_ReadExprSub(types_asdl::lex_mode_t lex_mode) {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* right_token = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&enode);
  StackRoot _root2(&right_token);

  left_token = this->cur_token;
  this->_SetNext(lex_mode_e::Expr);
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup1 = this->parse_ctx->ParseYshExpr(this->lexer, grammar_nt::ysh_expr_sub);
  enode = tup1.at0();
  right_token = tup1.at1();
  this->_SetNext(lex_mode);
  return Alloc<word_part::ExprSub>(left_token, enode, right_token);
}

syntax_asdl::VarDecl* WordParser::ParseVarDecl(syntax_asdl::Token* kw_token) {
  syntax_asdl::VarDecl* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&kw_token);
  StackRoot _root1(&enode);
  StackRoot _root2(&last_token);

  this->_SetNext(lex_mode_e::Expr);
  Tuple2<syntax_asdl::VarDecl*, syntax_asdl::Token*> tup2 = this->parse_ctx->ParseVarDecl(kw_token, this->lexer);
  enode = tup2.at0();
  last_token = tup2.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  this->buffered_word = last_token;
  this->_SetNext(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::Mutation* WordParser::ParseMutation(syntax_asdl::Token* kw_token, cmd_parse::VarChecker* var_checker) {
  syntax_asdl::Mutation* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  syntax_asdl::y_lhs_t* UP_lhs = nullptr;
  expr::Var* v = nullptr;
  StackRoot _root0(&kw_token);
  StackRoot _root1(&var_checker);
  StackRoot _root2(&enode);
  StackRoot _root3(&last_token);
  StackRoot _root4(&UP_lhs);
  StackRoot _root5(&v);

  this->_SetNext(lex_mode_e::Expr);
  Tuple2<syntax_asdl::Mutation*, syntax_asdl::Token*> tup3 = this->parse_ctx->ParseMutation(kw_token, this->lexer);
  enode = tup3.at0();
  last_token = tup3.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  for (ListIter<syntax_asdl::y_lhs_t*> it(enode->lhs); !it.Done(); it.Next()) {
    syntax_asdl::y_lhs_t* lhs = it.Value();
    StackRoot _for(&lhs  );
    UP_lhs = lhs;
    switch (lhs->tag()) {
      case y_lhs_e::Var: {
        Token* lhs = static_cast<Token*>(UP_lhs);
        var_checker->Check(kw_token->id, lexer::LazyStr(lhs), lhs);
      }
        break;
      case y_lhs_e::Subscript: {
        Subscript* lhs = static_cast<Subscript*>(UP_lhs);
        if (lhs->obj->tag() == expr_e::Var) {
          v = static_cast<expr::Var*>(lhs->obj);
          var_checker->Check(kw_token->id, v->name, v->left);
        }
      }
        break;
      case y_lhs_e::Attribute: {
        Attribute* lhs = static_cast<Attribute*>(UP_lhs);
        if (lhs->obj->tag() == expr_e::Var) {
          v = static_cast<expr::Var*>(lhs->obj);
          var_checker->Check(kw_token->id, v->name, v->left);
        }
      }
        break;
    }
  }
  this->buffered_word = last_token;
  this->_SetNext(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::expr_t* WordParser::ParseBareDecl() {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&enode);
  StackRoot _root1(&last_token);

  this->_SetNext(lex_mode_e::Expr);
  this->_GetToken();
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup4 = this->parse_ctx->ParseYshExpr(this->lexer, grammar_nt::command_expr);
  enode = tup4.at0();
  last_token = tup4.at1();
  if (last_token->id == Id::Op_RBrace) {
    last_token->id = Id::Lit_RBrace;
  }
  this->buffered_word = last_token;
  this->_SetNext(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::expr_t* WordParser::ParseYshExprForCommand() {
  syntax_asdl::expr_t* enode = nullptr;
  StackRoot _root0(&enode);

  if (this->token_type == Id::Op_LParen) {
    this->lexer->MaybeUnreadOne();
  }
  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup5 = this->parse_ctx->ParseYshExpr(this->lexer, grammar_nt::ysh_expr);
  enode = tup5.at0();
  this->_SetNext(lex_mode_e::ShCommand);
  return enode;
}

syntax_asdl::expr_t* WordParser::ParseCommandExpr() {
  syntax_asdl::expr_t* enode = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&enode);
  StackRoot _root1(&last_token);

  Tuple2<syntax_asdl::expr_t*, syntax_asdl::Token*> tup6 = this->parse_ctx->ParseYshExpr(this->lexer, grammar_nt::command_expr);
  enode = tup6.at0();
  last_token = tup6.at1();
  if (last_token->id != Id::Eof_Real) {
    this->lexer->MaybeUnreadOne();
  }
  return enode;
}

void WordParser::ParseProc(syntax_asdl::Proc* node) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&last_token);

  this->_SetNext(lex_mode_e::ShCommand);
  this->_GetToken();
  if (this->token_type != Id::Lit_Chars) {
    p_die(StrFormat("Invalid proc name %s", ui::PrettyToken(this->cur_token)), this->cur_token);
  }
  node->name = this->cur_token;
  last_token = this->parse_ctx->ParseProc(this->lexer, node);
  last_token->id = Id::Lit_LBrace;
  this->buffered_word = last_token;
  this->_SetNext(lex_mode_e::ShCommand);
}

void WordParser::ParseFunc(syntax_asdl::Func* node) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&last_token);

  last_token = this->parse_ctx->ParseFunc(this->lexer, node);
  last_token->id = Id::Lit_LBrace;
  this->buffered_word = last_token;
  this->_SetNext(lex_mode_e::ShCommand);
}

Tuple2<syntax_asdl::pat_t*, syntax_asdl::Token*> WordParser::ParseYshCasePattern() {
  syntax_asdl::pat_t* pat = nullptr;
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&pat);
  StackRoot _root1(&left_tok);
  StackRoot _root2(&last_token);

  Tuple3<syntax_asdl::pat_t*, syntax_asdl::Token*, syntax_asdl::Token*> tup7 = this->parse_ctx->ParseYshCasePattern(this->lexer);
  pat = tup7.at0();
  left_tok = tup7.at1();
  last_token = tup7.at2();
  if (last_token->id == Id::Op_LBrace) {
    last_token->id = Id::Lit_LBrace;
  }
  this->buffered_word = last_token;
  return Tuple2<syntax_asdl::pat_t*, syntax_asdl::Token*>(pat, left_tok);
}

int WordParser::NewlineOkForYshCase() {
  int next_id;
  id_kind_asdl::Kind_t next_kind;
  while (true) {
    next_id = this->lexer->LookAheadOne(lex_mode_e::Expr);
    if (next_id == Id::Unknown_Tok) {
      if (!this->lexer->MoveToNextLine()) {
        break;
      }
      continue;
    }
    next_kind = consts::GetKind(next_id);
    if ((next_id != Id::Op_Newline and next_kind != Kind::Ignored)) {
      break;
    }
    this->lexer->Read(lex_mode_e::Expr);
  }
  if ((next_id == Id::Op_RBrace || next_id == Id::Op_LParen || next_id == Id::Arith_Slash)) {
    this->_SetNext(lex_mode_e::Expr);
  }
  else {
    this->_SetNext(lex_mode_e::ShCommand);
    this->_GetToken();
  }
  return next_id;
}

syntax_asdl::arith_expr_t* WordParser::_ReadArithExpr(int end_id) {
  syntax_asdl::arith_expr_t* anode = nullptr;
  int cur_id;
  StackRoot _root0(&anode);

  anode = this->a_parser->Parse();
  cur_id = this->a_parser->CurrentId();
  if ((end_id != Id::Undefined_Tok and cur_id != end_id)) {
    p_die(StrFormat("Unexpected token after arithmetic expression (%s != %s)", ui::PrettyId(cur_id), ui::PrettyId(end_id)), Alloc<loc::Word>(this->a_parser->cur_word));
  }
  return anode;
}

word_part::ArithSub* WordParser::_ReadArithSub() {
  syntax_asdl::Token* left_tok = nullptr;
  syntax_asdl::arith_expr_t* anode = nullptr;
  syntax_asdl::Token* right_tok = nullptr;
  StackRoot _root0(&left_tok);
  StackRoot _root1(&anode);
  StackRoot _root2(&right_tok);

  left_tok = this->cur_token;
  this->lexer->PushHint(Id::Op_RParen, Id::Right_DollarDParen);
  anode = arith_expr::EmptyZero;
  this->_NextNonSpace();
  if (this->token_type != Id::Arith_RParen) {
    anode = this->_ReadArithExpr(Id::Arith_RParen);
  }
  this->_SetNext(lex_mode_e::ShCommand);
  this->_GetToken();
  if (this->token_type != Id::Right_DollarDParen) {
    p_die(S_fsD, this->cur_token);
  }
  right_tok = this->cur_token;
  return Alloc<word_part::ArithSub>(left_tok, anode, right_tok);
}

Tuple2<syntax_asdl::arith_expr_t*, syntax_asdl::Token*> WordParser::ReadDParen() {
  syntax_asdl::arith_expr_t* anode = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&anode);
  StackRoot _root1(&right);

  anode = arith_expr::EmptyZero;
  this->lexer->PushHint(Id::Op_RParen, Id::Op_DRightParen);
  this->_NextNonSpace();
  if (this->token_type != Id::Arith_RParen) {
    anode = this->_ReadArithExpr(Id::Arith_RParen);
  }
  this->_SetNext(lex_mode_e::ShCommand);
  this->_GetToken();
  right = this->cur_token;
  if (right->id != Id::Op_DRightParen) {
    p_die(S_Fgl, right);
  }
  this->_SetNext(lex_mode_e::ShCommand);
  return Tuple2<syntax_asdl::arith_expr_t*, syntax_asdl::Token*>(anode, right);
}

void WordParser::_NextNonSpace() {
  while (true) {
    this->_SetNext(lex_mode_e::Arith);
    this->_GetToken();
    if ((this->token_kind != Kind::Ignored && this->token_kind != Kind::WS)) {
      break;
    }
  }
}

command::ForExpr* WordParser::ReadForExpression() {
  int cur_id;
  syntax_asdl::arith_expr_t* init_node = nullptr;
  syntax_asdl::arith_expr_t* cond_node = nullptr;
  syntax_asdl::arith_expr_t* update_node = nullptr;
  command::ForExpr* node = nullptr;
  StackRoot _root0(&init_node);
  StackRoot _root1(&cond_node);
  StackRoot _root2(&update_node);
  StackRoot _root3(&node);

  this->_NextNonSpace();
  cur_id = this->token_type;
  if (cur_id == Id::Arith_Semi) {
    init_node = arith_expr::EmptyZero;
  }
  else {
    init_node = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  this->_NextNonSpace();
  if (cur_id != Id::Arith_Semi) {
    p_die(S_lun, Alloc<loc::Word>(this->a_parser->cur_word));
  }
  this->_GetToken();
  cur_id = this->token_type;
  if (cur_id == Id::Arith_Semi) {
    cond_node = arith_expr::EmptyOne;
  }
  else {
    cond_node = this->a_parser->Parse();
    cur_id = this->a_parser->CurrentId();
  }
  if (cur_id != Id::Arith_Semi) {
    p_die(S_lun, Alloc<loc::Word>(this->a_parser->cur_word));
  }
  this->_NextNonSpace();
  if (this->token_type == Id::Arith_RParen) {
    update_node = arith_expr::EmptyZero;
  }
  else {
    update_node = this->_ReadArithExpr(Id::Arith_RParen);
  }
  this->_NextNonSpace();
  if (this->token_type != Id::Arith_RParen) {
    p_die(S_nfD, this->cur_token);
  }
  this->_SetNext(lex_mode_e::ShCommand);
  node = command::ForExpr::CreateNull();
  node->init = init_node;
  node->cond = cond_node;
  node->update = update_node;
  return node;
}

syntax_asdl::word_part_t* WordParser::_ReadArrayLiteral() {
  syntax_asdl::Token* left_token = nullptr;
  syntax_asdl::Token* right_token = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  List<syntax_asdl::CompoundWord*>* words = nullptr;
  bool done;
  syntax_asdl::word_t* w = nullptr;
  syntax_asdl::Token* tok = nullptr;
  List<syntax_asdl::InitializerWord_t*>* initializer_words = nullptr;
  syntax_asdl::AssocPair* pair = nullptr;
  syntax_asdl::word_t* w2 = nullptr;
  syntax_asdl::word_t* w3 = nullptr;
  StackRoot _root0(&left_token);
  StackRoot _root1(&right_token);
  StackRoot _root2(&w_parser);
  StackRoot _root3(&words);
  StackRoot _root4(&w);
  StackRoot _root5(&tok);
  StackRoot _root6(&initializer_words);
  StackRoot _root7(&pair);
  StackRoot _root8(&w2);
  StackRoot _root9(&w3);

  this->_SetNext(lex_mode_e::ShCommand);
  this->_GetToken();
  if (this->cur_token->id != Id::Op_LParen) {
    p_die(S_oCF, this->cur_token);
  }
  left_token = this->cur_token;
  right_token = nullptr;
  w_parser = this->parse_ctx->MakeWordParser(this->lexer, this->line_reader);
  words = Alloc<List<syntax_asdl::CompoundWord*>>();
  done = false;
  while (!done) {
    w = w_parser->ReadWord(lex_mode_e::ShCommand);
    switch (w->tag()) {
      case word_e::Operator: {
        tok = static_cast<Token*>(w);
        if (tok->id == Id::Right_Initializer) {
          right_token = tok;
          done = true;
        }
        else {
          if (tok->id == Id::Op_Newline) {
            continue;
          }
          else {
            p_die(S_Ayd, Alloc<loc::Word>(w));
          }
        }
      }
        break;
      case word_e::Compound: {
        words->append(static_cast<CompoundWord*>(w));
      }
        break;
      default: {
        assert(0);  // AssertionError
      }
    }
  }
  initializer_words = Alloc<List<syntax_asdl::InitializerWord_t*>>();
  for (ListIter<syntax_asdl::CompoundWord*> it(words); !it.Done(); it.Next()) {
    syntax_asdl::CompoundWord* w = it.Value();
    StackRoot _for(&w  );
    pair = word_::DetectAssocPair(w);
    if (pair != nullptr) {
      word_::TildeDetectAssign(pair->value);
      initializer_words->append(pair);
    }
    else {
      w2 = braces::BraceDetect(w);
      if (w2 == nullptr) {
        w2 = w;
      }
      w3 = word_::TildeDetect(w2);
      if (w3 == nullptr) {
        w3 = w2;
      }
      initializer_words->append(Alloc<InitializerWord::ArrayWord>(w3));
    }
  }
  return Alloc<word_part::InitializerLiteral>(left_token, initializer_words, right_token);
}

syntax_asdl::ArgList* WordParser::ParseProcCallArgs(int start_symbol) {
  syntax_asdl::ArgList* arg_list = nullptr;
  StackRoot _root0(&arg_list);

  this->lexer->MaybeUnreadOne();
  arg_list = ArgList::CreateNull(true);
  arg_list->left = this->cur_token;
  this->parse_ctx->ParseProcCallArgs(this->lexer, arg_list, start_symbol);
  return arg_list;
}

bool WordParser::_MaybeReadWordPart(bool is_first, types_asdl::lex_mode_t lex_mode, List<syntax_asdl::word_part_t*>* parts) {
  bool done;
  syntax_asdl::Token* tok = nullptr;
  BigStr* ch = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  int next_id;
  syntax_asdl::word_part_t* part2 = nullptr;
  syntax_asdl::Token* splice_tok = nullptr;
  StackRoot _root0(&parts);
  StackRoot _root1(&tok);
  StackRoot _root2(&ch);
  StackRoot _root3(&part);
  StackRoot _root4(&part2);
  StackRoot _root5(&splice_tok);

  done = false;
  if (this->token_type == Id::Lit_EscapedChar) {
    tok = this->cur_token;
    ch = lexer::TokenSliceLeft(tok, 1);
    if (!this->parse_opts->parse_backslash()) {
      if (!pyutil::IsValidCharEscape(ch)) {
        p_die(S_dEh, this->cur_token);
      }
    }
    part = Alloc<word_part::EscapedLiteral>(this->cur_token, ch);
  }
  else {
    part = this->cur_token;
  }
  if ((is_first and this->token_type == Id::Lit_VarLike)) {
    parts->append(part);
    next_id = this->lexer->LookPastSpace(lex_mode);
    if (next_id == Id::Op_LParen) {
      this->lexer->PushHint(Id::Op_RParen, Id::Right_Initializer);
      part2 = this->_ReadArrayLiteral();
      parts->append(part2);
      this->_SetNext(lex_mode);
      this->_GetToken();
      if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
        p_die(S_bbn, this->cur_token);
      }
      done = true;
    }
  }
  else {
    if ((is_first and (this->parse_opts->parse_at() and this->token_type == Id::Lit_Splice))) {
      splice_tok = this->cur_token;
      part2 = Alloc<word_part::Splice>(splice_tok, lexer::TokenSliceLeft(splice_tok, 1));
      parts->append(part2);
      this->_SetNext(lex_mode);
      this->_GetToken();
      if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
        p_die(S_evz, this->cur_token);
      }
      done = true;
    }
    else {
      if ((is_first and (this->parse_opts->parse_at() and this->token_type == Id::Lit_AtLBracket))) {
        part2 = this->_ReadExprSub(lex_mode_e::DQ);
        parts->append(part2);
        this->_SetNext(lex_mode);
        this->_GetToken();
        if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
          p_die(S_AAk, this->cur_token);
        }
        done = true;
      }
      else {
        if ((is_first and (this->parse_opts->parse_at() and this->token_type == Id::Lit_AtLBraceDot))) {
          p_die(S_rsr, this->cur_token);
        }
        else {
          if ((is_first and (this->parse_opts->parse_at_all() and this->token_type == Id::Lit_At))) {
            p_die(S_oFq, this->cur_token);
          }
          else {
            parts->append(part);
          }
        }
      }
    }
  }
  return done;
}

syntax_asdl::CompoundWord* WordParser::_ReadCompoundWord(types_asdl::lex_mode_t lex_mode) {
  return this->_ReadCompoundWord3(lex_mode, Id::Undefined_Tok, true);
}

syntax_asdl::CompoundWord* WordParser::_ReadCompoundWord3(types_asdl::lex_mode_t lex_mode, int eof_type, bool empty_ok) {
  syntax_asdl::CompoundWord* w = nullptr;
  int num_parts;
  int brace_count;
  bool done;
  syntax_asdl::BoolParamBox* is_triple_quoted = nullptr;
  bool allow_done;
  BigStr* next_byte = nullptr;
  syntax_asdl::Token* vsub_token = nullptr;
  syntax_asdl::word_part_t* part = nullptr;
  syntax_asdl::CommandSub* cs_part = nullptr;
  bool try_triple_quote;
  StackRoot _root0(&w);
  StackRoot _root1(&is_triple_quoted);
  StackRoot _root2(&next_byte);
  StackRoot _root3(&vsub_token);
  StackRoot _root4(&part);
  StackRoot _root5(&cs_part);

  w = Alloc<CompoundWord>(Alloc<List<syntax_asdl::word_part_t*>>());
  num_parts = 0;
  brace_count = 0;
  done = false;
  is_triple_quoted = nullptr;
  while (!done) {
    this->_GetToken();
    allow_done = (empty_ok or num_parts != 0);
    if ((allow_done and this->token_type == eof_type)) {
      done = true;
    }
    else {
      if ((this->token_kind == Kind::Lit || this->token_kind == Kind::History || this->token_kind == Kind::KW || this->token_kind == Kind::ControlFlow || this->token_kind == Kind::BoolUnary || this->token_kind == Kind::BoolBinary)) {
        if (this->token_type == Id::Lit_LBrace) {
          brace_count += 1;
        }
        else {
          if (this->token_type == Id::Lit_RBrace) {
            brace_count -= 1;
          }
          else {
            if (this->token_type == Id::Lit_Dollar) {
              if (!this->parse_opts->parse_dollar()) {
                if ((num_parts == 0 and lex_mode == lex_mode_e::ShCommand)) {
                  next_byte = this->lexer->ByteLookAhead();
                  if (str_equals(next_byte, S_ckc)) {
                    ;  // pass
                  }
                }
                p_die(S_oex, this->cur_token);
              }
            }
          }
        }
        done = this->_MaybeReadWordPart(num_parts == 0, lex_mode, w->parts);
      }
      else {
        if (this->token_kind == Kind::VSub) {
          vsub_token = this->cur_token;
          part = Alloc<SimpleVarSub>(vsub_token);
          w->parts->append(part);
        }
        else {
          if (this->token_kind == Kind::ExtGlob) {
            if ((this->parse_opts->parse_at() and (this->token_type == Id::ExtGlob_At and num_parts == 0))) {
              cs_part = this->_ReadCommandSub(Id::Left_AtParen, false);
              cs_part->left_token->id = Id::Left_AtParen;
              part = cs_part;
              this->_GetToken();
              if (!list_contains(KINDS_THAT_END_WORDS, this->token_kind)) {
                p_die(S_rip, this->cur_token);
              }
              done = true;
            }
            else {
              if (HAVE_FNM_EXTMATCH == 0) {
                p_die(S_eez, this->cur_token);
              }
              part = this->_ReadExtGlob();
            }
            w->parts->append(part);
          }
          else {
            if (this->token_kind == Kind::BashRegex) {
              if (this->token_type == Id::BashRegex_LParen) {
                part = this->_ReadBashRegexGroup();
                w->parts->append(part);
              }
              else {
                p_die(S_qDr, this->cur_token);
              }
            }
            else {
              if (this->token_kind == Kind::Left) {
                try_triple_quote = (this->parse_opts->parse_triple_quote() and (lex_mode == lex_mode_e::ShCommand and num_parts == 0));
                if (try_triple_quote) {
                  is_triple_quoted = Alloc<BoolParamBox>(false);
                }
                part = this->_ReadUnquotedLeftParts(is_triple_quoted);
                w->parts->append(part);
              }
              else {
                if (this->token_kind == Kind::Right) {
                  if (this->token_type == Id::Right_DoubleQuote) {
                    ;  // pass
                  }
                  else {
                    if (this->token_type == Id::Right_Subshell) {
                      if (this->lexer->MaybeUnreadOne()) {
                        this->lexer->PushHint(Id::Op_RParen, Id::Right_Subshell);
                        this->_SetNext(lex_mode);
                      }
                      done = true;
                    }
                    else {
                      done = true;
                    }
                  }
                }
                else {
                  if (this->token_kind == Kind::Ignored) {
                    done = true;
                  }
                  else {
                    if ((this->token_type == Id::Op_RParen || this->token_type == Id::Eof_RParen)) {
                      if (this->lexer->MaybeUnreadOne()) {
                        if (this->token_type == Id::Eof_RParen) {
                          this->lexer->PushHint(Id::Op_RParen, Id::Eof_RParen);
                        }
                        this->_SetNext(lex_mode);
                      }
                    }
                    done = true;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!done) {
      this->_SetNext(lex_mode);
      num_parts += 1;
    }
  }
  if ((this->parse_opts->parse_brace() and (num_parts > 1 and brace_count != 0))) {
    p_die(S_tvz, Alloc<loc::Word>(w));
  }
  if ((is_triple_quoted and (is_triple_quoted->b and num_parts > 1))) {
    p_die(S_imw, Alloc<loc::WordPart>(w->parts->at(-1)));
  }
  if ((!this->parse_opts->parse_word_join() and !_IsValidYshWord(w))) {
    p_die(S_yzg, Alloc<loc::WordPart>(part));
  }
  return w;
}

syntax_asdl::word_t* WordParser::_ReadArithWord() {
  this->_GetToken();
  if (this->token_kind == Kind::Unknown) {
    p_die(StrFormat("Unexpected token while parsing arithmetic: %r", lexer::TokenVal(this->cur_token)), this->cur_token);
  }
  else {
    if (this->token_kind == Kind::Eof) {
      return this->cur_token;
    }
    else {
      if (this->token_kind == Kind::Ignored) {
        this->_SetNext(lex_mode_e::Arith);
        return nullptr;
      }
      else {
        if ((this->token_kind == Kind::Arith || this->token_kind == Kind::Right)) {
          this->_SetNext(lex_mode_e::Arith);
          return this->cur_token;
        }
        else {
          if ((this->token_kind == Kind::Lit || this->token_kind == Kind::Left || this->token_kind == Kind::VSub)) {
            return this->_ReadCompoundWord(lex_mode_e::Arith);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
}

syntax_asdl::word_t* WordParser::_ReadWord(types_asdl::lex_mode_t word_mode) {
  types_asdl::lex_mode_t lex_mode;
  syntax_asdl::Token* bracket_word = nullptr;
  syntax_asdl::Token* tok = nullptr;
  int left_id;
  StackRoot _root0(&bracket_word);
  StackRoot _root1(&tok);

  if (word_mode == lex_mode_e::ShCommandFakeBrack) {
    lex_mode = lex_mode_e::ShCommand;
  }
  else {
    lex_mode = word_mode;
  }
  this->_GetToken();
  if (this->token_kind == Kind::Eof) {
    return this->cur_token;
  }
  else {
    if ((this->token_kind == Kind::Op || this->token_kind == Kind::Redir || this->token_kind == Kind::Arith)) {
      this->_SetNext(lex_mode);
      if (this->token_type == Id::Op_Newline) {
        if (this->multiline) {
          if (this->newline_state > 1) {
            p_die(S_gba, this->cur_token);
          }
          return nullptr;
        }
        if (this->returned_newline) {
          return nullptr;
        }
      }
      return this->cur_token;
    }
    else {
      if (this->token_kind == Kind::Right) {
        if ((this->token_type != Id::Right_Subshell && this->token_type != Id::Right_ShFunction && this->token_type != Id::Right_CasePat && this->token_type != Id::Right_Initializer)) {
          assert(0);  // AssertionError
        }
        this->_SetNext(lex_mode);
        return this->cur_token;
      }
      else {
        if ((this->token_kind == Kind::Ignored || this->token_kind == Kind::WS)) {
          this->_SetNext(lex_mode);
          return nullptr;
        }
        else {
          if ((word_mode == lex_mode_e::ShCommandFakeBrack and (this->parse_opts->parse_bracket() and this->token_type == Id::Lit_LBracket))) {
            bracket_word = this->cur_token;
            bracket_word->id = Id::Op_LBracket;
            this->_SetNext(lex_mode);
            return bracket_word;
          }
          if (this->token_type == Id::Lit_Pound) {
            this->_SetNext(lex_mode_e::Comment);
            this->_GetToken();
            return nullptr;
          }
          else {
            if (this->token_type == Id::Lit_TPound) {
              this->_SetNext(lex_mode_e::Comment);
              this->_GetToken();
              if ((this->token_type == Id::Ignored_Comment and this->emit_doc_token)) {
                return this->cur_token;
              }
              return nullptr;
            }
            else {
              if ((this->token_type == Id::Lit_Chars and this->lexer->LookAheadOne(lex_mode_e::ShCommand) == Id::Left_SingleQuote)) {
                tok = this->cur_token;
                if (this->parse_opts->parse_ysh_string()) {
                  if (lexer::TokenEquals(tok, S_nAr)) {
                    left_id = Id::Left_RSingleQuote;
                  }
                  else {
                    if (lexer::TokenEquals(tok, S_rsz)) {
                      left_id = Id::Left_USingleQuote;
                    }
                    else {
                      if (lexer::TokenEquals(tok, S_jFv)) {
                        left_id = Id::Left_BSingleQuote;
                      }
                      else {
                        left_id = Id::Undefined_Tok;
                      }
                    }
                  }
                  if (left_id != Id::Undefined_Tok) {
                    this->_SetNext(lex_mode_e::ShCommand);
                    this->_GetToken();
                    return this->_ReadYshSingleQuoted(left_id);
                  }
                }
              }
              return this->_ReadCompoundWord(lex_mode);
            }
          }
        }
      }
    }
  }
}

syntax_asdl::BracedVarSub* WordParser::ParseVarRef() {
  syntax_asdl::BracedVarSub* part = nullptr;
  StackRoot _root0(&part);

  this->_SetNext(lex_mode_e::VSub_1);
  this->_GetToken();
  if (this->token_kind != Kind::VSub) {
    p_die(S_smu, this->cur_token);
  }
  part = this->_ParseVarOf();
  part->left = part->name_tok;
  part->right = part->name_tok;
  this->_GetToken();
  if (this->token_type != Id::Eof_Real) {
    p_die(S_txD, this->cur_token);
  }
  return part;
}

int WordParser::LookPastSpace() {
  int id_;
  if (this->cur_token->id == Id::WS_Space) {
    id_ = this->lexer->LookPastSpace(lex_mode_e::ShCommand);
  }
  else {
    id_ = this->cur_token->id;
  }
  return id_;
}

bool WordParser::LookAheadFuncParens() {
  if (this->cur_token->id == Id::Op_LParen) {
    return this->lexer->LookAheadFuncParens(1);
  }
  else {
    if (this->cur_token->id == Id::WS_Space) {
      return this->lexer->LookAheadFuncParens(0);
    }
    else {
      return false;
    }
  }
}

syntax_asdl::word_t* WordParser::ReadWord(types_asdl::lex_mode_t word_mode) {
  syntax_asdl::word_t* w = nullptr;
  StackRoot _root0(&w);

  if (this->buffered_word) {
    w = this->buffered_word;
    this->buffered_word = nullptr;
  }
  else {
    while (true) {
      w = this->_ReadWord(word_mode);
      if (w != nullptr) {
        break;
      }
    }
  }
  this->returned_newline = word_::CommandId(w) == Id::Op_Newline;
  return w;
}

syntax_asdl::word_t* WordParser::ReadArithWord() {
  syntax_asdl::word_t* w = nullptr;
  StackRoot _root0(&w);

  while (true) {
    w = this->_ReadArithWord();
    if (w != nullptr) {
      break;
    }
  }
  return w;
}

void WordParser::ReadHereDocBody(List<syntax_asdl::word_part_t*>* parts) {
  StackRoot _root0(&parts);

  this->_ReadLikeDQ(nullptr, false, parts);
}

syntax_asdl::CompoundWord* WordParser::ReadForPlugin() {
  syntax_asdl::CompoundWord* w = nullptr;
  StackRoot _root0(&w);

  w = Alloc<CompoundWord>(Alloc<List<syntax_asdl::word_part_t*>>());
  this->_ReadLikeDQ(nullptr, false, w->parts);
  return w;
}

void WordParser::EmitDocToken(bool b) {
  this->emit_doc_token = b;
}

void WordParser::Multiline(bool b) {
  this->multiline = b;
}

}  // define namespace word_parse

namespace parse {  // define

using pnode::PNode;
using pnode::PNodeAllocator;
int NT_OFFSET = 256;

ParseError::ParseError(BigStr* msg, int type_, syntax_asdl::Token* tok) {
  this->msg = msg;
  this->type = type_;
  this->tok = tok;
}

_StackItem::_StackItem(Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* dfa, int state, pnode::PNode* node) {
  this->dfa = dfa;
  this->state = state;
  this->node = node;
}

Parser::Parser(grammar::Grammar* grammar) {
  this->grammar = grammar;
  this->rootnode = nullptr;
  this->stack = Alloc<List<parse::_StackItem*>>();
  this->pnode_alloc = nullptr;
}

void Parser::setup(int start, pnode::PNodeAllocator* pnode_alloc) {
  pnode::PNode* newnode = nullptr;
  StackRoot _root0(&pnode_alloc);

  this->pnode_alloc = pnode_alloc;
  newnode = this->pnode_alloc->NewPNode(start, nullptr);
  this->stack = NewList<parse::_StackItem*>(std::initializer_list<parse::_StackItem*>{Alloc<_StackItem>(this->grammar->dfas->at(start), 0, newnode)});
  this->rootnode = nullptr;
}

bool Parser::addtoken(int typ, syntax_asdl::Token* opaque, int ilabel) {
  parse::_StackItem* top = nullptr;
  List<List<Tuple2<int, int>*>*>* states = nullptr;
  int state;
  List<Tuple2<int, int>*>* arcs = nullptr;
  bool found;
  int t;
  int s0;
  int s1;
  Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* itsdfa = nullptr;
  Dict<int, int>* itsfirst = nullptr;
  bool found2;
  StackRoot _root0(&opaque);
  StackRoot _root1(&top);
  StackRoot _root2(&states);
  StackRoot _root3(&arcs);
  StackRoot _root4(&itsdfa);
  StackRoot _root5(&itsfirst);

  while (true) {
    top = this->stack->at(-1);
    Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* tup0 = top->dfa;
    states = tup0->at0();
    state = top->state;
    arcs = states->at(state);
    found = false;
    for (ListIter<Tuple2<int, int>*> it(arcs); !it.Done(); it.Next()) {
      Tuple2<int, int>* tup1 = it.Value();
      int ilab = tup1->at0();
      int newstate = tup1->at1();
      t = this->grammar->labels->at(ilab);
      if (ilabel == ilab) {
        this->shift(typ, opaque, newstate);
        state = newstate;
        while (true) {
          if (len(states->at(state)) != 1) {
            break;
          }
          Tuple2<int, int>* tup2 = states->at(state)->at(0);
          s0 = tup2->at0();
          s1 = tup2->at1();
          if ((s0 != 0 or s1 != state)) {
            break;
          }
          this->pop();
          if (len(this->stack) == 0) {
            return true;
          }
          top = this->stack->at(-1);
          Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* tup3 = top->dfa;
          states = tup3->at0();
          state = top->state;
        }
        return false;
      }
      else {
        if (t >= NT_OFFSET) {
          itsdfa = this->grammar->dfas->at(t);
          Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* tup4 = itsdfa;
          itsfirst = tup4->at1();
          if (dict_contains(itsfirst, ilabel)) {
            this->push(t, opaque, this->grammar->dfas->at(t), newstate);
            found = true;
            break;
          }
        }
      }
    }
    if (!found) {
      found2 = false;
      for (ListIter<Tuple2<int, int>*> it(arcs); !it.Done(); it.Next()) {
        Tuple2<int, int>* tup5 = it.Value();
        int left = tup5->at0();
        int right = tup5->at1();
        if ((left == 0 and right == state)) {
          this->pop();
          if (len(this->stack) == 0) {
            throw Alloc<ParseError>(S_vwh, typ, opaque);
          }
          found2 = true;
        }
      }
      if (!found2) {
        throw Alloc<ParseError>(S_trA, typ, opaque);
      }
    }
  }
}

void Parser::shift(int typ, syntax_asdl::Token* opaque, int newstate) {
  parse::_StackItem* top = nullptr;
  pnode::PNode* newnode = nullptr;
  StackRoot _root0(&opaque);
  StackRoot _root1(&top);

  top = this->stack->at(-1);
  newnode = this->pnode_alloc->NewPNode(typ, opaque);
  top->node->AddChild(newnode);
  this->stack->at(-1)->state = newstate;
}

void Parser::push(int typ, syntax_asdl::Token* opaque, Tuple2<List<List<Tuple2<int, int>*>*>*, Dict<int, int>*>* newdfa, int newstate) {
  parse::_StackItem* top = nullptr;
  pnode::PNode* newnode = nullptr;
  StackRoot _root0(&opaque);
  StackRoot _root1(&newdfa);
  StackRoot _root2(&top);

  top = this->stack->at(-1);
  newnode = this->pnode_alloc->NewPNode(typ, opaque);
  this->stack->at(-1)->state = newstate;
  this->stack->append(Alloc<_StackItem>(newdfa, 0, newnode));
}

void Parser::pop() {
  parse::_StackItem* top = nullptr;
  pnode::PNode* newnode = nullptr;
  parse::_StackItem* top2 = nullptr;
  StackRoot _root0(&top);
  StackRoot _root1(&top2);

  top = this->stack->pop();
  newnode = top->node;
  if (len(this->stack)) {
    top2 = this->stack->at(-1);
    top2->node->AddChild(newnode);
  }
  else {
    this->rootnode = newnode;
  }
}

}  // define namespace parse

namespace os_path {  // define

BigStr* extsep = S_Aru;
BigStr* sep = S_ckc;

BigStr* join(BigStr* s1, BigStr* s2) {
  StackRoot _root0(&s1);
  StackRoot _root1(&s2);

  if ((s2->startswith(S_ckc) or len(s1) == 0)) {
    return s2;
  }
  if (s1->endswith(S_ckc)) {
    return str_concat(s1, s2);
  }
  return StrFormat("%s/%s", s1, s2);
}

Tuple2<BigStr*, BigStr*> split(BigStr* p) {
  int i;
  BigStr* head = nullptr;
  BigStr* tail = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&head);
  StackRoot _root2(&tail);

  i = (p->rfind(S_ckc) + 1);
  head = p->slice(0, i);
  tail = p->slice(i);
  head = rstrip_slashes(head);
  return Tuple2<BigStr*, BigStr*>(head, tail);
}

Tuple2<BigStr*, BigStr*> _splitext(BigStr* p, BigStr* sep, BigStr* extsep) {
  int sepIndex;
  int dotIndex;
  int filenameIndex;
  StackRoot _root0(&p);
  StackRoot _root1(&sep);
  StackRoot _root2(&extsep);

  sepIndex = p->rfind(sep);
  dotIndex = p->rfind(extsep);
  if (dotIndex > sepIndex) {
    filenameIndex = (sepIndex + 1);
    while (filenameIndex < dotIndex) {
      if (!(str_equals(p->at(filenameIndex), extsep))) {
        return Tuple2<BigStr*, BigStr*>(p->slice(0, dotIndex), p->slice(dotIndex));
      }
      filenameIndex += 1;
    }
  }
  return Tuple2<BigStr*, BigStr*>(p, S_Aoo);
}

Tuple2<BigStr*, BigStr*> splitext(BigStr* p) {
  StackRoot _root0(&p);

  return _splitext(p, sep, extsep);
}

BigStr* basename(BigStr* p) {
  int i;
  StackRoot _root0(&p);

  i = (p->rfind(S_ckc) + 1);
  return p->slice(i);
}

BigStr* dirname(BigStr* p) {
  int i;
  BigStr* head = nullptr;
  StackRoot _root0(&p);
  StackRoot _root1(&head);

  i = (p->rfind(S_ckc) + 1);
  head = p->slice(0, i);
  head = rstrip_slashes(head);
  return head;
}

BigStr* normpath(BigStr* path) {
  BigStr* slash = nullptr;
  BigStr* dot = nullptr;
  int initial_slashes;
  List<BigStr*>* comps = nullptr;
  List<BigStr*>* new_comps = nullptr;
  StackRoot _root0(&path);
  StackRoot _root1(&slash);
  StackRoot _root2(&dot);
  StackRoot _root3(&comps);
  StackRoot _root4(&new_comps);

  slash = S_ckc;
  dot = S_Aru;
  if (str_equals(path, S_Aoo)) {
    return dot;
  }
  initial_slashes = path->startswith(S_ckc);
  if ((initial_slashes and (path->startswith(S_lFp) and !path->startswith(S_gEs)))) {
    initial_slashes = 2;
  }
  comps = path->split(S_ckc);
  new_comps = Alloc<List<BigStr*>>();
  for (ListIter<BigStr*> it(comps); !it.Done(); it.Next()) {
    BigStr* comp = it.Value();
    StackRoot _for(&comp  );
    if ((len(comp) == 0 or str_equals(comp, S_Aru))) {
      continue;
    }
    if ((!(str_equals(comp, S_Dmc)) or ((initial_slashes == 0 and len(new_comps) == 0) or (len(new_comps) and str_equals(new_comps->at(-1), S_Dmc))))) {
      new_comps->append(comp);
    }
    else {
      if (len(new_comps)) {
        new_comps->pop();
      }
    }
  }
  comps = new_comps;
  path = slash->join(comps);
  if (initial_slashes) {
    path = str_concat(str_repeat(slash, initial_slashes), path);
  }
  return len(path) ? path : dot;
}

bool isabs(BigStr* s) {
  StackRoot _root0(&s);

  return s->startswith(S_ckc);
}

BigStr* abspath(BigStr* path) {
  BigStr* cwd = nullptr;
  StackRoot _root0(&path);
  StackRoot _root1(&cwd);

  if (!isabs(path)) {
    cwd = posix::getcwd();
    path = join(cwd, path);
  }
  return normpath(path);
}

}  // define namespace os_path

namespace expr_parse {  // define

using syntax_asdl::loc;
using syntax_asdl::Token;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::SingleQuoted;
using syntax_asdl::CommandSub;
using syntax_asdl::YshArrayLiteral;
using syntax_asdl::CompoundWord;
using syntax_asdl::word_part_t;
using syntax_asdl::word_e;
using id_kind_asdl::Id;
using id_kind_asdl::Kind;
using id_kind_asdl::Id_str;
using types_asdl::lex_mode_e;
using error::p_die;
using pnode::PNodeAllocator;

int _Classify(grammar::Grammar* gr, syntax_asdl::Token* tok) {
  int id_;
  BigStr* type_str = nullptr;
  StackRoot _root0(&gr);
  StackRoot _root1(&tok);
  StackRoot _root2(&type_str);

  id_ = tok->id;
  if (dict_contains(gr->tokens, id_)) {
    return gr->tokens->at(id_);
  }
  if (id_ == Id::Unknown_DEqual) {
    p_die(S_qbb, tok);
  }
  if (id_ == Id::Unknown_DAmp) {
    p_die(S_hkt, tok);
  }
  if (id_ == Id::Unknown_DPipe) {
    p_die(S_yww, tok);
  }
  if (id_ == Id::Unknown_DDot) {
    p_die(S_bkb, tok);
  }
  if (id_ == Id::Unknown_Tok) {
    type_str = S_Aoo;
  }
  else {
    type_str = StrFormat(" (%s)", ui::PrettyId(tok->id));
  }
  p_die(StrFormat("Unexpected token in expression mode%s", type_str), tok);
}
GLOBAL_DICT(_OTHER_BALANCE, int, int, 4, {Id::Op_LParen COMMA Id::Op_RParen COMMA Id::Op_LBracket COMMA Id::Op_RBracket}, {1 COMMA -1 COMMA 1 COMMA -1});

syntax_asdl::Token* _PushYshTokens(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr, parse::Parser* p, lexer::Lexer* lex) {
  syntax_asdl::Token* last_token = nullptr;
  bool prev_was_newline;
  int balance;
  syntax_asdl::Token* tok = nullptr;
  int ilabel;
  syntax_asdl::Token* left_tok = nullptr;
  reader::DisallowedLineReader* line_reader = nullptr;
  word_parse::WordParser* w_parser = nullptr;
  List<syntax_asdl::CompoundWord*>* words = nullptr;
  syntax_asdl::Token* close_tok = nullptr;
  bool done;
  syntax_asdl::word_t* w = nullptr;
  List<syntax_asdl::word_t*>* words2 = nullptr;
  List<syntax_asdl::word_t*>* words3 = nullptr;
  int typ;
  syntax_asdl::YshArrayLiteral* lit_part = nullptr;
  syntax_asdl::Token* opaque = nullptr;
  syntax_asdl::Token* left_token = nullptr;
  cmd_parse::CommandParser* c_parser = nullptr;
  syntax_asdl::command_t* node = nullptr;
  syntax_asdl::Token* right_token = nullptr;
  syntax_asdl::CommandSub* cs_part = nullptr;
  List<syntax_asdl::word_part_t*>* parts = nullptr;
  syntax_asdl::DoubleQuoted* expr_dq_part = nullptr;
  syntax_asdl::BracedVarSub* part = nullptr;
  types_asdl::lex_mode_t sq_mode;
  List<syntax_asdl::Token*>* tokens = nullptr;
  BigStr* sval = nullptr;
  syntax_asdl::SingleQuoted* sq_part = nullptr;
  StackRoot _root0(&parse_ctx);
  StackRoot _root1(&gr);
  StackRoot _root2(&p);
  StackRoot _root3(&lex);
  StackRoot _root4(&last_token);
  StackRoot _root5(&tok);
  StackRoot _root6(&left_tok);
  StackRoot _root7(&line_reader);
  StackRoot _root8(&w_parser);
  StackRoot _root9(&words);
  StackRoot _root10(&close_tok);
  StackRoot _root11(&w);
  StackRoot _root12(&words2);
  StackRoot _root13(&words3);
  StackRoot _root14(&lit_part);
  StackRoot _root15(&opaque);
  StackRoot _root16(&left_token);
  StackRoot _root17(&c_parser);
  StackRoot _root18(&node);
  StackRoot _root19(&right_token);
  StackRoot _root20(&cs_part);
  StackRoot _root21(&parts);
  StackRoot _root22(&expr_dq_part);
  StackRoot _root23(&part);
  StackRoot _root24(&tokens);
  StackRoot _root25(&sval);
  StackRoot _root26(&sq_part);

  last_token = nullptr;
  prev_was_newline = false;
  balance = 0;
  while (true) {
    if (last_token) {
      tok = last_token;
      last_token = nullptr;
    }
    else {
      tok = lex->Read(lex_mode_e::Expr);
    }
    if (consts::GetKind(tok->id) == Kind::Ignored) {
      continue;
    }
    if (tok->id == Id::Op_Newline) {
      if (balance > 0) {
        continue;
      }
      if (prev_was_newline) {
        continue;
      }
      prev_was_newline = true;
    }
    else {
      prev_was_newline = false;
    }
    balance += _OTHER_BALANCE->get(tok->id, 0);
    if (tok->id == Id::Op_LParen) {
      lex->PushHint(Id::Op_RParen, Id::Op_RParen);
    }
    ilabel = _Classify(gr, tok);
    if (p->addtoken(tok->id, tok, ilabel)) {
      return tok;
    }
    if ((tok->id == Id::Left_ColonPipe || tok->id == Id::Left_PercentParen)) {
      left_tok = tok;
      if (tok->id == Id::Left_PercentParen) {
        lex->PushHint(Id::Op_RParen, Id::Right_Initializer);
      }
      line_reader = Alloc<reader::DisallowedLineReader>(parse_ctx->arena, tok);
      w_parser = parse_ctx->MakeWordParser(lex, line_reader);
      words = Alloc<List<syntax_asdl::CompoundWord*>>();
      close_tok = nullptr;
      done = false;
      while (!done) {
        w = w_parser->ReadWord(lex_mode_e::ShCommand);
        switch (w->tag()) {
          case word_e::Operator: {
            tok = reinterpret_cast<Token*>(w);
            if (tok->id == Id::Right_Initializer) {
              if (left_tok->id != Id::Left_PercentParen) {
                p_die(S_ine, left_tok);
              }
              close_tok = tok;
              done = true;
            }
            else {
              if (tok->id == Id::Op_Pipe) {
                if (left_tok->id != Id::Left_ColonPipe) {
                  p_die(S_ine, left_tok);
                }
                close_tok = tok;
                done = true;
              }
              else {
                if (tok->id == Id::Op_Newline) {
                  continue;
                }
                else {
                  p_die(S_Ayd, Alloc<loc::Word>(w));
                }
              }
            }
          }
            break;
          case word_e::Compound: {
            words->append(static_cast<CompoundWord*>(w));
          }
            break;
          default: {
            assert(0);  // AssertionError
          }
        }
      }
      words2 = braces::BraceDetectAll(words);
      words3 = word_::TildeDetectAll(words2);
      typ = Id::Expr_CastedDummy;
      lit_part = Alloc<YshArrayLiteral>(left_tok, words3, close_tok);
      opaque = reinterpret_cast<Token*>(lit_part);
      done = p->addtoken(typ, opaque, gr->tokens->at(typ));
      ilabel = _Classify(gr, close_tok);
      done = p->addtoken(tok->id, close_tok, ilabel);
      continue;
    }
    if ((tok->id == Id::Left_DollarParen || tok->id == Id::Left_AtParen || tok->id == Id::Left_CaretParen)) {
      left_token = tok;
      lex->PushHint(Id::Op_RParen, Id::Eof_RParen);
      line_reader = Alloc<reader::DisallowedLineReader>(parse_ctx->arena, tok);
      c_parser = parse_ctx->MakeParserForCommandSub(line_reader, lex, Id::Eof_RParen);
      node = c_parser->ParseCommandSub();
      right_token = c_parser->w_parser->cur_token;
      cs_part = Alloc<CommandSub>(left_token, node, right_token);
      typ = Id::Expr_CastedDummy;
      opaque = reinterpret_cast<Token*>(cs_part);
      done = p->addtoken(typ, opaque, gr->tokens->at(typ));
      ilabel = _Classify(gr, right_token);
      done = p->addtoken(right_token->id, right_token, ilabel);
      continue;
    }
    if ((tok->id == Id::Left_DoubleQuote || tok->id == Id::Left_DollarDoubleQuote || tok->id == Id::Left_TDoubleQuote || tok->id == Id::Left_DollarTDoubleQuote || tok->id == Id::Left_CaretDoubleQuote)) {
      left_token = tok;
      line_reader = Alloc<reader::DisallowedLineReader>(parse_ctx->arena, tok);
      w_parser = parse_ctx->MakeWordParser(lex, line_reader);
      parts = Alloc<List<syntax_asdl::word_part_t*>>();
      last_token = w_parser->ReadDoubleQuoted(left_token, parts);
      expr_dq_part = Alloc<DoubleQuoted>(left_token, parts, last_token);
      typ = Id::Expr_CastedDummy;
      opaque = reinterpret_cast<Token*>(expr_dq_part);
      done = p->addtoken(typ, opaque, gr->tokens->at(typ));
      continue;
    }
    if (tok->id == Id::Left_DollarBrace) {
      left_token = tok;
      line_reader = Alloc<reader::DisallowedLineReader>(parse_ctx->arena, tok);
      w_parser = parse_ctx->MakeWordParser(lex, line_reader);
      Tuple2<syntax_asdl::BracedVarSub*, syntax_asdl::Token*> tup0 = w_parser->ReadBracedVarSub(left_token);
      part = tup0.at0();
      last_token = tup0.at1();
      typ = Id::Expr_CastedDummy;
      opaque = reinterpret_cast<Token*>(part);
      done = p->addtoken(typ, opaque, gr->tokens->at(typ));
      continue;
    }
    if ((tok->id == Id::Left_SingleQuote || tok->id == Id::Left_TSingleQuote || tok->id == Id::Left_RSingleQuote || tok->id == Id::Left_RTSingleQuote || tok->id == Id::Left_USingleQuote || tok->id == Id::Left_UTSingleQuote || tok->id == Id::Left_BSingleQuote || tok->id == Id::Left_BTSingleQuote || tok->id == Id::Left_DollarSingleQuote)) {
      if (tok->id == Id::Left_DollarSingleQuote) {
        sq_mode = lex_mode_e::SQ_C;
      }
      else {
        if ((tok->id == Id::Left_USingleQuote || tok->id == Id::Left_UTSingleQuote || tok->id == Id::Left_BSingleQuote || tok->id == Id::Left_BTSingleQuote)) {
          sq_mode = lex_mode_e::J8_Str;
        }
        else {
          sq_mode = lex_mode_e::SQ_Raw;
        }
      }
      left_token = tok;
      line_reader = Alloc<reader::DisallowedLineReader>(parse_ctx->arena, tok);
      w_parser = parse_ctx->MakeWordParser(lex, line_reader);
      tokens = Alloc<List<syntax_asdl::Token*>>();
      last_token = w_parser->ReadSingleQuoted(sq_mode, left_token, tokens, true);
      sval = word_compile::EvalSingleQuoted(left_token->id, tokens);
      sq_part = Alloc<SingleQuoted>(left_token, sval, last_token);
      typ = Id::Expr_CastedDummy;
      opaque = reinterpret_cast<Token*>(sq_part);
      done = p->addtoken(typ, opaque, gr->tokens->at(typ));
      continue;
    }
  }
}

ExprParser::ExprParser(parse_lib::ParseContext* parse_ctx, grammar::Grammar* gr) {
  this->parse_ctx = parse_ctx;
  this->gr = gr;
  this->push_parser = Alloc<parse::Parser>(gr);
  this->pnode_alloc = nullptr;
}

Tuple2<pnode::PNode*, syntax_asdl::Token*> ExprParser::Parse(lexer::Lexer* lexer, int start_symbol) {
  syntax_asdl::Token* last_token = nullptr;
  StackRoot _root0(&lexer);
  StackRoot _root1(&last_token);

  this->push_parser->setup(start_symbol, this->pnode_alloc);
  try {
    last_token = _PushYshTokens(this->parse_ctx, this->gr, this->push_parser, lexer);
  }
  catch (parse::ParseError* e) {
    p_die(StrFormat("Syntax error in expression (near %s)", ui::PrettyId(e->tok->id)), e->tok);
  }
  return Tuple2<pnode::PNode*, syntax_asdl::Token*>(this->push_parser->rootnode, last_token);
}

ctx_PNodeAllocator::ctx_PNodeAllocator(expr_parse::ExprParser* ep) {
  gHeap.PushRoot(reinterpret_cast<RawObject**>(&(this->expr_parser)));
  this->expr_parser = ep;
  this->expr_parser->pnode_alloc = Alloc<PNodeAllocator>();
}

ctx_PNodeAllocator::~ctx_PNodeAllocator() {
  this->expr_parser->pnode_alloc->Clear();
  this->expr_parser->pnode_alloc = nullptr;
  gHeap.PopRoot();
}

}  // define namespace expr_parse

namespace expr_to_ast {  // define

using id_kind_asdl::Id;
using id_kind_asdl::Id_t;
using id_kind_asdl::Id_str;
using id_kind_asdl::Kind;
using syntax_asdl::Token;
using syntax_asdl::SimpleVarSub;
using syntax_asdl::loc;
using syntax_asdl::loc_t;
using syntax_asdl::DoubleQuoted;
using syntax_asdl::SingleQuoted;
using syntax_asdl::BracedVarSub;
using syntax_asdl::CommandSub;
using syntax_asdl::YshArrayLiteral;
using syntax_asdl::expr;
using syntax_asdl::expr_e;
using syntax_asdl::expr_t;
using syntax_asdl::expr_context_e;
using syntax_asdl::re;
using syntax_asdl::re_t;
using syntax_asdl::re_repeat;
using syntax_asdl::re_repeat_t;
using syntax_asdl::class_literal_term;
using syntax_asdl::class_literal_term_t;
using syntax_asdl::PosixClass;
using syntax_asdl::PerlClass;
using syntax_asdl::NameType;
using syntax_asdl::y_lhs_t;
using syntax_asdl::Comprehension;
using syntax_asdl::Subscript;
using syntax_asdl::Attribute;
using syntax_asdl::proc_sig;
using syntax_asdl::proc_sig_t;
using syntax_asdl::Param;
using syntax_asdl::RestParam;
using syntax_asdl::ParamGroup;
using syntax_asdl::NamedArg;
using syntax_asdl::ArgList;
using syntax_asdl::pat;
using syntax_asdl::pat_t;
using syntax_asdl::TypeExpr;
using syntax_asdl::Func;
using syntax_asdl::Eggex;
using syntax_asdl::EggexFlag;
using syntax_asdl::CharCode;
using syntax_asdl::CharRange;
using syntax_asdl::VarDecl;
using syntax_asdl::Mutation;
using value_asdl::value;
using value_asdl::value_t;
using error::p_die;
GLOBAL_DICT(PERL_CLASSES, BigStr*, BigStr*, 4, {S_Crn COMMA S_pfC COMMA S_Cbp COMMA S_anC}, {S_Crn COMMA S_pfC COMMA S_pfC COMMA S_anC});
GLOBAL_LIST(POSIX_CLASSES, BigStr*, 12, {S_gja COMMA S_mij COMMA S_urB COMMA S_iya COMMA S_EvD COMMA S_Coo COMMA S_nld COMMA S_fgo COMMA S_bdb COMMA S_jji COMMA S_syu COMMA S_dgp});
BigStr* RANGE_POINT_TOO_LONG = S_Fza;
BigStr* POS_ARG_MISPLACED = S_Fpz;
int NT_OFFSET = 256;

Transformer::Transformer(grammar::Grammar* gr) {
  this->number2symbol = gr->number2symbol;
}

syntax_asdl::expr_t* Transformer::_LeftAssoc(pnode::PNode* p_node) {
  int i;
  int n;
  syntax_asdl::expr_t* left = nullptr;
  pnode::PNode* op = nullptr;
  syntax_asdl::expr_t* right = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&right);

  i = 1;
  n = p_node->NumChildren();
  left = this->Expr(p_node->GetChild(0));
  while (i < n) {
    op = p_node->GetChild(i);
    right = this->Expr(p_node->GetChild((i + 1)));
    left = Alloc<expr::Binary>(op->tok, left, right);
    i += 2;
  }
  return left;
}

syntax_asdl::expr_t* Transformer::_Trailer(syntax_asdl::expr_t* base, pnode::PNode* p_trailer) {
  syntax_asdl::Token* tok0 = nullptr;
  int typ0;
  syntax_asdl::Token* lparen = nullptr;
  syntax_asdl::Token* rparen = nullptr;
  syntax_asdl::ArgList* arglist = nullptr;
  pnode::PNode* p = nullptr;
  pnode::PNode* p_args = nullptr;
  int n;
  syntax_asdl::expr_t* subscript = nullptr;
  List<syntax_asdl::expr_t*>* slices = nullptr;
  syntax_asdl::Token* comma_tok = nullptr;
  syntax_asdl::Token* attr = nullptr;
  StackRoot _root0(&base);
  StackRoot _root1(&tok0);
  StackRoot _root2(&lparen);
  StackRoot _root3(&rparen);
  StackRoot _root4(&arglist);
  StackRoot _root5(&subscript);
  StackRoot _root6(&slices);
  StackRoot _root7(&comma_tok);
  StackRoot _root8(&attr);

  tok0 = p_trailer->GetChild(0)->tok;
  typ0 = p_trailer->GetChild(0)->typ;
  if (typ0 == Id::Op_LParen) {
    lparen = tok0;
    rparen = p_trailer->GetChild(-1)->tok;
    arglist = Alloc<ArgList>(lparen, Alloc<List<syntax_asdl::expr_t*>>(), nullptr, Alloc<List<syntax_asdl::NamedArg*>>(), nullptr, nullptr, rparen);
    if (p_trailer->NumChildren() == 2) {
      return Alloc<expr::FuncCall>(base, arglist);
    }
    p = p_trailer->GetChild(1);
    this->_ArgList(p, arglist);
    return Alloc<expr::FuncCall>(base, arglist);
  }
  if (typ0 == Id::Op_LBracket) {
    p_args = p_trailer->GetChild(1);
    n = p_args->NumChildren();
    if (n == 1) {
      subscript = this->_Subscript(p_args->GetChild(0));
    }
    else {
      slices = Alloc<List<syntax_asdl::expr_t*>>();
      for (int i = 0; i < n; i += 2) {
        slices->append(this->_Subscript(p_args->GetChild(i)));
      }
      comma_tok = p_args->GetChild(1)->tok;
      subscript = Alloc<expr::Tuple>(comma_tok, slices, expr_context_e::Store);
    }
    return Alloc<Subscript>(tok0, base, subscript);
  }
  if ((typ0 == Id::Expr_Dot || typ0 == Id::Expr_RArrow || typ0 == Id::Expr_RDArrow)) {
    attr = p_trailer->GetChild(1)->tok;
    return Alloc<Attribute>(base, tok0, attr, lexer::TokenVal(attr), expr_context_e::Store);
  }
  assert(0);  // AssertionError
}

Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> Transformer::_DictPair(pnode::PNode* p_node) {
  int typ;
  syntax_asdl::expr_t* key = nullptr;
  syntax_asdl::expr_t* val = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  int id_;
  value::Str* key_str = nullptr;
  StackRoot _root0(&key);
  StackRoot _root1(&val);
  StackRoot _root2(&tok0);
  StackRoot _root3(&key_str);

  typ = p_node->GetChild(0)->typ;
  if ((typ == grammar_nt::sq_string || typ == grammar_nt::dq_string)) {
    key = this->Expr(p_node->GetChild(0));
    val = this->Expr(p_node->GetChild(2));
    return Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, val);
  }
  tok0 = p_node->GetChild(0)->tok;
  id_ = tok0->id;
  if (id_ == Id::Expr_Name) {
    key_str = Alloc<value::Str>(lexer::TokenVal(tok0));
    key = Alloc<expr::Const>(tok0, key_str);
    if (p_node->NumChildren() >= 3) {
      val = this->Expr(p_node->GetChild(2));
    }
    else {
      val = expr::Implicit;
    }
  }
  if (id_ == Id::Op_LBracket) {
    key = this->Expr(p_node->GetChild(1));
    val = this->Expr(p_node->GetChild(4));
    return Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, val);
  }
  return Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*>(key, val);
}

expr::Dict* Transformer::_Dict(pnode::PNode* parent, pnode::PNode* p_node) {
  List<syntax_asdl::expr_t*>* keys = nullptr;
  List<syntax_asdl::expr_t*>* values = nullptr;
  int n;
  syntax_asdl::expr_t* key = nullptr;
  syntax_asdl::expr_t* val = nullptr;
  StackRoot _root0(&keys);
  StackRoot _root1(&values);
  StackRoot _root2(&key);
  StackRoot _root3(&val);

  if (p_node->typ == Id::Op_RBrace) {
    return Alloc<expr::Dict>(parent->tok, Alloc<List<syntax_asdl::expr_t*>>(), Alloc<List<syntax_asdl::expr_t*>>());
  }
  keys = Alloc<List<syntax_asdl::expr_t*>>();
  values = Alloc<List<syntax_asdl::expr_t*>>();
  n = p_node->NumChildren();
  for (int i = 0; i < n; i += 2) {
    Tuple2<syntax_asdl::expr_t*, syntax_asdl::expr_t*> tup0 = this->_DictPair(p_node->GetChild(i));
    key = tup0.at0();
    val = tup0.at1();
    keys->append(key);
    values->append(val);
  }
  return Alloc<expr::Dict>(parent->tok, keys, values);
}

syntax_asdl::expr_t* Transformer::_Tuple(pnode::PNode* parent) {
  int n;
  List<syntax_asdl::expr_t*>* elts = nullptr;
  pnode::PNode* p_node = nullptr;
  StackRoot _root0(&elts);

  n = parent->NumChildren();
  if (n == 1) {
    return this->Expr(parent->GetChild(0));
  }
  if (n == 2) {
    p_die(S_iFj, parent->GetChild(1)->tok);
  }
  elts = Alloc<List<syntax_asdl::expr_t*>>();
  for (int i = 0; i < n; i += 2) {
    p_node = parent->GetChild(i);
    elts->append(this->Expr(p_node));
  }
  return Alloc<expr::Tuple>(parent->tok, elts, expr_context_e::Store);
}

syntax_asdl::expr_t* Transformer::_TestlistComp(pnode::PNode* parent, pnode::PNode* p_node, int id0) {
  int n;
  pnode::PNode* child0 = nullptr;
  syntax_asdl::expr_t* elt = nullptr;
  syntax_asdl::Comprehension* comp = nullptr;
  List<syntax_asdl::expr_t*>* elts = nullptr;
  pnode::PNode* child = nullptr;
  StackRoot _root0(&elt);
  StackRoot _root1(&comp);
  StackRoot _root2(&elts);

  n = p_node->NumChildren();
  if ((n > 1 and p_node->GetChild(1)->typ == grammar_nt::comp_for)) {
    child0 = p_node->GetChild(0);
    if (child0->typ == grammar_nt::splat_expr) {
      p_die(S_bgA, child0->tok);
    }
    elt = this->Expr(child0);
    comp = this->_CompFor(p_node->GetChild(1));
    if (id0 == Id::Op_LParen) {
      return Alloc<expr::GeneratorExp>(elt, NewList<syntax_asdl::Comprehension*>(std::initializer_list<syntax_asdl::Comprehension*>{comp}));
    }
    if (id0 == Id::Op_LBracket) {
      return Alloc<expr::ListComp>(parent->tok, elt, NewList<syntax_asdl::Comprehension*>(std::initializer_list<syntax_asdl::Comprehension*>{comp}));
    }
    assert(0);  // AssertionError
  }
  if (id0 == Id::Op_LParen) {
    if (n == 1) {
      return this->Expr(p_node->GetChild(0));
    }
    if (p_node->GetChild(1)->typ == Id::Arith_Comma) {
      return this->_Tuple(p_node);
    }
    assert(0);  // AssertionError
  }
  if (id0 == Id::Op_LBracket) {
    elts = Alloc<List<syntax_asdl::expr_t*>>();
    for (int i = 0; i < n; i += 2) {
      child = p_node->GetChild(i);
      if (child->typ == grammar_nt::splat_expr) {
        p_die(S_bgA, child->tok);
      }
      elts->append(this->Expr(child));
    }
    return Alloc<expr::List>(parent->tok, elts, expr_context_e::Store);
  }
  assert(0);  // AssertionError
}

syntax_asdl::expr_t* Transformer::_Atom(pnode::PNode* parent) {
  syntax_asdl::Token* tok = nullptr;
  int id_;
  int n;
  syntax_asdl::expr_t* child = nullptr;
  int i;
  syntax_asdl::Token* name_tok = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&child);
  StackRoot _root2(&name_tok);

  tok = parent->GetChild(0)->tok;
  id_ = tok->id;
  n = parent->NumChildren();
  if (id_ == Id::Op_LParen) {
    if (n == 2) {
      return Alloc<expr::Tuple>(tok, Alloc<List<syntax_asdl::expr_t*>>(), expr_context_e::Store);
    }
    return this->_TestlistComp(parent, parent->GetChild(1), id_);
  }
  if (id_ == Id::Op_LBracket) {
    if (n == 2) {
      return Alloc<expr::List>(tok, Alloc<List<syntax_asdl::expr_t*>>(), expr_context_e::Store);
    }
    return this->_TestlistComp(parent, parent->GetChild(1), id_);
  }
  if (id_ == Id::Left_CaretBracket) {
    child = this->Expr(parent->GetChild(1));
    return Alloc<expr::Literal>(child);
  }
  if (id_ == Id::Op_LBrace) {
    i = 1;
    if (parent->GetChild(i)->typ == Id::Op_Newline) {
      i += 1;
    }
    return this->_Dict(parent, parent->GetChild(i));
  }
  if (id_ == Id::Arith_Amp) {
    n = parent->NumChildren();
    if (n >= 3) {
      p_die(S_ynk, parent->GetChild(2)->tok);
    }
    name_tok = parent->GetChild(1)->tok;
    return Alloc<expr::Place>(name_tok, lexer::TokenVal(name_tok), Alloc<List<syntax_asdl::place_op_t*>>());
  }
  if (id_ == Id::Expr_Func) {
    return Alloc<expr::Lambda>(Alloc<List<syntax_asdl::NameType*>>(), expr::Implicit);
  }
  if (id_ == Id::Expr_DecInt) {
    p_die(S_rBg, parent->GetChild(1)->tok);
  }
  if (id_ == Id::Expr_Float) {
    p_die(S_zxo, parent->GetChild(1)->tok);
  }
  assert(0);  // AssertionError
}

syntax_asdl::NameType* Transformer::_NameType(pnode::PNode* p_node) {
  syntax_asdl::Token* name_tok = nullptr;
  syntax_asdl::TypeExpr* typ = nullptr;
  int n;
  StackRoot _root0(&name_tok);
  StackRoot _root1(&typ);

  name_tok = p_node->GetChild(0)->tok;
  typ = nullptr;
  n = p_node->NumChildren();
  if (n == 2) {
    typ = this->_TypeExpr(p_node->GetChild(1));
  }
  if (n == 3) {
    typ = this->_TypeExpr(p_node->GetChild(2));
  }
  return Alloc<NameType>(name_tok, lexer::TokenVal(name_tok), typ);
}

List<syntax_asdl::NameType*>* Transformer::_NameTypeList(pnode::PNode* p_node) {
  List<syntax_asdl::NameType*>* results = nullptr;
  int n;
  StackRoot _root0(&results);

  results = Alloc<List<syntax_asdl::NameType*>>();
  n = p_node->NumChildren();
  for (int i = 0; i < n; i += 2) {
    results->append(this->_NameType(p_node->GetChild(i)));
  }
  return results;
}

syntax_asdl::Comprehension* Transformer::_CompFor(pnode::PNode* p_node) {
  List<syntax_asdl::NameType*>* lhs = nullptr;
  syntax_asdl::expr_t* iterable = nullptr;
  syntax_asdl::expr_t* cond = nullptr;
  StackRoot _root0(&lhs);
  StackRoot _root1(&iterable);
  StackRoot _root2(&cond);

  lhs = this->_NameTypeList(p_node->GetChild(1));
  iterable = this->Expr(p_node->GetChild(3));
  if (p_node->NumChildren() >= 6) {
    cond = this->Expr(p_node->GetChild(5));
  }
  else {
    cond = nullptr;
  }
  return Alloc<Comprehension>(lhs, iterable, cond);
}

syntax_asdl::expr_t* Transformer::_CompareChain(pnode::PNode* parent) {
  List<syntax_asdl::Token*>* cmp_ops = nullptr;
  List<syntax_asdl::expr_t*>* comparators = nullptr;
  syntax_asdl::expr_t* left = nullptr;
  int i;
  int n;
  pnode::PNode* p = nullptr;
  syntax_asdl::Token* op = nullptr;
  StackRoot _root0(&cmp_ops);
  StackRoot _root1(&comparators);
  StackRoot _root2(&left);
  StackRoot _root3(&op);

  cmp_ops = Alloc<List<syntax_asdl::Token*>>();
  comparators = Alloc<List<syntax_asdl::expr_t*>>();
  left = this->Expr(parent->GetChild(0));
  i = 1;
  n = parent->NumChildren();
  while (i < n) {
    p = parent->GetChild(i);
    op = p->GetChild(0)->tok;
    if (p->NumChildren() == 2) {
      if (op->id == Id::Expr_Not) {
        op->id = Id::Node_NotIn;
      }
      else {
        if (op->id == Id::Expr_Is) {
          op->id = Id::Node_IsNot;
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
    else {
      ;  // pass
    }
    cmp_ops->append(op);
    i += 1;
    comparators->append(this->Expr(parent->GetChild(i)));
    i += 1;
  }
  return Alloc<expr::Compare>(left, cmp_ops, comparators);
}

syntax_asdl::expr_t* Transformer::_Subscript(pnode::PNode* parent) {
  int typ0;
  int n;
  syntax_asdl::expr_t* lower = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  syntax_asdl::expr_t* upper = nullptr;
  StackRoot _root0(&lower);
  StackRoot _root1(&op_tok);
  StackRoot _root2(&upper);

  typ0 = parent->GetChild(0)->typ;
  n = parent->NumChildren();
  if (typ0 == grammar_nt::expr) {
    if (n == 3) {
      lower = this->Expr(parent->GetChild(0));
      op_tok = parent->GetChild(1)->tok;
      upper = this->Expr(parent->GetChild(2));
    }
    else {
      if (n == 2) {
        lower = this->Expr(parent->GetChild(0));
        op_tok = parent->GetChild(1)->tok;
        upper = nullptr;
      }
      else {
        return this->Expr(parent->GetChild(0));
      }
    }
  }
  else {
    lower = nullptr;
    if (n == 1) {
      op_tok = parent->GetChild(0)->tok;
      upper = nullptr;
    }
    else {
      op_tok = parent->GetChild(0)->tok;
      upper = this->Expr(parent->GetChild(1));
    }
  }
  return Alloc<expr::Slice>(lower, op_tok, upper);
}

syntax_asdl::expr_t* Transformer::Expr(pnode::PNode* pnode) {
  int typ;
  syntax_asdl::expr_t* test = nullptr;
  syntax_asdl::expr_t* body = nullptr;
  syntax_asdl::expr_t* orelse = nullptr;
  int n;
  List<syntax_asdl::NameType*>* params = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  pnode::PNode* op = nullptr;
  pnode::PNode* e = nullptr;
  syntax_asdl::expr_t* node = nullptr;
  int i;
  syntax_asdl::expr_t* factor = nullptr;
  syntax_asdl::DoubleQuoted* dq = nullptr;
  syntax_asdl::Token* tok = nullptr;
  BigStr* bare = nullptr;
  BigStr* tok_str = nullptr;
  BigStr* c_under = nullptr;
  bool ok;
  mops::BigInt big_int;
  value_asdl::value_t* cval = nullptr;
  BigStr* s = nullptr;
  BigStr* hex_str = nullptr;
  int code_point;
  StackRoot _root0(&test);
  StackRoot _root1(&body);
  StackRoot _root2(&orelse);
  StackRoot _root3(&params);
  StackRoot _root4(&op_tok);
  StackRoot _root5(&node);
  StackRoot _root6(&factor);
  StackRoot _root7(&dq);
  StackRoot _root8(&tok);
  StackRoot _root9(&bare);
  StackRoot _root10(&tok_str);
  StackRoot _root11(&c_under);
  StackRoot _root12(&cval);
  StackRoot _root13(&s);
  StackRoot _root14(&hex_str);

  typ = pnode->typ;
  if (typ == grammar_nt::ysh_expr) {
    return this->Expr(pnode->GetChild(1));
  }
  if (typ == grammar_nt::command_expr) {
    return this->Expr(pnode->GetChild(0));
  }
  if (typ == grammar_nt::atom) {
    if (pnode->NumChildren() == 1) {
      return this->Expr(pnode->GetChild(0));
    }
    return this->_Atom(pnode);
  }
  if (typ == grammar_nt::testlist) {
    return this->_Tuple(pnode);
  }
  if (typ == grammar_nt::test) {
    if (pnode->NumChildren() == 1) {
      return this->Expr(pnode->GetChild(0));
    }
    test = this->Expr(pnode->GetChild(2));
    body = this->Expr(pnode->GetChild(0));
    orelse = this->Expr(pnode->GetChild(4));
    return Alloc<expr::IfExp>(test, body, orelse);
  }
  if (typ == grammar_nt::lambdef) {
    n = pnode->NumChildren();
    if (n == 4) {
      params = this->_NameTypeList(pnode->GetChild(1));
    }
    else {
      params = Alloc<List<syntax_asdl::NameType*>>();
    }
    body = this->Expr(pnode->GetChild((n - 1)));
    return Alloc<expr::Lambda>(params, body);
  }
  if (typ == grammar_nt::or_test) {
    return this->_LeftAssoc(pnode);
  }
  if (typ == grammar_nt::and_test) {
    return this->_LeftAssoc(pnode);
  }
  if (typ == grammar_nt::not_test) {
    if (pnode->NumChildren() == 1) {
      return this->Expr(pnode->GetChild(0));
    }
    op_tok = pnode->GetChild(0)->tok;
    return Alloc<expr::Unary>(op_tok, this->Expr(pnode->GetChild(1)));
  }
  else {
    if (typ == grammar_nt::comparison) {
      if (pnode->NumChildren() == 1) {
        return this->Expr(pnode->GetChild(0));
      }
      return this->_CompareChain(pnode);
    }
    else {
      if (typ == grammar_nt::range_expr) {
        n = pnode->NumChildren();
        if (n == 1) {
          return this->Expr(pnode->GetChild(0));
        }
        if (n == 3) {
          return Alloc<expr::Range>(this->Expr(pnode->GetChild(0)), pnode->GetChild(1)->tok, this->Expr(pnode->GetChild(2)));
        }
        assert(0);  // AssertionError
      }
      else {
        if (typ == grammar_nt::expr) {
          return this->_LeftAssoc(pnode);
        }
      }
    }
  }
  if (typ == grammar_nt::xor_expr) {
    return this->_LeftAssoc(pnode);
  }
  if (typ == grammar_nt::and_expr) {
    return this->_LeftAssoc(pnode);
  }
  else {
    if (typ == grammar_nt::shift_expr) {
      return this->_LeftAssoc(pnode);
    }
    else {
      if (typ == grammar_nt::arith_expr) {
        return this->_LeftAssoc(pnode);
      }
      else {
        if (typ == grammar_nt::term) {
          return this->_LeftAssoc(pnode);
        }
        else {
          if (typ == grammar_nt::factor) {
            if (pnode->NumChildren() == 1) {
              return this->Expr(pnode->GetChild(0));
            }
            op = pnode->GetChild(0);
            e = pnode->GetChild(1);
            return Alloc<expr::Unary>(op->tok, this->Expr(e));
          }
          else {
            if (typ == grammar_nt::power) {
              node = this->Expr(pnode->GetChild(0));
              if (pnode->NumChildren() == 1) {
                return node;
              }
              n = pnode->NumChildren();
              i = 1;
              while ((i < n and pnode->GetChild(i)->typ == grammar_nt::trailer)) {
                node = this->_Trailer(node, pnode->GetChild(i));
                i += 1;
              }
              if (i != n) {
                op_tok = pnode->GetChild(i)->tok;
                factor = this->Expr(pnode->GetChild((i + 1)));
                node = Alloc<expr::Binary>(op_tok, node, factor);
              }
              return node;
            }
            else {
              if (typ == grammar_nt::eggex) {
                return this->_Eggex(pnode);
              }
              else {
                if (typ == grammar_nt::ysh_expr_sub) {
                  return this->Expr(pnode->GetChild(0));
                }
                else {
                  if (typ == grammar_nt::sh_array_literal) {
                    return reinterpret_cast<YshArrayLiteral*>(pnode->GetChild(1)->tok);
                  }
                  else {
                    if (typ == grammar_nt::old_sh_array_literal) {
                      return reinterpret_cast<YshArrayLiteral*>(pnode->GetChild(1)->tok);
                    }
                    else {
                      if (typ == grammar_nt::sh_command_sub) {
                        return reinterpret_cast<CommandSub*>(pnode->GetChild(1)->tok);
                      }
                      else {
                        if (typ == grammar_nt::braced_var_sub) {
                          return reinterpret_cast<BracedVarSub*>(pnode->GetChild(1)->tok);
                        }
                        else {
                          if (typ == grammar_nt::dq_string) {
                            dq = reinterpret_cast<DoubleQuoted*>(pnode->GetChild(1)->tok);
                            if (pnode->GetChild(0)->typ == Id::Left_CaretDoubleQuote) {
                              return Alloc<expr::Literal>(dq);
                            }
                            return dq;
                          }
                          else {
                            if (typ == grammar_nt::sq_string) {
                              return reinterpret_cast<SingleQuoted*>(pnode->GetChild(1)->tok);
                            }
                            else {
                              if (typ == grammar_nt::simple_var_sub) {
                                tok = pnode->GetChild(0)->tok;
                                if (tok->id == Id::VSub_DollarName) {
                                  bare = lexer::TokenSliceLeft(tok, 1);
                                  p_die(StrFormat("In expressions, remove $ and use `%s`, or sometimes \"$%s\"", bare, bare), tok);
                                }
                                return Alloc<SimpleVarSub>(tok);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tok = pnode->tok;
  if (typ == Id::Expr_Name) {
    return Alloc<expr::Var>(tok, lexer::TokenVal(tok));
  }
  tok_str = lexer::TokenVal(tok);
  c_under = tok_str->replace(S_tci, S_Aoo);
  if (typ == Id::Expr_DecInt) {
    Tuple2<bool, mops::BigInt> tup1 = mops::FromStr2(c_under);
    ok = tup1.at0();
    big_int = tup1.at1();
    if (!ok) {
      p_die(S_jgg, tok);
    }
    cval = Alloc<value::Int>(big_int);
  }
  else {
    if (typ == Id::Expr_BinInt) {
      Tuple2<bool, mops::BigInt> tup2 = mops::FromStr2(c_under->slice(2), 2);
      ok = tup2.at0();
      big_int = tup2.at1();
      if (!ok) {
        p_die(S_DCt, tok);
      }
      cval = Alloc<value::Int>(big_int);
    }
    else {
      if (typ == Id::Expr_OctInt) {
        Tuple2<bool, mops::BigInt> tup3 = mops::FromStr2(c_under->slice(2), 8);
        ok = tup3.at0();
        big_int = tup3.at1();
        if (!ok) {
          p_die(S_rDF, tok);
        }
        cval = Alloc<value::Int>(big_int);
      }
      else {
        if (typ == Id::Expr_HexInt) {
          Tuple2<bool, mops::BigInt> tup4 = mops::FromStr2(c_under->slice(2), 16);
          ok = tup4.at0();
          big_int = tup4.at1();
          if (!ok) {
            p_die(S_uDt, tok);
          }
          cval = Alloc<value::Int>(big_int);
        }
        else {
          if (typ == Id::Expr_Float) {
            cval = Alloc<value::Float>(to_float(c_under));
          }
          else {
            if (typ == Id::Expr_Null) {
              cval = value::Null;
            }
            else {
              if (typ == Id::Expr_True) {
                cval = Alloc<value::Bool>(true);
              }
              else {
                if (typ == Id::Expr_False) {
                  cval = Alloc<value::Bool>(false);
                }
                else {
                  if (typ == Id::Char_OneChar) {
                    s = consts::LookupCharC(lexer::TokenSliceLeft(tok, 1));
                    cval = Alloc<value::Str>(s);
                  }
                  else {
                    if (typ == Id::Char_YHex) {
                      hex_str = lexer::TokenSliceLeft(tok, 2);
                      s = chr(to_int(hex_str, 16));
                      cval = Alloc<value::Str>(s);
                    }
                    else {
                      if (typ == Id::Char_UBraced) {
                        hex_str = lexer::TokenSlice(tok, 3, -1);
                        code_point = to_int(hex_str, 16);
                        s = j8::Utf8Encode(code_point);
                        cval = Alloc<value::Str>(s);
                      }
                      else {
                        assert(0);  // AssertionError
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return Alloc<expr::Const>(tok, cval);
}

void Transformer::_CheckLhs(syntax_asdl::expr_t* lhs) {
  syntax_asdl::expr_t* UP_lhs = nullptr;
  StackRoot _root0(&lhs);
  StackRoot _root1(&UP_lhs);

  UP_lhs = lhs;
  switch (lhs->tag()) {
    case expr_e::Var: {
      ;  // pass
    }
      break;
    case expr_e::Subscript: {
      Subscript* lhs = static_cast<Subscript*>(UP_lhs);
      this->_CheckLhs(lhs->obj);
    }
      break;
    case expr_e::Attribute: {
      Attribute* lhs = static_cast<Attribute*>(UP_lhs);
      this->_CheckLhs(lhs->obj);
    }
      break;
    default: {
      p_die(S_juC, location::TokenForExpr(lhs));
    }
  }
}

List<syntax_asdl::y_lhs_t*>* Transformer::_LhsExprList(pnode::PNode* p_node) {
  List<syntax_asdl::y_lhs_t*>* lhs_list = nullptr;
  int n;
  pnode::PNode* p = nullptr;
  syntax_asdl::expr_t* e = nullptr;
  syntax_asdl::expr_t* UP_e = nullptr;
  syntax_asdl::loc_t* blame = nullptr;
  StackRoot _root0(&lhs_list);
  StackRoot _root1(&e);
  StackRoot _root2(&UP_e);
  StackRoot _root3(&blame);

  lhs_list = Alloc<List<syntax_asdl::y_lhs_t*>>();
  n = p_node->NumChildren();
  for (int i = 0; i < n; i += 2) {
    p = p_node->GetChild(i);
    e = this->Expr(p);
    UP_e = e;
    switch (e->tag()) {
      case expr_e::Var: {
        expr::Var* e = static_cast<expr::Var*>(UP_e);
        lhs_list->append(e->left);
      }
        break;
      case expr_e::Subscript: {
        Subscript* e = static_cast<Subscript*>(UP_e);
        this->_CheckLhs(e);
        lhs_list->append(e);
      }
        break;
      case expr_e::Attribute: {
        Attribute* e = static_cast<Attribute*>(UP_e);
        this->_CheckLhs(e);
        if (e->op->id != Id::Expr_Dot) {
          p_die(S_rcx, e->op);
        }
        lhs_list->append(e);
      }
        break;
      default: {
        ;  // pass
        if (p->tok) {
          blame = p->tok;
        }
        else {
          blame = loc::Missing;
        }
        p_die(S_gzm, blame);
      }
    }
  }
  return lhs_list;
}

syntax_asdl::VarDecl* Transformer::MakeVarDecl(pnode::PNode* p_node) {
  List<syntax_asdl::NameType*>* lhs = nullptr;
  int n;
  syntax_asdl::expr_t* rhs = nullptr;
  StackRoot _root0(&lhs);
  StackRoot _root1(&rhs);

  lhs = this->_NameTypeList(p_node->GetChild(0));
  n = p_node->NumChildren();
  if (n >= 3) {
    rhs = this->Expr(p_node->GetChild(2));
  }
  else {
    rhs = nullptr;
  }
  return Alloc<VarDecl>(nullptr, lhs, rhs);
}

syntax_asdl::Mutation* Transformer::MakeMutation(pnode::PNode* p_node) {
  List<syntax_asdl::y_lhs_t*>* lhs_list = nullptr;
  syntax_asdl::Token* op_tok = nullptr;
  syntax_asdl::expr_t* rhs = nullptr;
  StackRoot _root0(&lhs_list);
  StackRoot _root1(&op_tok);
  StackRoot _root2(&rhs);

  lhs_list = this->_LhsExprList(p_node->GetChild(0));
  op_tok = p_node->GetChild(1)->tok;
  if ((len(lhs_list) > 1 and op_tok->id != Id::Arith_Equal)) {
    p_die(S_Dtp, op_tok);
  }
  rhs = this->Expr(p_node->GetChild(2));
  return Alloc<Mutation>(nullptr, lhs_list, op_tok, rhs);
}

syntax_asdl::EggexFlag* Transformer::_EggexFlag(pnode::PNode* p_node) {
  int n;
  n = p_node->NumChildren();
  if (n == 1) {
    return Alloc<EggexFlag>(false, p_node->GetChild(0)->tok);
  }
  else {
    if (n == 2) {
      return Alloc<EggexFlag>(true, p_node->GetChild(1)->tok);
    }
    else {
      assert(0);  // AssertionError
    }
  }
}

syntax_asdl::Eggex* Transformer::_Eggex(pnode::PNode* p_node) {
  syntax_asdl::Token* left = nullptr;
  syntax_asdl::re_t* regex = nullptr;
  List<syntax_asdl::EggexFlag*>* flags = nullptr;
  syntax_asdl::Token* trans_pref = nullptr;
  int i;
  pnode::PNode* current = nullptr;
  BigStr* canonical_flags = nullptr;
  StackRoot _root0(&left);
  StackRoot _root1(&regex);
  StackRoot _root2(&flags);
  StackRoot _root3(&trans_pref);
  StackRoot _root4(&canonical_flags);

  left = p_node->GetChild(0)->tok;
  regex = this->_Regex(p_node->GetChild(1));
  flags = Alloc<List<syntax_asdl::EggexFlag*>>();
  trans_pref = nullptr;
  i = 2;
  current = p_node->GetChild(i);
  if (current->typ == Id::Op_Semi) {
    i += 1;
    while (true) {
      current = p_node->GetChild(i);
      if (current->typ != grammar_nt::re_flag) {
        break;
      }
      flags->append(this->_EggexFlag(current));
      i += 1;
    }
    if (current->typ == Id::Op_Semi) {
      i += 1;
      trans_pref = p_node->GetChild(i)->tok;
    }
  }
  if ((trans_pref == nullptr or str_equals(lexer::TokenVal(trans_pref), S_ith))) {
    canonical_flags = regex_translate::CanonicalFlags(flags);
  }
  else {
    canonical_flags = nullptr;
  }
  return Alloc<Eggex>(left, regex, flags, trans_pref, canonical_flags);
}

syntax_asdl::pat_t* Transformer::YshCasePattern(pnode::PNode* pnode) {
  pnode::PNode* pattern = nullptr;
  int typ;
  List<syntax_asdl::expr_t*>* exprs = nullptr;
  pnode::PNode* child = nullptr;
  syntax_asdl::expr_t* expr = nullptr;
  StackRoot _root0(&exprs);
  StackRoot _root1(&expr);

  pattern = pnode->GetChild(0);
  typ = pattern->typ;
  if (typ == Id::Op_LParen) {
    pattern = pnode->GetChild(1);
    typ = pattern->typ;
    if (typ == grammar_nt::pat_else) {
      return pat::Else;
    }
    if (typ == grammar_nt::pat_exprs) {
      exprs = Alloc<List<syntax_asdl::expr_t*>>();
      for (int i = 0; i < pattern->NumChildren(); ++i) {
        child = pattern->GetChild(i);
        if (child->typ == grammar_nt::expr) {
          expr = this->Expr(child);
          exprs->append(expr);
        }
      }
      return Alloc<pat::YshExprs>(exprs);
    }
  }
  if (typ == grammar_nt::eggex) {
    return this->_Eggex(pattern);
  }
  assert(0);  // AssertionError
}

syntax_asdl::expr_t* Transformer::_BlockArg(pnode::PNode* p_node) {
  int n;
  pnode::PNode* child = nullptr;
  n = p_node->NumChildren();
  if (n == 1) {
    child = p_node->GetChild(0);
    return this->Expr(child);
  }
  p_die(S_ago, p_node->tok);
}

void Transformer::_Argument(pnode::PNode* p_node, bool after_semi, syntax_asdl::ArgList* arglist) {
  List<syntax_asdl::expr_t*>* pos_args = nullptr;
  List<syntax_asdl::NamedArg*>* named_args = nullptr;
  int n;
  pnode::PNode* child = nullptr;
  syntax_asdl::expr_t* arg = nullptr;
  syntax_asdl::Token* tok0 = nullptr;
  expr::Spread* spread_expr = nullptr;
  syntax_asdl::expr_t* elt = nullptr;
  syntax_asdl::Comprehension* comp = nullptr;
  syntax_asdl::NamedArg* n1 = nullptr;
  StackRoot _root0(&arglist);
  StackRoot _root1(&pos_args);
  StackRoot _root2(&named_args);
  StackRoot _root3(&arg);
  StackRoot _root4(&tok0);
  StackRoot _root5(&spread_expr);
  StackRoot _root6(&elt);
  StackRoot _root7(&comp);
  StackRoot _root8(&n1);

  pos_args = arglist->pos_args;
  named_args = arglist->named_args;
  n = p_node->NumChildren();
  if (n == 1) {
    child = p_node->GetChild(0);
    if (after_semi) {
      p_die(POS_ARG_MISPLACED, child->tok);
    }
    arg = this->Expr(child);
    pos_args->append(arg);
    return ;
  }
  if (n == 2) {
    tok0 = p_node->GetChild(0)->tok;
    if (tok0->id == Id::Expr_Ellipsis) {
      spread_expr = Alloc<expr::Spread>(tok0, this->Expr(p_node->GetChild(1)));
      if (after_semi) {
        named_args->append(Alloc<NamedArg>(nullptr, spread_expr));
      }
      else {
        pos_args->append(spread_expr);
      }
      return ;
    }
    if (p_node->GetChild(1)->typ == grammar_nt::comp_for) {
      child = p_node->GetChild(0);
      if (after_semi) {
        p_die(POS_ARG_MISPLACED, child->tok);
      }
      elt = this->Expr(child);
      comp = this->_CompFor(p_node->GetChild(1));
      arg = Alloc<expr::GeneratorExp>(elt, NewList<syntax_asdl::Comprehension*>(std::initializer_list<syntax_asdl::Comprehension*>{comp}));
      pos_args->append(arg);
      return ;
    }
    assert(0);  // AssertionError
  }
  if (n == 3) {
    n1 = Alloc<NamedArg>(p_node->GetChild(0)->tok, this->Expr(p_node->GetChild(2)));
    named_args->append(n1);
    return ;
  }
  assert(0);  // AssertionError
}

void Transformer::_ArgGroup(pnode::PNode* p_node, bool after_semi, syntax_asdl::ArgList* arglist) {
  pnode::PNode* p_child = nullptr;
  StackRoot _root0(&arglist);

  for (int i = 0; i < p_node->NumChildren(); ++i) {
    p_child = p_node->GetChild(i);
    if (p_child->typ == grammar_nt::argument) {
      this->_Argument(p_child, after_semi, arglist);
    }
  }
}

void Transformer::_ArgList(pnode::PNode* p_node, syntax_asdl::ArgList* arglist) {
  int n;
  int i;
  pnode::PNode* child = nullptr;
  StackRoot _root0(&arglist);

  n = p_node->NumChildren();
  if (n == 0) {
    return ;
  }
  i = 0;
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::arg_group) {
    this->_ArgGroup(child, false, arglist);
    i += 1;
  }
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == Id::Op_Semi) {
    arglist->semi_tok = child->tok;
    i += 1;
  }
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::arg_group) {
    this->_ArgGroup(child, true, arglist);
    i += 1;
  }
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == Id::Op_Semi) {
    arglist->semi_tok2 = child->tok;
    i += 1;
  }
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::argument) {
    arglist->block_expr = this->_BlockArg(child);
    i += 1;
  }
}

void Transformer::ProcCallArgs(pnode::PNode* pnode, syntax_asdl::ArgList* arglist) {
  int n;
  pnode::PNode* child1 = nullptr;
  StackRoot _root0(&arglist);

  n = pnode->NumChildren();
  if (n == 2) {
    return ;
  }
  if (n == 3) {
    child1 = pnode->GetChild(1);
    this->_ArgList(child1, arglist);
    return ;
  }
  assert(0);  // AssertionError
}

syntax_asdl::TypeExpr* Transformer::_TypeExpr(pnode::PNode* pnode) {
  syntax_asdl::TypeExpr* ty = nullptr;
  int n;
  int i;
  syntax_asdl::TypeExpr* p = nullptr;
  StackRoot _root0(&ty);
  StackRoot _root1(&p);

  ty = TypeExpr::CreateNull();
  ty->tok = pnode->GetChild(0)->tok;
  ty->name = lexer::TokenVal(ty->tok);
  n = pnode->NumChildren();
  if (n == 1) {
    return ty;
  }
  ty->params = Alloc<List<syntax_asdl::TypeExpr*>>();
  i = 2;
  while (i < n) {
    p = this->_TypeExpr(pnode->GetChild(i));
    ty->params->append(p);
    i += 2;
  }
  return ty;
}

syntax_asdl::Param* Transformer::_Param(pnode::PNode* pnode) {
  syntax_asdl::Token* name_tok = nullptr;
  int n;
  syntax_asdl::expr_t* default_val = nullptr;
  syntax_asdl::TypeExpr* type_ = nullptr;
  StackRoot _root0(&name_tok);
  StackRoot _root1(&default_val);
  StackRoot _root2(&type_);

  name_tok = pnode->GetChild(0)->tok;
  n = pnode->NumChildren();
  default_val = nullptr;
  type_ = nullptr;
  if (n == 1) {
    ;  // pass
  }
  else {
    if (n == 2) {
      type_ = this->_TypeExpr(pnode->GetChild(1));
    }
    else {
      if (n == 3) {
        default_val = this->Expr(pnode->GetChild(2));
      }
      else {
        if (n == 4) {
          type_ = this->_TypeExpr(pnode->GetChild(1));
          default_val = this->Expr(pnode->GetChild(3));
        }
      }
    }
  }
  return Alloc<Param>(name_tok, lexer::TokenVal(name_tok), type_, default_val);
}

syntax_asdl::ParamGroup* Transformer::_ParamGroup(pnode::PNode* p_node) {
  List<syntax_asdl::Param*>* params = nullptr;
  syntax_asdl::RestParam* rest_of = nullptr;
  int n;
  int i;
  pnode::PNode* child = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&params);
  StackRoot _root1(&rest_of);
  StackRoot _root2(&tok);

  params = Alloc<List<syntax_asdl::Param*>>();
  rest_of = nullptr;
  n = p_node->NumChildren();
  i = 0;
  while (i < n) {
    child = p_node->GetChild(i);
    if (child->typ == grammar_nt::param) {
      params->append(this->_Param(child));
    }
    else {
      if (child->typ == Id::Expr_Ellipsis) {
        tok = p_node->GetChild((i + 1))->tok;
        rest_of = Alloc<RestParam>(tok, lexer::TokenVal(tok));
      }
    }
    i += 2;
  }
  return Alloc<ParamGroup>(params, rest_of);
}

syntax_asdl::proc_sig_t* Transformer::Proc(pnode::PNode* p_node) {
  int n;
  proc_sig::Closed* sig = nullptr;
  int i;
  pnode::PNode* child = nullptr;
  syntax_asdl::ParamGroup* group = nullptr;
  List<syntax_asdl::Param*>* params = nullptr;
  StackRoot _root0(&sig);
  StackRoot _root1(&group);
  StackRoot _root2(&params);

  n = p_node->NumChildren();
  if (n == 1) {
    return proc_sig::Open;
  }
  if (n == 3) {
    sig = proc_sig::Closed::CreateNull(true);
  }
  sig = proc_sig::Closed::CreateNull(true);
  i = 1;
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    sig->word = this->_ParamGroup(p_node->GetChild(i));
    for (ListIter<syntax_asdl::Param*> it(sig->word->params); !it.Done(); it.Next()) {
      syntax_asdl::Param* word = it.Value();
      StackRoot _for(&word    );
      if (word->type) {
        if ((!str_equals(word->type->name, S_DsF) && !str_equals(word->type->name, S_ioh))) {
          p_die(S_Bej, word->type->tok);
        }
        if (word->type->params != nullptr) {
          p_die(S_noa, word->type->tok);
        }
      }
    }
    i += 2;
  }
  else {
    i += 1;
  }
  if (i >= n) {
    return sig;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    sig->positional = this->_ParamGroup(p_node->GetChild(i));
    i += 2;
  }
  else {
    i += 1;
  }
  if (i >= n) {
    return sig;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    sig->named = this->_ParamGroup(p_node->GetChild(i));
    i += 2;
  }
  else {
    i += 1;
  }
  if (i >= n) {
    return sig;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    group = this->_ParamGroup(p_node->GetChild(i));
    params = group->params;
    if (len(params) > 1) {
      p_die(S_sxs, params->at(1)->blame_tok);
    }
    if (group->rest_of) {
      p_die(S_Cab, group->rest_of->blame_tok);
    }
    if (len(params) == 1) {
      if (params->at(0)->type) {
        if (!(str_equals(params->at(0)->type->name, S_jma))) {
          p_die(S_stA, params->at(0)->type->tok);
        }
        if (params->at(0)->type->params != nullptr) {
          p_die(S_noa, params->at(0)->type->tok);
        }
      }
      sig->block_param = params->at(0);
    }
  }
  return sig;
}

void Transformer::YshFunc(pnode::PNode* p_node, syntax_asdl::Func* out) {
  int n;
  int i;
  pnode::PNode* child = nullptr;
  StackRoot _root0(&out);

  out->name = p_node->GetChild(0)->tok;
  n = p_node->NumChildren();
  i = 2;
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    out->positional = this->_ParamGroup(child);
    i += 2;
  }
  else {
    i += 1;
  }
  if (i >= n) {
    return ;
  }
  child = p_node->GetChild(i);
  if (child->typ == grammar_nt::param_group) {
    out->named = this->_ParamGroup(child);
  }
}

syntax_asdl::CharCode* Transformer::_RangeCharSingleQuoted(pnode::PNode* p_node) {
  pnode::PNode* child0 = nullptr;
  syntax_asdl::SingleQuoted* sq_part = nullptr;
  int n;
  StackRoot _root0(&sq_part);

  child0 = p_node->GetChild(0);
  if (child0->typ == grammar_nt::sq_string) {
    sq_part = reinterpret_cast<SingleQuoted*>(child0->GetChild(1)->tok);
    n = len(sq_part->sval);
    if (n == 0) {
      p_die(S_lBE, Alloc<loc::WordPart>(sq_part));
    }
    else {
      if (n == 1) {
        return Alloc<CharCode>(sq_part->left, ord(sq_part->sval->at(0)), false);
      }
      else {
        p_die(RANGE_POINT_TOO_LONG, Alloc<loc::WordPart>(sq_part));
      }
    }
  }
  return nullptr;
}

syntax_asdl::Token* Transformer::_OtherRangeToken(pnode::PNode* p_node) {
  pnode::PNode* child0 = nullptr;
  syntax_asdl::Token* tok = nullptr;
  StackRoot _root0(&tok);

  child0 = p_node->GetChild(0);
  if (child0->typ == grammar_nt::char_literal) {
    tok = child0->GetChild(0)->tok;
    return tok;
  }
  tok = p_node->tok;
  if (tok->length != 1) {
    p_die(RANGE_POINT_TOO_LONG, tok);
  }
  return tok;
}

syntax_asdl::class_literal_term_t* Transformer::_NonRangeChars(pnode::PNode* p_node) {
  pnode::PNode* child0 = nullptr;
  int typ0;
  child0 = p_node->GetChild(0);
  typ0 = p_node->GetChild(0)->typ;
  if (typ0 == grammar_nt::sq_string) {
    return reinterpret_cast<SingleQuoted*>(child0->GetChild(1)->tok);
  }
  if (typ0 == grammar_nt::char_literal) {
    return word_compile::EvalCharLiteralForRegex(child0->tok);
  }
  if (typ0 == Id::Expr_Name) {
    return this->_NameInClass(nullptr, child0->tok);
  }
  assert(0);  // AssertionError
}

syntax_asdl::class_literal_term_t* Transformer::_ClassLiteralTerm(pnode::PNode* p_node) {
  int typ0;
  int n;
  pnode::PNode* left = nullptr;
  pnode::PNode* right = nullptr;
  syntax_asdl::CharCode* code1 = nullptr;
  syntax_asdl::Token* tok1 = nullptr;
  syntax_asdl::CharCode* code2 = nullptr;
  syntax_asdl::Token* tok2 = nullptr;
  StackRoot _root0(&code1);
  StackRoot _root1(&tok1);
  StackRoot _root2(&code2);
  StackRoot _root3(&tok2);

  typ0 = p_node->GetChild(0)->typ;
  if (typ0 == grammar_nt::range_char) {
    n = p_node->NumChildren();
    if (n == 1) {
      return this->_NonRangeChars(p_node->GetChild(0));
    }
    if (n == 3) {
      left = p_node->GetChild(0);
      right = p_node->GetChild(2);
      code1 = this->_RangeCharSingleQuoted(left);
      if (code1 == nullptr) {
        tok1 = this->_OtherRangeToken(left);
        code1 = word_compile::EvalCharLiteralForRegex(tok1);
      }
      code2 = this->_RangeCharSingleQuoted(right);
      if (code2 == nullptr) {
        tok2 = this->_OtherRangeToken(right);
        code2 = word_compile::EvalCharLiteralForRegex(tok2);
      }
      return Alloc<CharRange>(code1, code2);
    }
    assert(0);  // AssertionError
  }
  if (typ0 == Id::Expr_At) {
    tok1 = p_node->GetChild(1)->tok;
    return Alloc<class_literal_term::Splice>(tok1, lexer::TokenVal(tok1));
  }
  if (typ0 == Id::Expr_Bang) {
    return this->_NameInClass(p_node->GetChild(0)->tok, p_node->GetChild(1)->tok);
  }
  p_die(S_dlq, p_node->GetChild(0)->tok);
}

List<syntax_asdl::class_literal_term_t*>* Transformer::_ClassLiteral(pnode::PNode* p_node) {
  List<syntax_asdl::class_literal_term_t*>* terms = nullptr;
  StackRoot _root0(&terms);

  terms = Alloc<List<syntax_asdl::class_literal_term_t*>>();
  for (int i = 1; i < (p_node->NumChildren() - 1); ++i) {
    terms->append(this->_ClassLiteralTerm(p_node->GetChild(i)));
  }
  return terms;
}

syntax_asdl::re_t* Transformer::_NameInRegex(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok) {
  BigStr* tok_str = nullptr;
  BigStr* perl = nullptr;
  StackRoot _root0(&negated_tok);
  StackRoot _root1(&tok);
  StackRoot _root2(&tok_str);
  StackRoot _root3(&perl);

  tok_str = lexer::TokenVal(tok);
  if (str_equals(tok_str, S_urc)) {
    if (negated_tok) {
      p_die(S_kfs, tok);
    }
    return Alloc<re::Primitive>(tok, Id::Eggex_Dot);
  }
  if (list_contains(POSIX_CLASSES, tok_str)) {
    return Alloc<PosixClass>(negated_tok, tok_str);
  }
  perl = PERL_CLASSES->get(tok_str);
  if (perl != nullptr) {
    return Alloc<PerlClass>(negated_tok, perl);
  }
  if (tok_str->at(0)->isupper()) {
    return Alloc<re::Splice>(tok, lexer::TokenVal(tok));
  }
  p_die(StrFormat("%r isn't a character class", tok_str), tok);
}

syntax_asdl::class_literal_term_t* Transformer::_NameInClass(syntax_asdl::Token* negated_tok, syntax_asdl::Token* tok) {
  BigStr* tok_str = nullptr;
  BigStr* perl = nullptr;
  StackRoot _root0(&negated_tok);
  StackRoot _root1(&tok);
  StackRoot _root2(&tok_str);
  StackRoot _root3(&perl);

  tok_str = lexer::TokenVal(tok);
  if (len(tok_str) == 1) {
    if (negated_tok) {
      p_die(S_kfs, tok);
    }
    return word_compile::EvalCharLiteralForRegex(tok);
  }
  if (list_contains(POSIX_CLASSES, tok_str)) {
    return Alloc<PosixClass>(negated_tok, tok_str);
  }
  perl = PERL_CLASSES->get(tok_str);
  if (perl != nullptr) {
    return Alloc<PerlClass>(negated_tok, perl);
  }
  p_die(StrFormat("%r isn't a character class", tok_str), tok);
}

syntax_asdl::re_t* Transformer::_ReAtom(pnode::PNode* p_atom) {
  pnode::PNode* child0 = nullptr;
  int typ0;
  syntax_asdl::Token* tok0 = nullptr;
  BigStr* s = nullptr;
  BigStr* tok_str = nullptr;
  syntax_asdl::Token* tok1 = nullptr;
  int n;
  pnode::PNode* child1 = nullptr;
  syntax_asdl::re_t* regex = nullptr;
  syntax_asdl::Token* as_name = nullptr;
  syntax_asdl::Token* func_name = nullptr;
  int i;
  int typ;
  StackRoot _root0(&tok0);
  StackRoot _root1(&s);
  StackRoot _root2(&tok_str);
  StackRoot _root3(&tok1);
  StackRoot _root4(&regex);
  StackRoot _root5(&as_name);
  StackRoot _root6(&func_name);

  child0 = p_atom->GetChild(0);
  typ0 = p_atom->GetChild(0)->typ;
  tok0 = p_atom->GetChild(0)->tok;
  if (typ0 == grammar_nt::class_literal) {
    return Alloc<re::CharClassLiteral>(false, this->_ClassLiteral(child0));
  }
  if (typ0 == grammar_nt::sq_string) {
    return reinterpret_cast<SingleQuoted*>(child0->GetChild(1)->tok);
  }
  if (typ0 == grammar_nt::char_literal) {
    s = word_compile::EvalCStringToken(tok0->id, lexer::TokenVal(tok0));
    return Alloc<re::LiteralChars>(tok0, s);
  }
  if (typ0 == Id::Expr_Dot) {
    return Alloc<re::Primitive>(tok0, Id::Eggex_Dot);
  }
  if (typ0 == Id::Arith_Caret) {
    return Alloc<re::Primitive>(tok0, Id::Eggex_Start);
  }
  if (typ0 == Id::Expr_Dollar) {
    return Alloc<re::Primitive>(tok0, Id::Eggex_End);
  }
  if (typ0 == Id::Expr_Name) {
    return this->_NameInRegex(nullptr, tok0);
  }
  if (typ0 == Id::Expr_Symbol) {
    tok_str = lexer::TokenVal(tok0);
    if (str_equals(tok_str, S_DwB)) {
      return Alloc<re::Primitive>(tok0, Id::Eggex_Start);
    }
    if (str_equals(tok_str, S_Ctu)) {
      return Alloc<re::Primitive>(tok0, Id::Eggex_End);
    }
    p_die(StrFormat("Unexpected token %r in regex", tok_str), tok0);
  }
  if (typ0 == Id::Expr_At) {
    tok1 = p_atom->GetChild(1)->tok;
    return Alloc<re::Splice>(tok0, lexer::TokenVal(tok1));
  }
  if (typ0 == Id::Expr_Bang) {
    n = p_atom->NumChildren();
    if (n == 2) {
      child1 = p_atom->GetChild(1);
      if (child1->typ == grammar_nt::class_literal) {
        return Alloc<re::CharClassLiteral>(true, this->_ClassLiteral(child1));
      }
      else {
        return this->_NameInRegex(tok0, p_atom->GetChild(1)->tok);
      }
    }
    else {
      p_die(S_Fkp, p_atom->GetChild(1)->tok);
    }
  }
  if (typ0 == Id::Op_LParen) {
    return Alloc<re::Group>(this->_Regex(p_atom->GetChild(1)));
  }
  if (typ0 == Id::Arith_Less) {
    n = p_atom->NumChildren();
    regex = this->_Regex(p_atom->GetChild(2));
    as_name = nullptr;
    func_name = nullptr;
    i = 3;
    typ = p_atom->GetChild(i)->typ;
    if (typ == Id::Expr_As) {
      as_name = p_atom->GetChild((i + 1))->tok;
      i += 2;
    }
    typ = p_atom->GetChild(i)->typ;
    if (typ == Id::Arith_Colon) {
      func_name = p_atom->GetChild((i + 1))->tok;
    }
    return Alloc<re::Capture>(regex, as_name, func_name);
  }
  assert(0);  // AssertionError
}

syntax_asdl::re_repeat_t* Transformer::_RepeatOp(pnode::PNode* p_repeat) {
  syntax_asdl::Token* tok = nullptr;
  int id_;
  pnode::PNode* child1 = nullptr;
  int n;
  syntax_asdl::Token* left = nullptr;
  syntax_asdl::Token* right = nullptr;
  StackRoot _root0(&tok);
  StackRoot _root1(&left);
  StackRoot _root2(&right);

  tok = p_repeat->GetChild(0)->tok;
  id_ = tok->id;
  if ((id_ == Id::Arith_Plus || id_ == Id::Arith_Star || id_ == Id::Arith_QMark)) {
    return tok;
  }
  if (id_ == Id::Op_LBrace) {
    child1 = p_repeat->GetChild(1);
    if (child1->typ != grammar_nt::repeat_range) {
      p_die(S_aBC, child1->tok);
    }
    n = child1->NumChildren();
    if (n == 1) {
      tok = child1->GetChild(0)->tok;
      return tok;
    }
    if (n == 2) {
      if (child1->GetChild(0)->typ == Id::Expr_DecInt) {
        left = child1->GetChild(0)->tok;
        return Alloc<re_repeat::Range>(left, lexer::TokenVal(left), S_Aoo, nullptr);
      }
      else {
        right = child1->GetChild(1)->tok;
        return Alloc<re_repeat::Range>(nullptr, S_Aoo, lexer::TokenVal(right), right);
      }
    }
    if (n == 3) {
      left = child1->GetChild(0)->tok;
      right = child1->GetChild(2)->tok;
      return Alloc<re_repeat::Range>(left, lexer::TokenVal(left), lexer::TokenVal(right), right);
    }
    assert(0);  // AssertionError
  }
  assert(0);  // AssertionError
}

syntax_asdl::re_t* Transformer::_ReAlt(pnode::PNode* p_node) {
  int i;
  int n;
  List<syntax_asdl::re_t*>* seq = nullptr;
  syntax_asdl::re_t* r = nullptr;
  syntax_asdl::re_repeat_t* repeat_op = nullptr;
  StackRoot _root0(&seq);
  StackRoot _root1(&r);
  StackRoot _root2(&repeat_op);

  i = 0;
  n = p_node->NumChildren();
  seq = Alloc<List<syntax_asdl::re_t*>>();
  while (i < n) {
    r = this->_ReAtom(p_node->GetChild(i));
    i += 1;
    if ((i < n and p_node->GetChild(i)->typ == grammar_nt::repeat_op)) {
      repeat_op = this->_RepeatOp(p_node->GetChild(i));
      r = Alloc<re::Repeat>(r, repeat_op);
      i += 1;
    }
    seq->append(r);
  }
  if (len(seq) == 1) {
    return seq->at(0);
  }
  else {
    return Alloc<re::Seq>(seq);
  }
}

syntax_asdl::re_t* Transformer::_Regex(pnode::PNode* p_node) {
  int n;
  List<syntax_asdl::re_t*>* alts = nullptr;
  pnode::PNode* c = nullptr;
  StackRoot _root0(&alts);

  n = p_node->NumChildren();
  alts = Alloc<List<syntax_asdl::re_t*>>();
  for (int i = 0; i < n; i += 2) {
    c = p_node->GetChild(i);
    alts->append(this->_ReAlt(c));
  }
  if (len(alts) == 1) {
    return alts->at(0);
  }
  else {
    return Alloc<re::Alt>(alts);
  }
}

}  // define namespace expr_to_ast

namespace regex_translate {  // define

using syntax_asdl::PosixClass;
using syntax_asdl::PerlClass;
using syntax_asdl::CharCode;
using syntax_asdl::CharRange;
using syntax_asdl::char_class_term_e;
using syntax_asdl::char_class_term_t;
using syntax_asdl::re;
using syntax_asdl::re_e;
using syntax_asdl::re_repeat;
using syntax_asdl::re_repeat_e;
using syntax_asdl::EggexFlag;
using syntax_asdl::Token;
using id_kind_asdl::Id;
using value_asdl::value;
using error::e_die;
using error::p_die;
GLOBAL_DICT(PERL_CLASS, BigStr*, BigStr*, 3, {S_Crn COMMA S_pfC COMMA S_anC}, {S_Bro COMMA S_eEf COMMA S_khq});
int CH_RBRACKET = 93;
int CH_BACKSLASH = 92;
int CH_CARET = 94;
int CH_HYPHEN = 45;
int FLAG_RBRACKET = 1;
int FLAG_BACKSLASH = 2;
int FLAG_CARET = 4;
int FLAG_HYPHEN = 8;

void _CharCodeToEre(syntax_asdl::CharCode* term, List<BigStr*>* parts, List<int>* special_char_flags) {
  int char_int;
  int mask;
  StackRoot _root0(&term);
  StackRoot _root1(&parts);
  StackRoot _root2(&special_char_flags);

  char_int = term->i;
  if ((char_int >= 128 and term->u_braced)) {
    e_die(StrFormat("ERE can't express char code %d", char_int), term->blame_tok);
  }
  mask = special_char_flags->at(0);
  if (char_int == CH_HYPHEN) {
    mask |= FLAG_HYPHEN;
  }
  else {
    if (char_int == CH_CARET) {
      mask |= FLAG_CARET;
    }
    else {
      if (char_int == CH_RBRACKET) {
        mask |= FLAG_RBRACKET;
      }
      else {
        if (char_int == CH_BACKSLASH) {
          mask |= FLAG_BACKSLASH;
        }
        else {
          parts->append(chr(char_int));
        }
      }
    }
  }
  special_char_flags->set(0, mask);
}

void _CharClassTermToEre(syntax_asdl::char_class_term_t* term, List<BigStr*>* parts, List<int>* special_char_flags) {
  syntax_asdl::char_class_term_t* UP_term = nullptr;
  List<int>* range_no_special = nullptr;
  BigStr* n = nullptr;
  BigStr* chars = nullptr;
  BigStr* pat = nullptr;
  StackRoot _root0(&term);
  StackRoot _root1(&parts);
  StackRoot _root2(&special_char_flags);
  StackRoot _root3(&UP_term);
  StackRoot _root4(&range_no_special);
  StackRoot _root5(&n);
  StackRoot _root6(&chars);
  StackRoot _root7(&pat);

  UP_term = term;
  switch (term->tag()) {
    case char_class_term_e::CharRange: {
      CharRange* term = static_cast<CharRange*>(UP_term);
      range_no_special = NewList<int>(std::initializer_list<int>{0});
      _CharCodeToEre(term->start, parts, range_no_special);
      if (range_no_special->at(0) != 0) {
        e_die(StrFormat("Can't use char %d as start of range in ERE syntax", term->start->i), term->start->blame_tok);
      }
      parts->append(S_Bjq);
      _CharCodeToEre(term->end, parts, range_no_special);
      if (range_no_special->at(0) != 0) {
        e_die(StrFormat("Can't use char %d as end of range in ERE syntax", term->end->i), term->end->blame_tok);
      }
    }
      break;
    case char_class_term_e::CharCode: {
      CharCode* term = static_cast<CharCode*>(UP_term);
      _CharCodeToEre(term, parts, special_char_flags);
    }
      break;
    case char_class_term_e::PerlClass: {
      PerlClass* term = static_cast<PerlClass*>(UP_term);
      n = term->name;
      chars = PERL_CLASS->at(term->name);
      if (term->negated) {
        e_die(S_rqm, term->negated);
      }
      else {
        pat = StrFormat("%s", chars);
      }
      parts->append(pat);
    }
      break;
    case char_class_term_e::PosixClass: {
      PosixClass* term = static_cast<PosixClass*>(UP_term);
      n = term->name;
      if (term->negated) {
        e_die(S_xil, term->negated);
      }
      else {
        pat = StrFormat("[:%s:]", n);
      }
      parts->append(pat);
    }
      break;
    default: {
      assert(0);  // AssertionError
    }
  }
}

void _AsPosixEre(syntax_asdl::re_t* node, List<BigStr*>* parts, List<BigStr*>* capture_names) {
  syntax_asdl::re_t* UP_node = nullptr;
  int tag;
  int i;
  re::LiteralChars* child = nullptr;
  syntax_asdl::re_repeat_t* op = nullptr;
  int op_tag;
  syntax_asdl::re_repeat_t* UP_op = nullptr;
  BigStr* capture_str = nullptr;
  BigStr* n = nullptr;
  BigStr* chars = nullptr;
  BigStr* pat = nullptr;
  List<int>* special_char_flags = nullptr;
  List<BigStr*>* non_special_parts = nullptr;
  StackRoot _root0(&node);
  StackRoot _root1(&parts);
  StackRoot _root2(&capture_names);
  StackRoot _root3(&UP_node);
  StackRoot _root4(&child);
  StackRoot _root5(&op);
  StackRoot _root6(&UP_op);
  StackRoot _root7(&capture_str);
  StackRoot _root8(&n);
  StackRoot _root9(&chars);
  StackRoot _root10(&pat);
  StackRoot _root11(&special_char_flags);
  StackRoot _root12(&non_special_parts);

  UP_node = node;
  tag = node->tag();
  if (tag == re_e::Primitive) {
    re::Primitive* node = static_cast<re::Primitive*>(UP_node);
    if (node->id == Id::Eggex_Dot) {
      parts->append(S_Aru);
    }
    else {
      if (node->id == Id::Eggex_Start) {
        parts->append(S_EAB);
      }
      else {
        if (node->id == Id::Eggex_End) {
          parts->append(S_Czx);
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
    return ;
  }
  if (tag == re_e::LiteralChars) {
    re::LiteralChars* node = static_cast<re::LiteralChars*>(UP_node);
    parts->append(glob_::ExtendedRegexEscape(node->s));
    return ;
  }
  if (tag == re_e::Seq) {
    re::Seq* node = static_cast<re::Seq*>(UP_node);
    for (ListIter<syntax_asdl::re_t*> it(node->children); !it.Done(); it.Next()) {
      syntax_asdl::re_t* c = it.Value();
      StackRoot _for(&c    );
      _AsPosixEre(c, parts, capture_names);
    }
    return ;
  }
  if (tag == re_e::Alt) {
    re::Alt* node = static_cast<re::Alt*>(UP_node);
    i = 0;
    for (ListIter<syntax_asdl::re_t*> it(node->children); !it.Done(); it.Next(), ++i) {
      syntax_asdl::re_t* c = it.Value();
      StackRoot _for(&c    );
      if (i != 0) {
        parts->append(S_Ebn);
      }
      _AsPosixEre(c, parts, capture_names);
    }
    return ;
  }
  if (tag == re_e::Repeat) {
    re::Repeat* node = static_cast<re::Repeat*>(UP_node);
    if (node->child->tag() == re_e::LiteralChars) {
      child = static_cast<re::LiteralChars*>(node->child);
      if (len(child->s) > 1) {
        e_die(S_gik, child->blame_tok);
      }
    }
    _AsPosixEre(node->child, parts, capture_names);
    op = node->op;
    op_tag = op->tag();
    UP_op = op;
    if (op_tag == re_repeat_e::Op) {
      Token* op = static_cast<Token*>(UP_op);
      switch (op->id) {
        case Id::Arith_Plus: {
          parts->append(S_jnE);
        }
          break;
        case Id::Arith_Star: {
          parts->append(S_Fgw);
        }
          break;
        case Id::Arith_QMark: {
          parts->append(S_BAk);
        }
          break;
        case Id::Expr_DecInt: {
          parts->append(StrFormat("{%s}", lexer::LazyStr(op)));
        }
          break;
        default: {
          assert(0);  // AssertionError
        }
      }
      return ;
    }
    if (op_tag == re_repeat_e::Range) {
      re_repeat::Range* op = static_cast<re_repeat::Range*>(UP_op);
      parts->append(StrFormat("{%s,%s}", op->lower, op->upper));
      return ;
    }
    FAIL(kNotImplemented);  // Python NotImplementedError
  }
  if (tag == re_e::Group) {
    re::Group* node = static_cast<re::Group*>(UP_node);
    capture_names->append(nullptr);
    parts->append(S_ijB);
    _AsPosixEre(node->child, parts, capture_names);
    parts->append(S_hxb);
    return ;
  }
  if (tag == re_e::Capture) {
    re::Capture* node = static_cast<re::Capture*>(UP_node);
    capture_str = node->name ? lexer::TokenVal(node->name) : nullptr;
    capture_names->append(capture_str);
    parts->append(S_ijB);
    _AsPosixEre(node->child, parts, capture_names);
    parts->append(S_hxb);
    return ;
  }
  if (tag == re_e::PerlClass) {
    PerlClass* node = static_cast<PerlClass*>(UP_node);
    n = node->name;
    chars = PERL_CLASS->at(node->name);
    if (node->negated) {
      pat = StrFormat("[^%s]", chars);
    }
    else {
      pat = StrFormat("[%s]", chars);
    }
    parts->append(pat);
    return ;
  }
  if (tag == re_e::PosixClass) {
    PosixClass* node = static_cast<PosixClass*>(UP_node);
    n = node->name;
    if (node->negated) {
      pat = StrFormat("[^[:%s:]]", n);
    }
    else {
      pat = StrFormat("[[:%s:]]", n);
    }
    parts->append(pat);
    return ;
  }
  if (tag == re_e::CharClass) {
    re::CharClass* node = static_cast<re::CharClass*>(UP_node);
    special_char_flags = NewList<int>(std::initializer_list<int>{0});
    non_special_parts = Alloc<List<BigStr*>>();
    for (ListIter<syntax_asdl::char_class_term_t*> it(node->terms); !it.Done(); it.Next()) {
      syntax_asdl::char_class_term_t* term = it.Value();
      StackRoot _for(&term    );
      _CharClassTermToEre(term, non_special_parts, special_char_flags);
    }
    parts->append(S_Eax);
    if (node->negated) {
      parts->append(S_EAB);
    }
    if ((special_char_flags->at(0) & FLAG_RBRACKET)) {
      parts->append(S_pcD);
    }
    parts->extend(non_special_parts);
    if ((special_char_flags->at(0) & FLAG_BACKSLASH)) {
      parts->append(S_Eef);
    }
    if ((special_char_flags->at(0) & FLAG_CARET)) {
      parts->append(S_EAB);
    }
    if ((special_char_flags->at(0) & FLAG_HYPHEN)) {
      parts->append(S_Bjq);
    }
    parts->append(S_pcD);
    return ;
  }
  FAIL(kNotImplemented);  // Python NotImplementedError
}

BigStr* AsPosixEre(value::Eggex* eggex) {
  List<BigStr*>* parts = nullptr;
  StackRoot _root0(&eggex);
  StackRoot _root1(&parts);

  if (eggex->as_ere != nullptr) {
    return eggex->as_ere;
  }
  parts = Alloc<List<BigStr*>>();
  _AsPosixEre(eggex->spliced, parts, eggex->capture_names);
  eggex->as_ere = S_Aoo->join(parts);
  return eggex->as_ere;
}

BigStr* CanonicalFlags(List<syntax_asdl::EggexFlag*>* flags) {
  List<BigStr*>* letters = nullptr;
  BigStr* flag_name = nullptr;
  StackRoot _root0(&flags);
  StackRoot _root1(&letters);
  StackRoot _root2(&flag_name);

  letters = Alloc<List<BigStr*>>();
  for (ListIter<syntax_asdl::EggexFlag*> it(flags); !it.Done(); it.Next()) {
    syntax_asdl::EggexFlag* flag = it.Value();
    StackRoot _for(&flag  );
    if (flag->negated) {
      p_die(S_dwl, flag->flag);
    }
    flag_name = lexer::TokenVal(flag->flag);
    if ((str_equals(flag_name, S_eil) || str_equals(flag_name, S_fdv))) {
      letters->append(S_eil);
    }
    else {
      if (str_equals(flag_name, S_ABj)) {
        letters->append(S_rob);
      }
      else {
        p_die(StrFormat("Invalid regex flag %r", flag_name), flag->flag);
      }
    }
  }
  letters->sort();
  return S_Aoo->join(letters);
}

int LibcFlags(BigStr* canonical_flags) {
  int libc_flags;
  StackRoot _root0(&canonical_flags);

  if (canonical_flags == nullptr) {
    return 0;
  }
  libc_flags = 0;
  for (StrIter it(canonical_flags); !it.Done(); it.Next()) {
    BigStr* ch = it.Value();
    StackRoot _for(&ch  );
    if (str_equals(ch, S_eil)) {
      libc_flags |= REG_ICASE;
    }
    else {
      if (str_equals(ch, S_rob)) {
        libc_flags |= REG_NEWLINE;
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
  return libc_flags;
}

}  // define namespace regex_translate

