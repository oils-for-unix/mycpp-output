// _gen/asdl/examples/shared_variant.asdl.cc is generated by asdl_main.py

#include "_gen/asdl/examples/shared_variant.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;


namespace shared_variant_asdl {


hnode_t* prod::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("prod"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->a);
  L->append(Alloc<Field>(StrFromC("a"), x0));

  hnode_t* x1 = ToPretty(this->b);
  L->append(Alloc<Field>(StrFromC("b"), x1));

  return out_node;
}


hnode_t* DoubleQuoted::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("DoubleQuoted"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->left);
  L->append(Alloc<Field>(StrFromC("left"), x0));

  if (this->tokens != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<BigStr*> it(this->tokens); !it.Done(); it.Next()) {
      BigStr* v_ = it.Value();
      hnode_t* h = ToPretty(v_);
      x1->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("tokens"), x1));
  }

  return out_node;
}

BigStr* expr_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case expr_e::Binary:
    v = "Binary"; break;
  case expr_e::DoubleQuoted:
    v = "DoubleQuoted"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "expr.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* expr__Binary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->right->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("right"), x1));

  return out_node;
}


hnode_t* expr_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case expr_e::Binary: {
    expr__Binary* obj = static_cast<expr__Binary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case expr_e::DoubleQuoted: {
    DoubleQuoted* obj = static_cast<DoubleQuoted*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* Token::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("Token"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->id);
  L->append(Alloc<Field>(StrFromC("id"), x0));

  hnode_t* x1 = ToPretty(this->val);
  L->append(Alloc<Field>(StrFromC("val"), x1));

  return out_node;
}

BigStr* tok_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case tok_e::Eof:
    v = "Eof"; break;
  case tok_e::Token:
    v = "Token"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "tok.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

tok__Eof* tok::Eof = &gtok__Eof.obj;

GcGlobal<tok__Eof> gtok__Eof = 
  { ObjHeader::Global(tok_e::Eof) };

hnode_t* tok__Eof::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(tok_str(this->tag()));
  return out_node;
}


hnode_t* tok_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case tok_e::Eof: {
    tok__Eof* obj = static_cast<tok__Eof*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case tok_e::Token: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* tok_struct::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("tok_struct"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->token->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("token"), x0));

  hnode_t* x1 = ToPretty(this->x);
  L->append(Alloc<Field>(StrFromC("x"), x1));

  return out_node;
}


hnode_t* tok_array::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("tok_array"));
  List<Field*>* L = out_node->fields;

  if (this->tokens != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<tok_t*> it(this->tokens); !it.Done(); it.Next()) {
      tok_t* v_ = it.Value();
      hnode_t* h = (v_ == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                    color_e::OtherConst) : v_->PrettyTree(do_abbrev, seen);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("tokens"), x0));
  }

  return out_node;
}

BigStr* word_part_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case word_part_e::Literal:
    v = "Literal"; break;
  case word_part_e::DoubleQuoted:
    v = "DoubleQuoted"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "word_part.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* word_part__Literal::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(word_part_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->s);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  return out_node;
}


hnode_t* word_part_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case word_part_e::Literal: {
    word_part__Literal* obj = static_cast<word_part__Literal*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case word_part_e::DoubleQuoted: {
    DoubleQuoted* obj = static_cast<DoubleQuoted*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}
BigStr* cflow_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case cflow_e::Break:
    v = "Break"; break;
  case cflow_e::Continue:
    v = "Continue"; break;
  case cflow_e::Return:
    v = "Return"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "cflow.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

cflow__Break* cflow::Break = &gcflow__Break.obj;

GcGlobal<cflow__Break> gcflow__Break = 
  { ObjHeader::Global(cflow_e::Break) };

cflow__Continue* cflow::Continue = &gcflow__Continue.obj;

GcGlobal<cflow__Continue> gcflow__Continue = 
  { ObjHeader::Global(cflow_e::Continue) };

hnode_t* cflow__Break::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  return out_node;
}


hnode_t* cflow__Continue::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  return out_node;
}


hnode_t* cflow__Return::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->val);
  L->append(Alloc<Field>(StrFromC("val"), x0));

  return out_node;
}


hnode_t* cflow_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case cflow_e::Break: {
    cflow__Break* obj = static_cast<cflow__Break*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow_e::Continue: {
    cflow__Continue* obj = static_cast<cflow__Continue*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow_e::Return: {
    cflow__Return* obj = static_cast<cflow__Return*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

}  // namespace shared_variant_asdl
