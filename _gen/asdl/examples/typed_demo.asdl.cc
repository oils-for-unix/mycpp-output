// _gen/asdl/examples/typed_demo.asdl.cc is generated by asdl_main.py

#include "_gen/asdl/examples/typed_demo.asdl.h"
#include <assert.h>
#include "prebuilt/asdl/runtime.mycpp.h"  // generated code uses wrappers here
#include "_gen/asdl/examples/demo_lib.asdl.h"  // "use" in ASDL

// Generated code uses these types
using hnode_asdl::hnode;
using hnode_asdl::Field;
using hnode_asdl::color_e;


namespace typed_demo_asdl {

BigStr* op_id_str(op_id_e tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case op_id_e::Plus:
    v = "Plus"; break;
  case op_id_e::Minus:
    v = "Minus"; break;
  case op_id_e::Star:
    v = "Star"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "op_id.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* op_array::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("op_array"));
  List<Field*>* L = out_node->fields;

  if (this->ops != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<op_id_t> it(this->ops); !it.Done(); it.Next()) {
      op_id_t v_ = it.Value();
      hnode_t* h = Alloc<hnode::Leaf>(op_id_str(v_), color_e::TypeName);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("ops"), x0));
  }

  return out_node;
}


hnode_t* assign::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("assign"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->name);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  if (this->flags != nullptr) {  // List
    hnode::Array* x1 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<BigStr*> it(this->flags); !it.Done(); it.Next()) {
      BigStr* v_ = it.Value();
      hnode_t* h = ToPretty(v_);
      x1->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("flags"), x1));
  }

  return out_node;
}

BigStr* cflow_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case cflow_e::Break:
    v = "Break"; break;
  case cflow_e::Continue:
    v = "Continue"; break;
  case cflow_e::Return:
    v = "Return"; break;
  case cflow_e::PrimitiveList:
    v = "PrimitiveList"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "cflow.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

cflow__Break* cflow::Break = &gcflow__Break.obj;

GcGlobal<cflow__Break> gcflow__Break = 
  { ObjHeader::Global(cflow_e::Break) };

cflow__Continue* cflow::Continue = &gcflow__Continue.obj;

GcGlobal<cflow__Continue> gcflow__Continue = 
  { ObjHeader::Global(cflow_e::Continue) };

hnode_t* cflow__Break::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  return out_node;
}


hnode_t* cflow__Continue::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  return out_node;
}


hnode_t* cflow__Return::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->status);
  L->append(Alloc<Field>(StrFromC("status"), x0));

  return out_node;
}


hnode_t* cflow__PrimitiveList::PrettyTree(bool do_abbrev, Dict<int, bool>*
                                          seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow_str(this->tag()));
  List<Field*>* L = out_node->fields;

  if (this->ints != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<int> it(this->ints); !it.Done(); it.Next()) {
      int v_ = it.Value();
      hnode_t* h = ToPretty(v_);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("ints"), x0));
  }

  return out_node;
}


hnode_t* cflow_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case cflow_e::Break: {
    cflow__Break* obj = static_cast<cflow__Break*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow_e::Continue: {
    cflow__Continue* obj = static_cast<cflow__Continue*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow_e::Return: {
    cflow__Return* obj = static_cast<cflow__Return*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow_e::PrimitiveList: {
    cflow__PrimitiveList* obj = static_cast<cflow__PrimitiveList*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}
BigStr* cflow2_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case cflow2_e::Break:
    v = "Break"; break;
  case cflow2_e::Continue:
    v = "Continue"; break;
  case cflow2_e::Return:
    v = "Return"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "cflow2.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

cflow2__Break* cflow2::Break = &gcflow2__Break.obj;

GcGlobal<cflow2__Break> gcflow2__Break = 
  { ObjHeader::Global(cflow2_e::Break) };

cflow2__Continue* cflow2::Continue = &gcflow2__Continue.obj;

GcGlobal<cflow2__Continue> gcflow2__Continue = 
  { ObjHeader::Global(cflow2_e::Continue) };

hnode_t* cflow2__Break::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow2_str(this->tag()));
  return out_node;
}


hnode_t* cflow2__Continue::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow2_str(this->tag()));
  return out_node;
}


hnode_t* cflow2__Return::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(cflow2_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->status);
  L->append(Alloc<Field>(StrFromC("status"), x0));

  return out_node;
}


hnode_t* cflow2_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case cflow2_e::Break: {
    cflow2__Break* obj = static_cast<cflow2__Break*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow2_e::Continue: {
    cflow2__Continue* obj = static_cast<cflow2__Continue*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case cflow2_e::Return: {
    cflow2__Return* obj = static_cast<cflow2__Return*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* source_location::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("source_location"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->path);
  L->append(Alloc<Field>(StrFromC("path"), x0));

  hnode_t* x1 = ToPretty(this->line);
  L->append(Alloc<Field>(StrFromC("line"), x1));

  hnode_t* x2 = ToPretty(this->col);
  L->append(Alloc<Field>(StrFromC("col"), x2));

  hnode_t* x3 = ToPretty(this->length);
  L->append(Alloc<Field>(StrFromC("length"), x3));

  return out_node;
}


hnode_t* word::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("word"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->value);
  L->append(Alloc<Field>(StrFromC("value"), x0));

  return out_node;
}


hnode_t* Token::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("Token"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->s);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  hnode_t* x1 = ToPretty(this->b);
  L->append(Alloc<Field>(StrFromC("b"), x1));

  return out_node;
}

BigStr* word_part_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case word_part_e::Literal:
    v = "Literal"; break;
  case word_part_e::BoolSub:
    v = "BoolSub"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "word_part.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* word_part__BoolSub::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(word_part_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->b->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("b"), x0));

  return out_node;
}


hnode_t* word_part_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case word_part_e::Literal: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case word_part_e::BoolSub: {
    word_part__BoolSub* obj = static_cast<word_part__BoolSub*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}
BigStr* word2_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case word2_e::Operator:
    v = "Operator"; break;
  case word2_e::Compound:
    v = "Compound"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "word2.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* word2__Compound::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(word2_str(this->tag()));
  List<Field*>* L = out_node->fields;

  if (this->parts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word_part_t*> it(this->parts); !it.Done(); it.Next()) {
      word_part_t* v_ = it.Value();
      hnode_t* h = (v_ == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                    color_e::OtherConst) : v_->PrettyTree(do_abbrev, seen);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("parts"), x0));
  }

  return out_node;
}


hnode_t* word2_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case word2_e::Operator: {
    Token* obj = static_cast<Token*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case word2_e::Compound: {
    word2__Compound* obj = static_cast<word2__Compound*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}
BigStr* bool_expr_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case bool_expr_e::WordTest:
    v = "WordTest"; break;
  case bool_expr_e::Unary:
    v = "Unary"; break;
  case bool_expr_e::Binary:
    v = "Binary"; break;
  case bool_expr_e::LogicalNot:
    v = "LogicalNot"; break;
  case bool_expr_e::LogicalBinary:
    v = "LogicalBinary"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "bool_expr.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* bool_expr__WordTest::PrettyTree(bool do_abbrev, Dict<int, bool>* seen)
                                         {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(bool_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("child"), x0));

  return out_node;
}


hnode_t* bool_expr__Unary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(bool_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->child->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("child"), x0));

  return out_node;
}


hnode_t* bool_expr__Binary::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(bool_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->left->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("left"), x0));

  hnode_t* x1 = this->right->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("right"), x1));

  return out_node;
}


hnode_t* bool_expr__LogicalNot::PrettyTree(bool do_abbrev, Dict<int, bool>*
                                           seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(bool_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->b->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("b"), x0));

  return out_node;
}


hnode_t* bool_expr__LogicalBinary::PrettyTree(bool do_abbrev, Dict<int, bool>*
                                              seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(bool_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = Alloc<hnode::Leaf>(op_id_str(this->op), color_e::TypeName);
  L->append(Alloc<Field>(StrFromC("op"), x0));

  hnode_t* x1 = this->left->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("left"), x1));

  hnode_t* x2 = this->right->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("right"), x2));

  return out_node;
}


hnode_t* bool_expr_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case bool_expr_e::WordTest: {
    bool_expr__WordTest* obj = static_cast<bool_expr__WordTest*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case bool_expr_e::Unary: {
    bool_expr__Unary* obj = static_cast<bool_expr__Unary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case bool_expr_e::Binary: {
    bool_expr__Binary* obj = static_cast<bool_expr__Binary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case bool_expr_e::LogicalNot: {
    bool_expr__LogicalNot* obj = static_cast<bool_expr__LogicalNot*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case bool_expr_e::LogicalBinary: {
    bool_expr__LogicalBinary* obj =
static_cast<bool_expr__LogicalBinary*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* Dicts::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("Dicts"));
  List<Field*>* L = out_node->fields;

  if (this->ss != nullptr) {  // Dict
    auto* unnamed = NewList<hnode_t*>();
    auto* hdict = Alloc<hnode::Record>(kEmptyString, StrFromC("{"),
                                                                 StrFromC("}"),
                                                                 NewList<Field*>(), unnamed);
    for (DictIter<BigStr*, BigStr*> it(this->ss); !it.Done(); it.Next()) {
      auto k = it.Key();
      auto v = it.Value();
      unnamed->append(ToPretty(k));
      unnamed->append(ToPretty(v));
    }
    L->append(Alloc<Field>(StrFromC("ss"), hdict));
  }

  if (this->ib != nullptr) {  // Dict
    auto* unnamed = NewList<hnode_t*>();
    auto* hdict = Alloc<hnode::Record>(kEmptyString, StrFromC("{"),
                                                                 StrFromC("}"),
                                                                 NewList<Field*>(), unnamed);
    for (DictIter<int, bool> it(this->ib); !it.Done(); it.Next()) {
      auto k = it.Key();
      auto v = it.Value();
      unnamed->append(ToPretty(k));
      unnamed->append(ToPretty(v));
    }
    L->append(Alloc<Field>(StrFromC("ib"), hdict));
  }

  if (this->tokens != nullptr) {  // Dict
    auto* unnamed = NewList<hnode_t*>();
    auto* hdict = Alloc<hnode::Record>(kEmptyString, StrFromC("{"),
                                                                 StrFromC("}"),
                                                                 NewList<Field*>(), unnamed);
    for (DictIter<BigStr*, Token*> it(this->tokens); !it.Done(); it.Next()) {
      auto k = it.Key();
      auto v = it.Value();
      unnamed->append(ToPretty(k));
      unnamed->append(v->PrettyTree(do_abbrev, seen));
    }
    L->append(Alloc<Field>(StrFromC("tokens"), hdict));
  }

  return out_node;
}

BigStr* flag_type_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case flag_type_e::Bool:
    v = "Bool"; break;
  case flag_type_e::Int:
    v = "Int"; break;
  case flag_type_e::Float:
    v = "Float"; break;
  case flag_type_e::Str:
    v = "Str"; break;
  case flag_type_e::Enum:
    v = "Enum"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "flag_type.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

flag_type__Bool* flag_type::Bool = &gflag_type__Bool.obj;

GcGlobal<flag_type__Bool> gflag_type__Bool = 
  { ObjHeader::Global(flag_type_e::Bool) };

flag_type__Int* flag_type::Int = &gflag_type__Int.obj;

GcGlobal<flag_type__Int> gflag_type__Int = 
  { ObjHeader::Global(flag_type_e::Int) };

flag_type__Float* flag_type::Float = &gflag_type__Float.obj;

GcGlobal<flag_type__Float> gflag_type__Float = 
  { ObjHeader::Global(flag_type_e::Float) };

flag_type__Str* flag_type::Str = &gflag_type__Str.obj;

GcGlobal<flag_type__Str> gflag_type__Str = 
  { ObjHeader::Global(flag_type_e::Str) };

hnode_t* flag_type__Bool::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(flag_type_str(this->tag()));
  return out_node;
}


hnode_t* flag_type__Int::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(flag_type_str(this->tag()));
  return out_node;
}


hnode_t* flag_type__Float::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(flag_type_str(this->tag()));
  return out_node;
}


hnode_t* flag_type__Str::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(flag_type_str(this->tag()));
  return out_node;
}


hnode_t* flag_type__Enum::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(flag_type_str(this->tag()));
  List<Field*>* L = out_node->fields;

  if (this->alts != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<BigStr*> it(this->alts); !it.Done(); it.Next()) {
      BigStr* v_ = it.Value();
      hnode_t* h = ToPretty(v_);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("alts"), x0));
  }

  return out_node;
}


hnode_t* flag_type_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case flag_type_e::Bool: {
    flag_type__Bool* obj = static_cast<flag_type__Bool*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case flag_type_e::Int: {
    flag_type__Int* obj = static_cast<flag_type__Int*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case flag_type_e::Float: {
    flag_type__Float* obj = static_cast<flag_type__Float*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case flag_type_e::Str: {
    flag_type__Str* obj = static_cast<flag_type__Str*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case flag_type_e::Enum: {
    flag_type__Enum* obj = static_cast<flag_type__Enum*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* SetToArg_::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("SetToArg_"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->name);
  L->append(Alloc<Field>(StrFromC("name"), x0));

  hnode_t* x1 = this->flag_type->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("flag_type"), x1));

  hnode_t* x2 = ToPretty(this->quit_parsing_flags);
  L->append(Alloc<Field>(StrFromC("quit_parsing_flags"), x2));

  return out_node;
}


hnode_t* Strings::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("Strings"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->required);
  L->append(Alloc<Field>(StrFromC("required"), x0));

  if (this->optional) {  // Optional
    hnode_t* x1 = ToPretty(this->optional);
    L->append(Alloc<Field>(StrFromC("optional"), x1));
  }

  return out_node;
}


hnode_t* Maybes::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("Maybes"));
  List<Field*>* L = out_node->fields;

  if (this->op) {  // Optional
    hnode_t* x0 = this->op->PrettyTree(do_abbrev, seen);
    L->append(Alloc<Field>(StrFromC("op"), x0));
  }

  if (this->arg) {  // Optional
    hnode_t* x1 = this->arg->PrettyTree(do_abbrev, seen);
    L->append(Alloc<Field>(StrFromC("arg"), x1));
  }

  return out_node;
}


hnode_t* OptionalList::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("OptionalList"));
  List<Field*>* L = out_node->fields;

  if (this->words != nullptr) {  // List
    hnode::Array* x0 = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
    for (ListIter<word*> it(this->words); !it.Done(); it.Next()) {
      word* v_ = it.Value();
      hnode_t* h = (v_ == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                    color_e::OtherConst) : v_->PrettyTree(do_abbrev, seen);
      x0->children->append(h);
    }
    L->append(Alloc<Field>(StrFromC("words"), x0));
  }

  return out_node;
}

BigStr* arith_expr_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case arith_expr_e::NoOp:
    v = "NoOp"; break;
  case arith_expr_e::Const:
    v = "Const"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "arith_expr.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

arith_expr__NoOp* arith_expr::NoOp = &garith_expr__NoOp.obj;

GcGlobal<arith_expr__NoOp> garith_expr__NoOp = 
  { ObjHeader::Global(arith_expr_e::NoOp) };

hnode_t* arith_expr__NoOp::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  return out_node;
}


hnode_t* arith_expr__Const::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(arith_expr_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->i);
  L->append(Alloc<Field>(StrFromC("i"), x0));

  return out_node;
}


hnode_t* arith_expr_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case arith_expr_e::NoOp: {
    arith_expr__NoOp* obj = static_cast<arith_expr__NoOp*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case arith_expr_e::Const: {
    arith_expr__Const* obj = static_cast<arith_expr__Const*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* CompoundWord::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Array* out_node = Alloc<hnode::Array>(Alloc<List<hnode_t*>>());
  for (ListIter<arith_expr_t*> it(this); !it.Done(); it.Next()) {
    arith_expr_t* v_ = it.Value();
    hnode_t* h = (v_ == nullptr) ? Alloc<hnode::Leaf>(StrFromC("_"),
                  color_e::OtherConst) : v_->PrettyTree(do_abbrev, seen);
    out_node->children->append(h);
  }
  return out_node;
}

BigStr* a_word_str(int tag, bool dot) {
  char buf[32];
  const char* v = nullptr;
  switch (tag) {
  case a_word_e::String:
    v = "String"; break;
  case a_word_e::CompoundWord:
    v = "CompoundWord"; break;
  default:
    assert(0);
  }
  if (dot) {
    snprintf(buf, 32, "a_word.%s", v);
    return StrFromC(buf);
  } else {
    return StrFromC(v);
  }
}

hnode_t* a_word__String::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(a_word_str(this->tag()));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = ToPretty(this->s);
  L->append(Alloc<Field>(StrFromC("s"), x0));

  return out_node;
}


hnode_t* a_word_t::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  switch (this->tag()) {
  case a_word_e::String: {
    a_word__String* obj = static_cast<a_word__String*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  case a_word_e::CompoundWord: {
    CompoundWord* obj = static_cast<CompoundWord*>(this);
    return obj->PrettyTree(do_abbrev, seen);
  }
  default:
    assert(0);
  }
}

hnode_t* foo::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("foo"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->x->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("x"), x0));

  hnode_t* x1 = this->y->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("y"), x1));

  return out_node;
}


hnode_t* ContainsLib::PrettyTree(bool do_abbrev, Dict<int, bool>* seen) {
  seen = seen ? seen : Alloc<Dict<int, bool>>();
  int heap_id = ObjectId(this);
  if (dict_contains(seen, heap_id)) {
    return Alloc<hnode::AlreadySeen>(heap_id);
  }
  seen->set(heap_id, true);

  hnode::Record* out_node = runtime::NewRecord(StrFromC("ContainsLib"));
  List<Field*>* L = out_node->fields;

  hnode_t* x0 = this->t->PrettyTree(do_abbrev, seen);
  L->append(Alloc<Field>(StrFromC("t"), x0));

  return out_node;
}


}  // namespace typed_demo_asdl
