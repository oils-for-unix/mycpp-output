// _gen/asdl/examples/shared_variant.asdl.h is generated by asdl_main.py

#ifndef SHARED_VARIANT_ASDL
#define SHARED_VARIANT_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "asdl/cpp_runtime.h"
namespace shared_variant_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class prod;
class DoubleQuoted;
class expr_t;
class Token;
class tok_t;
class tok_struct;
class tok_array;
class word_part_t;
class cflow_t;

ASDL_NAMES expr_e {
  enum no_name {
  Binary = 1,
  DoubleQuoted = 65,
  };
};

BigStr* expr_str(int tag, bool dot = true);

class expr_t {
 protected:
  expr_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 256;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(expr_t)
};

class expr__Binary : public expr_t {
 public:
  expr__Binary(expr_t* left, expr_t* right)
      : left(left),
        right(right) {
  }

  static expr__Binary* CreateNull(bool alloc_lists = false) { 
    return Alloc<expr__Binary>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(expr_e::Binary), 2);
  }
  expr_t* left;
  expr_t* right;

  DISALLOW_COPY_AND_ASSIGN(expr__Binary)
};

ASDL_NAMES expr {
  typedef expr__Binary Binary;
};

ASDL_NAMES tok_e {
  enum no_name {
  Eof = 1,
  Token = 66,
  };
};

BigStr* tok_str(int tag, bool dot = true);

class tok_t {
 protected:
  tok_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 320;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(tok_t)
};

class tok__Eof : public tok_t {
 public:
  tok__Eof() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(tok_e::Eof), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(tok__Eof)
};

extern GcGlobal<tok__Eof> gtok__Eof;
ASDL_NAMES tok {
  static tok__Eof* Eof;
};

ASDL_NAMES word_part_e {
  enum no_name {
  Literal = 1,
  DoubleQuoted = 65,
  };
};

BigStr* word_part_str(int tag, bool dot = true);

class word_part_t {
 protected:
  word_part_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 384;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(word_part_t)
};

class word_part__Literal : public word_part_t {
 public:
  word_part__Literal(BigStr* s)
      : s(s) {
  }

  static word_part__Literal* CreateNull(bool alloc_lists = false) { 
    return Alloc<word_part__Literal>(kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(word_part_e::Literal), 1);
  }
  BigStr* s;

  DISALLOW_COPY_AND_ASSIGN(word_part__Literal)
};

ASDL_NAMES word_part {
  typedef word_part__Literal Literal;
};

ASDL_NAMES cflow_e {
  enum no_name {
  Break = 1,
  Continue = 2,
  Return = 3,
  };
};

BigStr* cflow_str(int tag, bool dot = true);

class cflow_t {
 protected:
  cflow_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 448;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(cflow_t)
};

class cflow__Break : public cflow_t {
 public:
  cflow__Break() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Break), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow__Break)
};

class cflow__Continue : public cflow_t {
 public:
  cflow__Continue() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Continue), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow__Continue)
};

class cflow__Return : public cflow_t {
 public:
  cflow__Return(int val)
      : val(val) {
  }

  static cflow__Return* CreateNull(bool alloc_lists = false) { 
    return Alloc<cflow__Return>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Return), 0);
  }
  int val;

  DISALLOW_COPY_AND_ASSIGN(cflow__Return)
};

extern GcGlobal<cflow__Break> gcflow__Break;
extern GcGlobal<cflow__Continue> gcflow__Continue;
ASDL_NAMES cflow {
  static cflow__Break* Break;
  static cflow__Continue* Continue;
  typedef cflow__Return Return;
};

class prod {
 public:
  prod(BigStr* a, BigStr* b)
      : a(a),
        b(b) {
  }

  static prod* CreateNull(bool alloc_lists = false) { 
    return Alloc<prod>(kEmptyString, kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(64, 2);
  }
  BigStr* a;
  BigStr* b;

  DISALLOW_COPY_AND_ASSIGN(prod)
};

class DoubleQuoted : public expr_t, public word_part_t {
 public:
  DoubleQuoted(int left, List<BigStr*>* tokens)
      : tokens(tokens),
        left(left) {
  }

  static DoubleQuoted* CreateNull(bool alloc_lists = false) { 
    return Alloc<DoubleQuoted>(-1, alloc_lists ? Alloc<List<BigStr*>>() :
                               nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(65, 1);
  }
  List<BigStr*>* tokens;
  int left;

  DISALLOW_COPY_AND_ASSIGN(DoubleQuoted)
};

class Token : public tok_t {
 public:
  Token(int id, BigStr* val)
      : val(val),
        id(id) {
  }

  static Token* CreateNull(bool alloc_lists = false) { 
    return Alloc<Token>(-1, kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(66, 1);
  }
  BigStr* val;
  int id;

  DISALLOW_COPY_AND_ASSIGN(Token)
};

class tok_struct {
 public:
  tok_struct(tok_t* token, int x)
      : token(token),
        x(x) {
  }

  static tok_struct* CreateNull(bool alloc_lists = false) { 
    return Alloc<tok_struct>(nullptr, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(67, 1);
  }
  tok_t* token;
  int x;

  DISALLOW_COPY_AND_ASSIGN(tok_struct)
};

class tok_array {
 public:
  tok_array(List<tok_t*>* tokens)
      : tokens(tokens) {
  }

  static tok_array* CreateNull(bool alloc_lists = false) { 
    return Alloc<tok_array>(alloc_lists ? Alloc<List<tok_t*>>() : nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(68, 1);
  }
  List<tok_t*>* tokens;

  DISALLOW_COPY_AND_ASSIGN(tok_array)
};


}  // namespace shared_variant_asdl

#endif  // SHARED_VARIANT_ASDL
