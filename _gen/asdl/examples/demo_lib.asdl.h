// _gen/asdl/examples/demo_lib.asdl.h is generated by asdl_main.py

#ifndef DEMO_LIB_ASDL
#define DEMO_LIB_ASDL

#include <cstdint>
#include "mycpp/runtime.h"

#include "asdl/cpp_runtime.h"
namespace demo_lib_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class value_t;
class t2;
class t3;
class t4;
class LibToken;

ASDL_NAMES value_e {
  enum no_name {
  Str = 1,
  Array = 2,
  };
};

BigStr* value_str(int tag, bool dot = true);

class value_t {
 protected:
  value_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(value_t)
};

class value__Str : public value_t {
 public:
  value__Str() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(value_e::Str), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(value__Str)
};

class value__Array : public value_t {
 public:
  value__Array(int a)
      : a(a) {
  }

  static value__Array* CreateNull(bool alloc_lists = false) { 
    return Alloc<value__Array>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(value_e::Array), 0);
  }
  int a;

  DISALLOW_COPY_AND_ASSIGN(value__Array)
};

extern GcGlobal<value__Str> gvalue__Str;
ASDL_NAMES value {
  static value__Str* Str;
  typedef value__Array Array;
};

class t2 {
 public:
  t2(int a, int b)
      : a(a),
        b(b) {
  }

  static t2* CreateNull(bool alloc_lists = false) { 
    return Alloc<t2>(-1, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(64, 0);
  }
  int a;
  int b;

  DISALLOW_COPY_AND_ASSIGN(t2)
};

class t3 {
 public:
  t3(int a, int b)
      : a(a),
        b(b) {
  }

  static t3* CreateNull(bool alloc_lists = false) { 
    return Alloc<t3>(-1, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(65, 0);
  }
  int a;
  int b;

  DISALLOW_COPY_AND_ASSIGN(t3)
};

class t4 {
 public:
  t4(int a, int b)
      : a(a),
        b(b) {
  }

  static t4* CreateNull(bool alloc_lists = false) { 
    return Alloc<t4>(-1, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(66, 0);
  }
  int a;
  int b;

  DISALLOW_COPY_AND_ASSIGN(t4)
};

class LibToken {
 public:
  LibToken(BigStr* s, int i)
      : s(s),
        i(i) {
  }

  static LibToken* CreateNull(bool alloc_lists = false) { 
    return Alloc<LibToken>(kEmptyString, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(67, 1);
  }
  BigStr* s;
  int i;

  DISALLOW_COPY_AND_ASSIGN(LibToken)
};


}  // namespace demo_lib_asdl

#endif  // DEMO_LIB_ASDL
