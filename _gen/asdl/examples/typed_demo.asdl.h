// _gen/asdl/examples/typed_demo.asdl.h is generated by asdl_main.py

#ifndef TYPED_DEMO_ASDL
#define TYPED_DEMO_ASDL

#include <cstdint>

#include "mycpp/runtime.h"
#include "asdl/cpp_runtime.h"
namespace demo_lib_asdl { class value_t; class LibToken; }

namespace typed_demo {
class _Callable {
 public:
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen);
};
}
namespace typed_demo_asdl {

// use struct instead of namespace so 'using' works consistently
#define ASDL_NAMES struct

class op_array;
class assign;
class cflow_t;
class cflow2_t;
class source_location;
class word;
class Token;
class word_part_t;
class word2_t;
class bool_expr_t;
class Dicts;
class flag_type_t;
class SetToArg_;
class Strings;
class Maybes;
class OptionalList;
class arith_expr_t;
class a_word_t;
class foo;
class ContainsLib;

enum class op_id_e {
  Plus = 1,
  Minus = 2,
  Star = 3,
};
typedef op_id_e op_id_t;

BigStr* op_id_str(op_id_e tag, bool dot = true);

ASDL_NAMES cflow_e {
  enum no_name {
  Break = 1,
  Continue = 2,
  Return = 3,
  PrimitiveList = 4,
  };
};

BigStr* cflow_str(int tag, bool dot = true);

class cflow_t {
 protected:
  cflow_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 256;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(cflow_t)
};

class cflow__Break : public cflow_t {
 public:
  cflow__Break() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Break), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow__Break)
};

class cflow__Continue : public cflow_t {
 public:
  cflow__Continue() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Continue), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow__Continue)
};

class cflow__Return : public cflow_t {
 public:
  cflow__Return(int status)
      : status(status) {
  }

  static cflow__Return* CreateNull(bool alloc_lists = false) { 
    return Alloc<cflow__Return>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::Return), 0);
  }
  int status;

  DISALLOW_COPY_AND_ASSIGN(cflow__Return)
};

class cflow__PrimitiveList : public cflow_t {
 public:
  cflow__PrimitiveList(List<int>* ints)
      : ints(ints) {
  }

  static cflow__PrimitiveList* CreateNull(bool alloc_lists = false) { 
    return Alloc<cflow__PrimitiveList>(alloc_lists ? Alloc<List<int>>() :
                                       nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow_e::PrimitiveList),
                                1);
  }
  List<int>* ints;

  DISALLOW_COPY_AND_ASSIGN(cflow__PrimitiveList)
};

extern GcGlobal<cflow__Break> gcflow__Break;
extern GcGlobal<cflow__Continue> gcflow__Continue;
ASDL_NAMES cflow {
  static cflow__Break* Break;
  static cflow__Continue* Continue;
  typedef cflow__Return Return;
  typedef cflow__PrimitiveList PrimitiveList;
};

ASDL_NAMES cflow2_e {
  enum no_name {
  Break = 1,
  Continue = 2,
  Return = 3,
  };
};

BigStr* cflow2_str(int tag, bool dot = true);

class cflow2_t {
 protected:
  cflow2_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 320;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(cflow2_t)
};

class cflow2__Break : public cflow2_t {
 public:
  cflow2__Break() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow2_e::Break), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow2__Break)
};

class cflow2__Continue : public cflow2_t {
 public:
  cflow2__Continue() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow2_e::Continue), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(cflow2__Continue)
};

class cflow2__Return : public cflow2_t {
 public:
  cflow2__Return(int status)
      : status(status) {
  }

  static cflow2__Return* CreateNull(bool alloc_lists = false) { 
    return Alloc<cflow2__Return>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(cflow2_e::Return), 0);
  }
  int status;

  DISALLOW_COPY_AND_ASSIGN(cflow2__Return)
};

extern GcGlobal<cflow2__Break> gcflow2__Break;
extern GcGlobal<cflow2__Continue> gcflow2__Continue;
ASDL_NAMES cflow2 {
  static cflow2__Break* Break;
  static cflow2__Continue* Continue;
  typedef cflow2__Return Return;
};

ASDL_NAMES word_part_e {
  enum no_name {
  Literal = 68,
  BoolSub = 2,
  };
};

BigStr* word_part_str(int tag, bool dot = true);

class word_part_t {
 protected:
  word_part_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 384;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(word_part_t)
};

class word_part__BoolSub : public word_part_t {
 public:
  word_part__BoolSub(bool_expr_t* b)
      : b(b) {
  }

  static word_part__BoolSub* CreateNull(bool alloc_lists = false) { 
    return Alloc<word_part__BoolSub>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(word_part_e::BoolSub), 1);
  }
  bool_expr_t* b;

  DISALLOW_COPY_AND_ASSIGN(word_part__BoolSub)
};

ASDL_NAMES word_part {
  typedef word_part__BoolSub BoolSub;
};

ASDL_NAMES word2_e {
  enum no_name {
  Operator = 68,
  Compound = 2,
  };
};

BigStr* word2_str(int tag, bool dot = true);

class word2_t {
 protected:
  word2_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 448;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(word2_t)
};

class word2__Compound : public word2_t {
 public:
  word2__Compound(List<word_part_t*>* parts)
      : parts(parts) {
  }

  static word2__Compound* CreateNull(bool alloc_lists = false) { 
    return Alloc<word2__Compound>(alloc_lists ? Alloc<List<word_part_t*>>() :
                                  nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(word2_e::Compound), 1);
  }
  List<word_part_t*>* parts;

  DISALLOW_COPY_AND_ASSIGN(word2__Compound)
};

ASDL_NAMES word2 {
  typedef word2__Compound Compound;
};

ASDL_NAMES bool_expr_e {
  enum no_name {
  WordTest = 1,
  Unary = 2,
  Binary = 3,
  LogicalNot = 4,
  LogicalBinary = 5,
  };
};

BigStr* bool_expr_str(int tag, bool dot = true);

class bool_expr_t {
 protected:
  bool_expr_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 512;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(bool_expr_t)
};

class bool_expr__WordTest : public bool_expr_t {
 public:
  bool_expr__WordTest(word2_t* child)
      : child(child) {
  }

  static bool_expr__WordTest* CreateNull(bool alloc_lists = false) { 
    return Alloc<bool_expr__WordTest>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(bool_expr_e::WordTest),
                                1);
  }
  word2_t* child;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__WordTest)
};

class bool_expr__Unary : public bool_expr_t {
 public:
  bool_expr__Unary(word* child)
      : child(child) {
  }

  static bool_expr__Unary* CreateNull(bool alloc_lists = false) { 
    return Alloc<bool_expr__Unary>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(bool_expr_e::Unary), 1);
  }
  word* child;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Unary)
};

class bool_expr__Binary : public bool_expr_t {
 public:
  bool_expr__Binary(word* left, word* right)
      : left(left),
        right(right) {
  }

  static bool_expr__Binary* CreateNull(bool alloc_lists = false) { 
    return Alloc<bool_expr__Binary>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(bool_expr_e::Binary), 2);
  }
  word* left;
  word* right;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__Binary)
};

class bool_expr__LogicalNot : public bool_expr_t {
 public:
  bool_expr__LogicalNot(bool_expr_t* b)
      : b(b) {
  }

  static bool_expr__LogicalNot* CreateNull(bool alloc_lists = false) { 
    return Alloc<bool_expr__LogicalNot>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(bool_expr_e::LogicalNot),
                                1);
  }
  bool_expr_t* b;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalNot)
};

class bool_expr__LogicalBinary : public bool_expr_t {
 public:
  bool_expr__LogicalBinary(op_id_t op, bool_expr_t* left, bool_expr_t* right)
      : left(left),
        right(right),
        op(op) {
  }

  static bool_expr__LogicalBinary* CreateNull(bool alloc_lists = false) { 
    return Alloc<bool_expr__LogicalBinary>(op_id_e::Plus, nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return
  ObjHeader::AsdlClass(static_cast<uint16_t>(bool_expr_e::LogicalBinary), 2);
  }
  bool_expr_t* left;
  bool_expr_t* right;
  op_id_t op;

  DISALLOW_COPY_AND_ASSIGN(bool_expr__LogicalBinary)
};

ASDL_NAMES bool_expr {
  typedef bool_expr__WordTest WordTest;
  typedef bool_expr__Unary Unary;
  typedef bool_expr__Binary Binary;
  typedef bool_expr__LogicalNot LogicalNot;
  typedef bool_expr__LogicalBinary LogicalBinary;
};

ASDL_NAMES flag_type_e {
  enum no_name {
  Bool = 1,
  Int = 2,
  Float = 3,
  Str = 4,
  Enum = 5,
  };
};

BigStr* flag_type_str(int tag, bool dot = true);

class flag_type_t {
 protected:
  flag_type_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 576;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(flag_type_t)
};

class flag_type__Bool : public flag_type_t {
 public:
  flag_type__Bool() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(flag_type_e::Bool), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(flag_type__Bool)
};

class flag_type__Int : public flag_type_t {
 public:
  flag_type__Int() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(flag_type_e::Int), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(flag_type__Int)
};

class flag_type__Float : public flag_type_t {
 public:
  flag_type__Float() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(flag_type_e::Float), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(flag_type__Float)
};

class flag_type__Str : public flag_type_t {
 public:
  flag_type__Str() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(flag_type_e::Str), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(flag_type__Str)
};

class flag_type__Enum : public flag_type_t {
 public:
  flag_type__Enum(List<BigStr*>* alts)
      : alts(alts) {
  }

  static flag_type__Enum* CreateNull(bool alloc_lists = false) { 
    return Alloc<flag_type__Enum>(alloc_lists ? Alloc<List<BigStr*>>() :
                                  nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(flag_type_e::Enum), 1);
  }
  List<BigStr*>* alts;

  DISALLOW_COPY_AND_ASSIGN(flag_type__Enum)
};

extern GcGlobal<flag_type__Bool> gflag_type__Bool;
extern GcGlobal<flag_type__Int> gflag_type__Int;
extern GcGlobal<flag_type__Float> gflag_type__Float;
extern GcGlobal<flag_type__Str> gflag_type__Str;
ASDL_NAMES flag_type {
  static flag_type__Bool* Bool;
  static flag_type__Int* Int;
  static flag_type__Float* Float;
  static flag_type__Str* Str;
  typedef flag_type__Enum Enum;
};

ASDL_NAMES arith_expr_e {
  enum no_name {
  NoOp = 1,
  Const = 2,
  };
};

BigStr* arith_expr_str(int tag, bool dot = true);

class arith_expr_t {
 protected:
  arith_expr_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 640;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(arith_expr_t)
};

class arith_expr__NoOp : public arith_expr_t {
 public:
  arith_expr__NoOp() {}

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::NoOp), 0);
  }

  DISALLOW_COPY_AND_ASSIGN(arith_expr__NoOp)
};

class arith_expr__Const : public arith_expr_t {
 public:
  arith_expr__Const(int i)
      : i(i) {
  }

  static arith_expr__Const* CreateNull(bool alloc_lists = false) { 
    return Alloc<arith_expr__Const>(-1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(arith_expr_e::Const), 0);
  }
  int i;

  DISALLOW_COPY_AND_ASSIGN(arith_expr__Const)
};

extern GcGlobal<arith_expr__NoOp> garith_expr__NoOp;
ASDL_NAMES arith_expr {
  static arith_expr__NoOp* NoOp;
  typedef arith_expr__Const Const;
};

ASDL_NAMES a_word_e {
  enum no_name {
  String = 1,
  CompoundWord = 74,
  };
};

BigStr* a_word_str(int tag, bool dot = true);

class a_word_t {
 protected:
  a_word_t() {
  }
 public:
  int tag() const {
    return ObjHeader::FromObject(this)->type_tag;
  }
  constexpr int sum_type_id() {
    return 704;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);

  DISALLOW_COPY_AND_ASSIGN(a_word_t)
};

class a_word__String : public a_word_t {
 public:
  a_word__String(BigStr* s)
      : s(s) {
  }

  static a_word__String* CreateNull(bool alloc_lists = false) { 
    return Alloc<a_word__String>(kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return this->sum_type_id() + this->tag();
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(static_cast<uint16_t>(a_word_e::String), 1);
  }
  BigStr* s;

  DISALLOW_COPY_AND_ASSIGN(a_word__String)
};

ASDL_NAMES a_word {
  typedef a_word__String String;
};

class op_array {
 public:
  op_array(List<op_id_t>* ops)
      : ops(ops) {
  }

  static op_array* CreateNull(bool alloc_lists = false) { 
    return Alloc<op_array>(alloc_lists ? Alloc<List<op_id_t>>() : nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(64, 1);
  }
  List<op_id_t>* ops;

  DISALLOW_COPY_AND_ASSIGN(op_array)
};

class assign {
 public:
  assign(BigStr* name, List<BigStr*>* flags)
      : name(name),
        flags(flags) {
  }

  static assign* CreateNull(bool alloc_lists = false) { 
    return Alloc<assign>(kEmptyString, alloc_lists ? Alloc<List<BigStr*>>() :
                         nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(65, 2);
  }
  BigStr* name;
  List<BigStr*>* flags;

  DISALLOW_COPY_AND_ASSIGN(assign)
};

class source_location {
 public:
  source_location(BigStr* path, int line, int col, int length)
      : path(path),
        line(line),
        col(col),
        length(length) {
  }

  static source_location* CreateNull(bool alloc_lists = false) { 
    return Alloc<source_location>(kEmptyString, -1, -1, -1);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(66, 1);
  }
  BigStr* path;
  int line;
  int col;
  int length;

  DISALLOW_COPY_AND_ASSIGN(source_location)
};

class word {
 public:
  word(BigStr* value)
      : value(value) {
  }

  static word* CreateNull(bool alloc_lists = false) { 
    return Alloc<word>(kEmptyString);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(67, 1);
  }
  BigStr* value;

  DISALLOW_COPY_AND_ASSIGN(word)
};

class Token : public word_part_t, public word2_t {
 public:
  Token(BigStr* s, bool b)
      : s(s),
        b(b) {
  }

  static Token* CreateNull(bool alloc_lists = false) { 
    return Alloc<Token>(kEmptyString, false);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(68, 1);
  }
  BigStr* s;
  bool b;

  DISALLOW_COPY_AND_ASSIGN(Token)
};

class Dicts {
 public:
  Dicts(Dict<BigStr*, BigStr*>* ss, Dict<int, bool>* ib, Dict<BigStr*, Token*>*
        tokens)
      : ss(ss),
        ib(ib),
        tokens(tokens) {
  }

  static Dicts* CreateNull(bool alloc_lists = false) { 
    return Alloc<Dicts>(nullptr, nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(69, 3);
  }
  Dict<BigStr*, BigStr*>* ss;
  Dict<int, bool>* ib;
  Dict<BigStr*, Token*>* tokens;

  DISALLOW_COPY_AND_ASSIGN(Dicts)
};

class SetToArg_ {
 public:
  SetToArg_(BigStr* name, flag_type_t* flag_type, bool quit_parsing_flags)
      : name(name),
        flag_type(flag_type),
        quit_parsing_flags(quit_parsing_flags) {
  }

  static SetToArg_* CreateNull(bool alloc_lists = false) { 
    return Alloc<SetToArg_>(kEmptyString, nullptr, false);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(70, 2);
  }
  BigStr* name;
  flag_type_t* flag_type;
  bool quit_parsing_flags;

  DISALLOW_COPY_AND_ASSIGN(SetToArg_)
};

class Strings {
 public:
  Strings(BigStr* required, BigStr* optional)
      : required(required),
        optional(optional) {
  }

  static Strings* CreateNull(bool alloc_lists = false) { 
    return Alloc<Strings>(kEmptyString, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(71, 2);
  }
  BigStr* required;
  BigStr* optional;

  DISALLOW_COPY_AND_ASSIGN(Strings)
};

class Maybes {
 public:
  Maybes(Token* op, word* arg)
      : op(op),
        arg(arg) {
  }

  static Maybes* CreateNull(bool alloc_lists = false) { 
    return Alloc<Maybes>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(72, 2);
  }
  Token* op;
  word* arg;

  DISALLOW_COPY_AND_ASSIGN(Maybes)
};

class OptionalList {
 public:
  OptionalList(List<word*>* words)
      : words(words) {
  }

  static OptionalList* CreateNull(bool alloc_lists = false) { 
    return Alloc<OptionalList>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(73, 1);
  }
  List<word*>* words;

  DISALLOW_COPY_AND_ASSIGN(OptionalList)
};

class foo {
 public:
  foo(typed_demo::_Callable* x, typed_demo::_Callable* y)
      : x(x),
        y(y) {
  }

  static foo* CreateNull(bool alloc_lists = false) { 
    return Alloc<foo>(nullptr, nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(75, 2);
  }
  typed_demo::_Callable* x;
  typed_demo::_Callable* y;

  DISALLOW_COPY_AND_ASSIGN(foo)
};

class ContainsLib {
 public:
  ContainsLib(demo_lib_asdl::LibToken* t)
      : t(t) {
  }

  static ContainsLib* CreateNull(bool alloc_lists = false) { 
    return Alloc<ContainsLib>(nullptr);
  }

  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  int type_id() {
    return ObjHeader::FromObject(this)->type_tag;
  }
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::AsdlClass(76, 1);
  }
  demo_lib_asdl::LibToken* t;

  DISALLOW_COPY_AND_ASSIGN(ContainsLib)
};

class CompoundWord : public a_word_t, public List<arith_expr_t*> {
 public:
  CompoundWord() : List<arith_expr_t*>() {
  }
  CompoundWord(List<arith_expr_t*>* plain_list) :
               List<arith_expr_t*>(plain_list) {
  }
  static CompoundWord* New() {
    return Alloc<CompoundWord>();
  }
  static CompoundWord* Take(List<arith_expr_t*>* plain_list) {
    auto* result = Alloc<CompoundWord>(plain_list);
    plain_list->SetTaken();
    return result;
  }
  hnode_t* PrettyTree(bool do_abbrev, Dict<int, bool>* seen = nullptr);
  
  static constexpr ObjHeader obj_header() {
    return ObjHeader::TaggedSubtype(74, field_mask());
  }
  DISALLOW_COPY_AND_ASSIGN(CompoundWord)
};


}  // namespace typed_demo_asdl

#endif  // TYPED_DEMO_ASDL
